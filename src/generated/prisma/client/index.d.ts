
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model collectivite
 * 
 */
export type collectivite = $Result.DefaultSelection<Prisma.$collectivitePayload>
/**
 * Model user_projet
 * 
 */
export type user_projet = $Result.DefaultSelection<Prisma.$user_projetPayload>
/**
 * Model email
 * 
 */
export type email = $Result.DefaultSelection<Prisma.$emailPayload>
/**
 * Model user_collectivite
 * 
 */
export type user_collectivite = $Result.DefaultSelection<Prisma.$user_collectivitePayload>
/**
 * Model projet
 * 
 */
export type projet = $Result.DefaultSelection<Prisma.$projetPayload>
/**
 * Model projet_fiche
 * 
 */
export type projet_fiche = $Result.DefaultSelection<Prisma.$projet_fichePayload>
/**
 * Model projet_sourcing_contact
 * 
 */
export type projet_sourcing_contact = $Result.DefaultSelection<Prisma.$projet_sourcing_contactPayload>
/**
 * Model estimation
 * 
 */
export type estimation = $Result.DefaultSelection<Prisma.$estimationPayload>
/**
 * Model climadiag
 * 
 */
export type climadiag = $Result.DefaultSelection<Prisma.$climadiagPayload>
/**
 * Model aide
 * 
 */
export type aide = $Result.DefaultSelection<Prisma.$aidePayload>
/**
 * Model estimations_aides
 * 
 */
export type estimations_aides = $Result.DefaultSelection<Prisma.$estimations_aidesPayload>
/**
 * Model estimation_materiaux
 * 
 */
export type estimation_materiaux = $Result.DefaultSelection<Prisma.$estimation_materiauxPayload>
/**
 * Model estimation_fiche_solution
 * 
 */
export type estimation_fiche_solution = $Result.DefaultSelection<Prisma.$estimation_fiche_solutionPayload>
/**
 * Model conversation
 * 
 */
export type conversation = $Result.DefaultSelection<Prisma.$conversationPayload>
/**
 * Model diagnostic_simulation
 * 
 */
export type diagnostic_simulation = $Result.DefaultSelection<Prisma.$diagnostic_simulationPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>
/**
 * Model cron_jobs
 * 
 */
export type cron_jobs = $Result.DefaultSelection<Prisma.$cron_jobsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StatutUser: {
  pas_trouve: 'pas_trouve',
  pas_maintenant: 'pas_maintenant',
  pas_compris: 'pas_compris',
  sans_pfmv: 'sans_pfmv',
  autre: 'autre'
};

export type StatutUser = (typeof StatutUser)[keyof typeof StatutUser]


export const RoleCollectivite: {
  ADMIN: 'ADMIN'
};

export type RoleCollectivite = (typeof RoleCollectivite)[keyof typeof RoleCollectivite]


export const RoleProjet: {
  ADMIN: 'ADMIN',
  EDITEUR: 'EDITEUR',
  LECTEUR: 'LECTEUR'
};

export type RoleProjet = (typeof RoleProjet)[keyof typeof RoleProjet]


export const InvitationStatus: {
  REQUESTED: 'REQUESTED',
  INVITED: 'INVITED',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const emailType: {
  projetCreation: 'projetCreation',
  projetInvitation: 'projetInvitation',
  projetRequestAccess: 'projetRequestAccess',
  projetAccessGranted: 'projetAccessGranted',
  projetAccessDeclined: 'projetAccessDeclined',
  contactMessageSent: 'contactMessageSent',
  welcomeMessage: 'welcomeMessage',
  welcomeMessageV2: 'welcomeMessageV2',
  noActivityAfterSignup: 'noActivityAfterSignup',
  remindNotCompletedDiagnostic: 'remindNotCompletedDiagnostic',
  projetRemindToDoSolution: 'projetRemindToDoSolution',
  projetRemindToDoDiagnostic: 'projetRemindToDoDiagnostic',
  projetRemindToDoEstimation: 'projetRemindToDoEstimation',
  projetRemindToDoFinancement: 'projetRemindToDoFinancement',
  projetUnfinishedInactive: 'projetUnfinishedInactive',
  projetUnfinishedInactive2: 'projetUnfinishedInactive2',
  projetFinishedQuestionnaireSatisfaction: 'projetFinishedQuestionnaireSatisfaction',
  projetFinishedToGetRex: 'projetFinishedToGetRex',
  noProjetAfterSignupMail1: 'noProjetAfterSignupMail1',
  noProjetAfterSignupMail2: 'noProjetAfterSignupMail2',
  noProjetAfterSignupMail3: 'noProjetAfterSignupMail3'
};

export type emailType = (typeof emailType)[keyof typeof emailType]


export const emailStatus: {
  PENDING: 'PENDING',
  ERROR: 'ERROR',
  SUCCESS: 'SUCCESS'
};

export type emailStatus = (typeof emailStatus)[keyof typeof emailStatus]


export const StatutProjet: {
  termine: 'termine',
  en_cours: 'en_cours',
  besoin_aide: 'besoin_aide'
};

export type StatutProjet = (typeof StatutProjet)[keyof typeof StatutProjet]


export const FicheType: {
  DIAGNOSTIC: 'DIAGNOSTIC',
  SOLUTION: 'SOLUTION'
};

export type FicheType = (typeof FicheType)[keyof typeof FicheType]


export const TypeLieuClimadiag: {
  commune: 'commune',
  epci: 'epci'
};

export type TypeLieuClimadiag = (typeof TypeLieuClimadiag)[keyof typeof TypeLieuClimadiag]


export const ReferenceType: {
  USER: 'USER',
  PROJET: 'PROJET',
  ESTIMATION: 'ESTIMATION'
};

export type ReferenceType = (typeof ReferenceType)[keyof typeof ReferenceType]


export const EventType: {
  UPDATE_MATURITE: 'UPDATE_MATURITE',
  UPDATE_STATUT_PROJET: 'UPDATE_STATUT_PROJET',
  UPDATE_STATUT_USER: 'UPDATE_STATUT_USER',
  UPDATE_PROJET_SET_VISIBLE: 'UPDATE_PROJET_SET_VISIBLE',
  UPDATE_PROJET_SET_INVISIBLE: 'UPDATE_PROJET_SET_INVISIBLE'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const JobType: {
  SYNC_HUBSPOT: 'SYNC_HUBSPOT',
  CSM_MAIL_BATCH: 'CSM_MAIL_BATCH',
  SYNC_CONNECT: 'SYNC_CONNECT'
};

export type JobType = (typeof JobType)[keyof typeof JobType]

}

export type StatutUser = $Enums.StatutUser

export const StatutUser: typeof $Enums.StatutUser

export type RoleCollectivite = $Enums.RoleCollectivite

export const RoleCollectivite: typeof $Enums.RoleCollectivite

export type RoleProjet = $Enums.RoleProjet

export const RoleProjet: typeof $Enums.RoleProjet

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type emailType = $Enums.emailType

export const emailType: typeof $Enums.emailType

export type emailStatus = $Enums.emailStatus

export const emailStatus: typeof $Enums.emailStatus

export type StatutProjet = $Enums.StatutProjet

export const StatutProjet: typeof $Enums.StatutProjet

export type FicheType = $Enums.FicheType

export const FicheType: typeof $Enums.FicheType

export type TypeLieuClimadiag = $Enums.TypeLieuClimadiag

export const TypeLieuClimadiag: typeof $Enums.TypeLieuClimadiag

export type ReferenceType = $Enums.ReferenceType

export const ReferenceType: typeof $Enums.ReferenceType

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectivite`: Exposes CRUD operations for the **collectivite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collectivites
    * const collectivites = await prisma.collectivite.findMany()
    * ```
    */
  get collectivite(): Prisma.collectiviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_projet`: Exposes CRUD operations for the **user_projet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_projets
    * const user_projets = await prisma.user_projet.findMany()
    * ```
    */
  get user_projet(): Prisma.user_projetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.emailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_collectivite`: Exposes CRUD operations for the **user_collectivite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_collectivites
    * const user_collectivites = await prisma.user_collectivite.findMany()
    * ```
    */
  get user_collectivite(): Prisma.user_collectiviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projet`: Exposes CRUD operations for the **projet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projets
    * const projets = await prisma.projet.findMany()
    * ```
    */
  get projet(): Prisma.projetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projet_fiche`: Exposes CRUD operations for the **projet_fiche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projet_fiches
    * const projet_fiches = await prisma.projet_fiche.findMany()
    * ```
    */
  get projet_fiche(): Prisma.projet_ficheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projet_sourcing_contact`: Exposes CRUD operations for the **projet_sourcing_contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projet_sourcing_contacts
    * const projet_sourcing_contacts = await prisma.projet_sourcing_contact.findMany()
    * ```
    */
  get projet_sourcing_contact(): Prisma.projet_sourcing_contactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estimation`: Exposes CRUD operations for the **estimation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estimations
    * const estimations = await prisma.estimation.findMany()
    * ```
    */
  get estimation(): Prisma.estimationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.climadiag`: Exposes CRUD operations for the **climadiag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Climadiags
    * const climadiags = await prisma.climadiag.findMany()
    * ```
    */
  get climadiag(): Prisma.climadiagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aide`: Exposes CRUD operations for the **aide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aides
    * const aides = await prisma.aide.findMany()
    * ```
    */
  get aide(): Prisma.aideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estimations_aides`: Exposes CRUD operations for the **estimations_aides** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estimations_aides
    * const estimations_aides = await prisma.estimations_aides.findMany()
    * ```
    */
  get estimations_aides(): Prisma.estimations_aidesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estimation_materiaux`: Exposes CRUD operations for the **estimation_materiaux** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estimation_materiauxes
    * const estimation_materiauxes = await prisma.estimation_materiaux.findMany()
    * ```
    */
  get estimation_materiaux(): Prisma.estimation_materiauxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estimation_fiche_solution`: Exposes CRUD operations for the **estimation_fiche_solution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estimation_fiche_solutions
    * const estimation_fiche_solutions = await prisma.estimation_fiche_solution.findMany()
    * ```
    */
  get estimation_fiche_solution(): Prisma.estimation_fiche_solutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.conversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diagnostic_simulation`: Exposes CRUD operations for the **diagnostic_simulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnostic_simulations
    * const diagnostic_simulations = await prisma.diagnostic_simulation.findMany()
    * ```
    */
  get diagnostic_simulation(): Prisma.diagnostic_simulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cron_jobs`: Exposes CRUD operations for the **cron_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cron_jobs
    * const cron_jobs = await prisma.cron_jobs.findMany()
    * ```
    */
  get cron_jobs(): Prisma.cron_jobsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    User: 'User',
    VerificationToken: 'VerificationToken',
    collectivite: 'collectivite',
    user_projet: 'user_projet',
    email: 'email',
    user_collectivite: 'user_collectivite',
    projet: 'projet',
    projet_fiche: 'projet_fiche',
    projet_sourcing_contact: 'projet_sourcing_contact',
    estimation: 'estimation',
    climadiag: 'climadiag',
    aide: 'aide',
    estimations_aides: 'estimations_aides',
    estimation_materiaux: 'estimation_materiaux',
    estimation_fiche_solution: 'estimation_fiche_solution',
    conversation: 'conversation',
    diagnostic_simulation: 'diagnostic_simulation',
    Analytics: 'Analytics',
    cron_jobs: 'cron_jobs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "user" | "verificationToken" | "collectivite" | "user_projet" | "email" | "user_collectivite" | "projet" | "projet_fiche" | "projet_sourcing_contact" | "estimation" | "climadiag" | "aide" | "estimations_aides" | "estimation_materiaux" | "estimation_fiche_solution" | "conversation" | "diagnostic_simulation" | "analytics" | "cron_jobs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      collectivite: {
        payload: Prisma.$collectivitePayload<ExtArgs>
        fields: Prisma.collectiviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collectiviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collectiviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>
          }
          findFirst: {
            args: Prisma.collectiviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collectiviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>
          }
          findMany: {
            args: Prisma.collectiviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>[]
          }
          create: {
            args: Prisma.collectiviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>
          }
          createMany: {
            args: Prisma.collectiviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collectiviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>[]
          }
          delete: {
            args: Prisma.collectiviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>
          }
          update: {
            args: Prisma.collectiviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>
          }
          deleteMany: {
            args: Prisma.collectiviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collectiviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.collectiviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>[]
          }
          upsert: {
            args: Prisma.collectiviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivitePayload>
          }
          aggregate: {
            args: Prisma.CollectiviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectivite>
          }
          groupBy: {
            args: Prisma.collectiviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectiviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.collectiviteCountArgs<ExtArgs>
            result: $Utils.Optional<CollectiviteCountAggregateOutputType> | number
          }
        }
      }
      user_projet: {
        payload: Prisma.$user_projetPayload<ExtArgs>
        fields: Prisma.user_projetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_projetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_projetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>
          }
          findFirst: {
            args: Prisma.user_projetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_projetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>
          }
          findMany: {
            args: Prisma.user_projetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>[]
          }
          create: {
            args: Prisma.user_projetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>
          }
          createMany: {
            args: Prisma.user_projetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_projetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>[]
          }
          delete: {
            args: Prisma.user_projetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>
          }
          update: {
            args: Prisma.user_projetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>
          }
          deleteMany: {
            args: Prisma.user_projetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_projetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_projetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>[]
          }
          upsert: {
            args: Prisma.user_projetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_projetPayload>
          }
          aggregate: {
            args: Prisma.User_projetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_projet>
          }
          groupBy: {
            args: Prisma.user_projetGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_projetGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_projetCountArgs<ExtArgs>
            result: $Utils.Optional<User_projetCountAggregateOutputType> | number
          }
        }
      }
      email: {
        payload: Prisma.$emailPayload<ExtArgs>
        fields: Prisma.emailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.emailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.emailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>
          }
          findFirst: {
            args: Prisma.emailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.emailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>
          }
          findMany: {
            args: Prisma.emailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>[]
          }
          create: {
            args: Prisma.emailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>
          }
          createMany: {
            args: Prisma.emailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.emailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>[]
          }
          delete: {
            args: Prisma.emailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>
          }
          update: {
            args: Prisma.emailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>
          }
          deleteMany: {
            args: Prisma.emailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.emailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.emailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>[]
          }
          upsert: {
            args: Prisma.emailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$emailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.emailGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.emailCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      user_collectivite: {
        payload: Prisma.$user_collectivitePayload<ExtArgs>
        fields: Prisma.user_collectiviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_collectiviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_collectiviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>
          }
          findFirst: {
            args: Prisma.user_collectiviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_collectiviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>
          }
          findMany: {
            args: Prisma.user_collectiviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>[]
          }
          create: {
            args: Prisma.user_collectiviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>
          }
          createMany: {
            args: Prisma.user_collectiviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_collectiviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>[]
          }
          delete: {
            args: Prisma.user_collectiviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>
          }
          update: {
            args: Prisma.user_collectiviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>
          }
          deleteMany: {
            args: Prisma.user_collectiviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_collectiviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_collectiviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>[]
          }
          upsert: {
            args: Prisma.user_collectiviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_collectivitePayload>
          }
          aggregate: {
            args: Prisma.User_collectiviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_collectivite>
          }
          groupBy: {
            args: Prisma.user_collectiviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_collectiviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_collectiviteCountArgs<ExtArgs>
            result: $Utils.Optional<User_collectiviteCountAggregateOutputType> | number
          }
        }
      }
      projet: {
        payload: Prisma.$projetPayload<ExtArgs>
        fields: Prisma.projetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>
          }
          findFirst: {
            args: Prisma.projetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>
          }
          findMany: {
            args: Prisma.projetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>[]
          }
          create: {
            args: Prisma.projetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>
          }
          createMany: {
            args: Prisma.projetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>[]
          }
          delete: {
            args: Prisma.projetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>
          }
          update: {
            args: Prisma.projetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>
          }
          deleteMany: {
            args: Prisma.projetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>[]
          }
          upsert: {
            args: Prisma.projetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetPayload>
          }
          aggregate: {
            args: Prisma.ProjetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjet>
          }
          groupBy: {
            args: Prisma.projetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetGroupByOutputType>[]
          }
          count: {
            args: Prisma.projetCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetCountAggregateOutputType> | number
          }
        }
      }
      projet_fiche: {
        payload: Prisma.$projet_fichePayload<ExtArgs>
        fields: Prisma.projet_ficheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projet_ficheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projet_ficheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>
          }
          findFirst: {
            args: Prisma.projet_ficheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projet_ficheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>
          }
          findMany: {
            args: Prisma.projet_ficheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>[]
          }
          create: {
            args: Prisma.projet_ficheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>
          }
          createMany: {
            args: Prisma.projet_ficheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projet_ficheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>[]
          }
          delete: {
            args: Prisma.projet_ficheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>
          }
          update: {
            args: Prisma.projet_ficheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>
          }
          deleteMany: {
            args: Prisma.projet_ficheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projet_ficheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projet_ficheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>[]
          }
          upsert: {
            args: Prisma.projet_ficheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_fichePayload>
          }
          aggregate: {
            args: Prisma.Projet_ficheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjet_fiche>
          }
          groupBy: {
            args: Prisma.projet_ficheGroupByArgs<ExtArgs>
            result: $Utils.Optional<Projet_ficheGroupByOutputType>[]
          }
          count: {
            args: Prisma.projet_ficheCountArgs<ExtArgs>
            result: $Utils.Optional<Projet_ficheCountAggregateOutputType> | number
          }
        }
      }
      projet_sourcing_contact: {
        payload: Prisma.$projet_sourcing_contactPayload<ExtArgs>
        fields: Prisma.projet_sourcing_contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projet_sourcing_contactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projet_sourcing_contactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>
          }
          findFirst: {
            args: Prisma.projet_sourcing_contactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projet_sourcing_contactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>
          }
          findMany: {
            args: Prisma.projet_sourcing_contactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>[]
          }
          create: {
            args: Prisma.projet_sourcing_contactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>
          }
          createMany: {
            args: Prisma.projet_sourcing_contactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projet_sourcing_contactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>[]
          }
          delete: {
            args: Prisma.projet_sourcing_contactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>
          }
          update: {
            args: Prisma.projet_sourcing_contactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>
          }
          deleteMany: {
            args: Prisma.projet_sourcing_contactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projet_sourcing_contactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projet_sourcing_contactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>[]
          }
          upsert: {
            args: Prisma.projet_sourcing_contactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projet_sourcing_contactPayload>
          }
          aggregate: {
            args: Prisma.Projet_sourcing_contactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjet_sourcing_contact>
          }
          groupBy: {
            args: Prisma.projet_sourcing_contactGroupByArgs<ExtArgs>
            result: $Utils.Optional<Projet_sourcing_contactGroupByOutputType>[]
          }
          count: {
            args: Prisma.projet_sourcing_contactCountArgs<ExtArgs>
            result: $Utils.Optional<Projet_sourcing_contactCountAggregateOutputType> | number
          }
        }
      }
      estimation: {
        payload: Prisma.$estimationPayload<ExtArgs>
        fields: Prisma.estimationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estimationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estimationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>
          }
          findFirst: {
            args: Prisma.estimationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estimationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>
          }
          findMany: {
            args: Prisma.estimationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>[]
          }
          create: {
            args: Prisma.estimationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>
          }
          createMany: {
            args: Prisma.estimationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estimationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>[]
          }
          delete: {
            args: Prisma.estimationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>
          }
          update: {
            args: Prisma.estimationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>
          }
          deleteMany: {
            args: Prisma.estimationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estimationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estimationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>[]
          }
          upsert: {
            args: Prisma.estimationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimationPayload>
          }
          aggregate: {
            args: Prisma.EstimationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstimation>
          }
          groupBy: {
            args: Prisma.estimationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstimationGroupByOutputType>[]
          }
          count: {
            args: Prisma.estimationCountArgs<ExtArgs>
            result: $Utils.Optional<EstimationCountAggregateOutputType> | number
          }
        }
      }
      climadiag: {
        payload: Prisma.$climadiagPayload<ExtArgs>
        fields: Prisma.climadiagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.climadiagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.climadiagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>
          }
          findFirst: {
            args: Prisma.climadiagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.climadiagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>
          }
          findMany: {
            args: Prisma.climadiagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>[]
          }
          create: {
            args: Prisma.climadiagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>
          }
          createMany: {
            args: Prisma.climadiagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.climadiagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>[]
          }
          delete: {
            args: Prisma.climadiagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>
          }
          update: {
            args: Prisma.climadiagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>
          }
          deleteMany: {
            args: Prisma.climadiagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.climadiagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.climadiagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>[]
          }
          upsert: {
            args: Prisma.climadiagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$climadiagPayload>
          }
          aggregate: {
            args: Prisma.ClimadiagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClimadiag>
          }
          groupBy: {
            args: Prisma.climadiagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClimadiagGroupByOutputType>[]
          }
          count: {
            args: Prisma.climadiagCountArgs<ExtArgs>
            result: $Utils.Optional<ClimadiagCountAggregateOutputType> | number
          }
        }
      }
      aide: {
        payload: Prisma.$aidePayload<ExtArgs>
        fields: Prisma.aideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>
          }
          findFirst: {
            args: Prisma.aideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>
          }
          findMany: {
            args: Prisma.aideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>[]
          }
          create: {
            args: Prisma.aideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>
          }
          createMany: {
            args: Prisma.aideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.aideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>[]
          }
          delete: {
            args: Prisma.aideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>
          }
          update: {
            args: Prisma.aideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>
          }
          deleteMany: {
            args: Prisma.aideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.aideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>[]
          }
          upsert: {
            args: Prisma.aideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aidePayload>
          }
          aggregate: {
            args: Prisma.AideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAide>
          }
          groupBy: {
            args: Prisma.aideGroupByArgs<ExtArgs>
            result: $Utils.Optional<AideGroupByOutputType>[]
          }
          count: {
            args: Prisma.aideCountArgs<ExtArgs>
            result: $Utils.Optional<AideCountAggregateOutputType> | number
          }
        }
      }
      estimations_aides: {
        payload: Prisma.$estimations_aidesPayload<ExtArgs>
        fields: Prisma.estimations_aidesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estimations_aidesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estimations_aidesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>
          }
          findFirst: {
            args: Prisma.estimations_aidesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estimations_aidesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>
          }
          findMany: {
            args: Prisma.estimations_aidesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>[]
          }
          create: {
            args: Prisma.estimations_aidesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>
          }
          createMany: {
            args: Prisma.estimations_aidesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estimations_aidesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>[]
          }
          delete: {
            args: Prisma.estimations_aidesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>
          }
          update: {
            args: Prisma.estimations_aidesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>
          }
          deleteMany: {
            args: Prisma.estimations_aidesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estimations_aidesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estimations_aidesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>[]
          }
          upsert: {
            args: Prisma.estimations_aidesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimations_aidesPayload>
          }
          aggregate: {
            args: Prisma.Estimations_aidesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstimations_aides>
          }
          groupBy: {
            args: Prisma.estimations_aidesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estimations_aidesGroupByOutputType>[]
          }
          count: {
            args: Prisma.estimations_aidesCountArgs<ExtArgs>
            result: $Utils.Optional<Estimations_aidesCountAggregateOutputType> | number
          }
        }
      }
      estimation_materiaux: {
        payload: Prisma.$estimation_materiauxPayload<ExtArgs>
        fields: Prisma.estimation_materiauxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estimation_materiauxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estimation_materiauxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>
          }
          findFirst: {
            args: Prisma.estimation_materiauxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estimation_materiauxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>
          }
          findMany: {
            args: Prisma.estimation_materiauxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>[]
          }
          create: {
            args: Prisma.estimation_materiauxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>
          }
          createMany: {
            args: Prisma.estimation_materiauxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estimation_materiauxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>[]
          }
          delete: {
            args: Prisma.estimation_materiauxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>
          }
          update: {
            args: Prisma.estimation_materiauxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>
          }
          deleteMany: {
            args: Prisma.estimation_materiauxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estimation_materiauxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estimation_materiauxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>[]
          }
          upsert: {
            args: Prisma.estimation_materiauxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_materiauxPayload>
          }
          aggregate: {
            args: Prisma.Estimation_materiauxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstimation_materiaux>
          }
          groupBy: {
            args: Prisma.estimation_materiauxGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estimation_materiauxGroupByOutputType>[]
          }
          count: {
            args: Prisma.estimation_materiauxCountArgs<ExtArgs>
            result: $Utils.Optional<Estimation_materiauxCountAggregateOutputType> | number
          }
        }
      }
      estimation_fiche_solution: {
        payload: Prisma.$estimation_fiche_solutionPayload<ExtArgs>
        fields: Prisma.estimation_fiche_solutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estimation_fiche_solutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estimation_fiche_solutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>
          }
          findFirst: {
            args: Prisma.estimation_fiche_solutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estimation_fiche_solutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>
          }
          findMany: {
            args: Prisma.estimation_fiche_solutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>[]
          }
          create: {
            args: Prisma.estimation_fiche_solutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>
          }
          createMany: {
            args: Prisma.estimation_fiche_solutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estimation_fiche_solutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>[]
          }
          delete: {
            args: Prisma.estimation_fiche_solutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>
          }
          update: {
            args: Prisma.estimation_fiche_solutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>
          }
          deleteMany: {
            args: Prisma.estimation_fiche_solutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estimation_fiche_solutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estimation_fiche_solutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>[]
          }
          upsert: {
            args: Prisma.estimation_fiche_solutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimation_fiche_solutionPayload>
          }
          aggregate: {
            args: Prisma.Estimation_fiche_solutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstimation_fiche_solution>
          }
          groupBy: {
            args: Prisma.estimation_fiche_solutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estimation_fiche_solutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.estimation_fiche_solutionCountArgs<ExtArgs>
            result: $Utils.Optional<Estimation_fiche_solutionCountAggregateOutputType> | number
          }
        }
      }
      conversation: {
        payload: Prisma.$conversationPayload<ExtArgs>
        fields: Prisma.conversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          findFirst: {
            args: Prisma.conversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          findMany: {
            args: Prisma.conversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          create: {
            args: Prisma.conversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          createMany: {
            args: Prisma.conversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          delete: {
            args: Prisma.conversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          update: {
            args: Prisma.conversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          deleteMany: {
            args: Prisma.conversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>[]
          }
          upsert: {
            args: Prisma.conversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.conversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      diagnostic_simulation: {
        payload: Prisma.$diagnostic_simulationPayload<ExtArgs>
        fields: Prisma.diagnostic_simulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.diagnostic_simulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.diagnostic_simulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>
          }
          findFirst: {
            args: Prisma.diagnostic_simulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.diagnostic_simulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>
          }
          findMany: {
            args: Prisma.diagnostic_simulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>[]
          }
          create: {
            args: Prisma.diagnostic_simulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>
          }
          createMany: {
            args: Prisma.diagnostic_simulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.diagnostic_simulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>[]
          }
          delete: {
            args: Prisma.diagnostic_simulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>
          }
          update: {
            args: Prisma.diagnostic_simulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>
          }
          deleteMany: {
            args: Prisma.diagnostic_simulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.diagnostic_simulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.diagnostic_simulationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>[]
          }
          upsert: {
            args: Prisma.diagnostic_simulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diagnostic_simulationPayload>
          }
          aggregate: {
            args: Prisma.Diagnostic_simulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnostic_simulation>
          }
          groupBy: {
            args: Prisma.diagnostic_simulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Diagnostic_simulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.diagnostic_simulationCountArgs<ExtArgs>
            result: $Utils.Optional<Diagnostic_simulationCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
      cron_jobs: {
        payload: Prisma.$cron_jobsPayload<ExtArgs>
        fields: Prisma.cron_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cron_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cron_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>
          }
          findFirst: {
            args: Prisma.cron_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cron_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>
          }
          findMany: {
            args: Prisma.cron_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>[]
          }
          create: {
            args: Prisma.cron_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>
          }
          createMany: {
            args: Prisma.cron_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cron_jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>[]
          }
          delete: {
            args: Prisma.cron_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>
          }
          update: {
            args: Prisma.cron_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>
          }
          deleteMany: {
            args: Prisma.cron_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cron_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cron_jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>[]
          }
          upsert: {
            args: Prisma.cron_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cron_jobsPayload>
          }
          aggregate: {
            args: Prisma.Cron_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCron_jobs>
          }
          groupBy: {
            args: Prisma.cron_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cron_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cron_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<Cron_jobsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    user?: UserOmit
    verificationToken?: VerificationTokenOmit
    collectivite?: collectiviteOmit
    user_projet?: user_projetOmit
    email?: emailOmit
    user_collectivite?: user_collectiviteOmit
    projet?: projetOmit
    projet_fiche?: projet_ficheOmit
    projet_sourcing_contact?: projet_sourcing_contactOmit
    estimation?: estimationOmit
    climadiag?: climadiagOmit
    aide?: aideOmit
    estimations_aides?: estimations_aidesOmit
    estimation_materiaux?: estimation_materiauxOmit
    estimation_fiche_solution?: estimation_fiche_solutionOmit
    conversation?: conversationOmit
    diagnostic_simulation?: diagnostic_simulationOmit
    analytics?: AnalyticsOmit
    cron_jobs?: cron_jobsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    collectivites_created: number
    projets_created: number
    estimations_created: number
    estimations_deleted: number
    projets_deleted: number
    collectivites: number
    projets: number
    user_projet_deleted: number
    conversations: number
    Analytics: number
    sourcing_contacts_created: number
    emails: number
    estimations_aides: number
    fiches: number
    diagnostic_simulation: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    collectivites_created?: boolean | UserCountOutputTypeCountCollectivites_createdArgs
    projets_created?: boolean | UserCountOutputTypeCountProjets_createdArgs
    estimations_created?: boolean | UserCountOutputTypeCountEstimations_createdArgs
    estimations_deleted?: boolean | UserCountOutputTypeCountEstimations_deletedArgs
    projets_deleted?: boolean | UserCountOutputTypeCountProjets_deletedArgs
    collectivites?: boolean | UserCountOutputTypeCountCollectivitesArgs
    projets?: boolean | UserCountOutputTypeCountProjetsArgs
    user_projet_deleted?: boolean | UserCountOutputTypeCountUser_projet_deletedArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    Analytics?: boolean | UserCountOutputTypeCountAnalyticsArgs
    sourcing_contacts_created?: boolean | UserCountOutputTypeCountSourcing_contacts_createdArgs
    emails?: boolean | UserCountOutputTypeCountEmailsArgs
    estimations_aides?: boolean | UserCountOutputTypeCountEstimations_aidesArgs
    fiches?: boolean | UserCountOutputTypeCountFichesArgs
    diagnostic_simulation?: boolean | UserCountOutputTypeCountDiagnostic_simulationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollectivites_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectiviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjets_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEstimations_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEstimations_deletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjets_deletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollectivitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_collectiviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_projetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_projet_deletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_projetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSourcing_contacts_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_sourcing_contactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: emailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEstimations_aidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimations_aidesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFichesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_ficheWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDiagnostic_simulationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnostic_simulationWhereInput
  }


  /**
   * Count Type CollectiviteCountOutputType
   */

  export type CollectiviteCountOutputType = {
    users: number
    projet: number
  }

  export type CollectiviteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CollectiviteCountOutputTypeCountUsersArgs
    projet?: boolean | CollectiviteCountOutputTypeCountProjetArgs
  }

  // Custom InputTypes
  /**
   * CollectiviteCountOutputType without action
   */
  export type CollectiviteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectiviteCountOutputType
     */
    select?: CollectiviteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectiviteCountOutputType without action
   */
  export type CollectiviteCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_collectiviteWhereInput
  }

  /**
   * CollectiviteCountOutputType without action
   */
  export type CollectiviteCountOutputTypeCountProjetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetWhereInput
  }


  /**
   * Count Type User_projetCountOutputType
   */

  export type User_projetCountOutputType = {
    email: number
    sourced_by_projets: number
  }

  export type User_projetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | User_projetCountOutputTypeCountEmailArgs
    sourced_by_projets?: boolean | User_projetCountOutputTypeCountSourced_by_projetsArgs
  }

  // Custom InputTypes
  /**
   * User_projetCountOutputType without action
   */
  export type User_projetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User_projetCountOutputType
     */
    select?: User_projetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * User_projetCountOutputType without action
   */
  export type User_projetCountOutputTypeCountEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: emailWhereInput
  }

  /**
   * User_projetCountOutputType without action
   */
  export type User_projetCountOutputTypeCountSourced_by_projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_sourcing_contactWhereInput
  }


  /**
   * Count Type ProjetCountOutputType
   */

  export type ProjetCountOutputType = {
    estimations: number
    users: number
    sourcing_user_projets: number
    fiches: number
    diagnostic_simulations: number
  }

  export type ProjetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimations?: boolean | ProjetCountOutputTypeCountEstimationsArgs
    users?: boolean | ProjetCountOutputTypeCountUsersArgs
    sourcing_user_projets?: boolean | ProjetCountOutputTypeCountSourcing_user_projetsArgs
    fiches?: boolean | ProjetCountOutputTypeCountFichesArgs
    diagnostic_simulations?: boolean | ProjetCountOutputTypeCountDiagnostic_simulationsArgs
  }

  // Custom InputTypes
  /**
   * ProjetCountOutputType without action
   */
  export type ProjetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjetCountOutputType
     */
    select?: ProjetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjetCountOutputType without action
   */
  export type ProjetCountOutputTypeCountEstimationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimationWhereInput
  }

  /**
   * ProjetCountOutputType without action
   */
  export type ProjetCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_projetWhereInput
  }

  /**
   * ProjetCountOutputType without action
   */
  export type ProjetCountOutputTypeCountSourcing_user_projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_sourcing_contactWhereInput
  }

  /**
   * ProjetCountOutputType without action
   */
  export type ProjetCountOutputTypeCountFichesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_ficheWhereInput
  }

  /**
   * ProjetCountOutputType without action
   */
  export type ProjetCountOutputTypeCountDiagnostic_simulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnostic_simulationWhereInput
  }


  /**
   * Count Type EstimationCountOutputType
   */

  export type EstimationCountOutputType = {
    estimations_aides: number
    estimations_fiches_solutions: number
  }

  export type EstimationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimations_aides?: boolean | EstimationCountOutputTypeCountEstimations_aidesArgs
    estimations_fiches_solutions?: boolean | EstimationCountOutputTypeCountEstimations_fiches_solutionsArgs
  }

  // Custom InputTypes
  /**
   * EstimationCountOutputType without action
   */
  export type EstimationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstimationCountOutputType
     */
    select?: EstimationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstimationCountOutputType without action
   */
  export type EstimationCountOutputTypeCountEstimations_aidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimations_aidesWhereInput
  }

  /**
   * EstimationCountOutputType without action
   */
  export type EstimationCountOutputTypeCountEstimations_fiches_solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimation_fiche_solutionWhereInput
  }


  /**
   * Count Type AideCountOutputType
   */

  export type AideCountOutputType = {
    estimations_aides: number
  }

  export type AideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimations_aides?: boolean | AideCountOutputTypeCountEstimations_aidesArgs
  }

  // Custom InputTypes
  /**
   * AideCountOutputType without action
   */
  export type AideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AideCountOutputType
     */
    select?: AideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AideCountOutputType without action
   */
  export type AideCountOutputTypeCountEstimations_aidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimations_aidesWhereInput
  }


  /**
   * Count Type Estimation_fiche_solutionCountOutputType
   */

  export type Estimation_fiche_solutionCountOutputType = {
    estimation_materiaux: number
  }

  export type Estimation_fiche_solutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation_materiaux?: boolean | Estimation_fiche_solutionCountOutputTypeCountEstimation_materiauxArgs
  }

  // Custom InputTypes
  /**
   * Estimation_fiche_solutionCountOutputType without action
   */
  export type Estimation_fiche_solutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estimation_fiche_solutionCountOutputType
     */
    select?: Estimation_fiche_solutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Estimation_fiche_solutionCountOutputType without action
   */
  export type Estimation_fiche_solutionCountOutputTypeCountEstimation_materiauxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimation_materiauxWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    nom: string | null
    prenom: string | null
    poste: string | null
    nom_etablissement: string | null
    created_at: Date | null
    updated_at: Date | null
    canal_acquisition: string | null
    accept_communication_produit: boolean | null
    accept_communication_suivi_projet: boolean | null
    statut: $Enums.StatutUser | null
    statut_updated_at: Date | null
    last_browsing_date: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    nom: string | null
    prenom: string | null
    poste: string | null
    nom_etablissement: string | null
    created_at: Date | null
    updated_at: Date | null
    canal_acquisition: string | null
    accept_communication_produit: boolean | null
    accept_communication_suivi_projet: boolean | null
    statut: $Enums.StatutUser | null
    statut_updated_at: Date | null
    last_browsing_date: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    image: number
    agentconnect_info: number
    nom: number
    prenom: number
    poste: number
    nom_etablissement: number
    siren_info: number
    created_at: number
    updated_at: number
    canal_acquisition: number
    discardedInformation: number
    accept_communication_produit: number
    accept_communication_suivi_projet: number
    statut: number
    statut_updated_at: number
    last_browsing_date: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    image?: true
    nom?: true
    prenom?: true
    poste?: true
    nom_etablissement?: true
    created_at?: true
    updated_at?: true
    canal_acquisition?: true
    accept_communication_produit?: true
    accept_communication_suivi_projet?: true
    statut?: true
    statut_updated_at?: true
    last_browsing_date?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    image?: true
    nom?: true
    prenom?: true
    poste?: true
    nom_etablissement?: true
    created_at?: true
    updated_at?: true
    canal_acquisition?: true
    accept_communication_produit?: true
    accept_communication_suivi_projet?: true
    statut?: true
    statut_updated_at?: true
    last_browsing_date?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    image?: true
    agentconnect_info?: true
    nom?: true
    prenom?: true
    poste?: true
    nom_etablissement?: true
    siren_info?: true
    created_at?: true
    updated_at?: true
    canal_acquisition?: true
    discardedInformation?: true
    accept_communication_produit?: true
    accept_communication_suivi_projet?: true
    statut?: true
    statut_updated_at?: true
    last_browsing_date?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    image: string | null
    agentconnect_info: JsonValue | null
    nom: string | null
    prenom: string | null
    poste: string | null
    nom_etablissement: string | null
    siren_info: JsonValue | null
    created_at: Date
    updated_at: Date | null
    canal_acquisition: string | null
    discardedInformation: string[]
    accept_communication_produit: boolean
    accept_communication_suivi_projet: boolean
    statut: $Enums.StatutUser | null
    statut_updated_at: Date | null
    last_browsing_date: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    agentconnect_info?: boolean
    nom?: boolean
    prenom?: boolean
    poste?: boolean
    nom_etablissement?: boolean
    siren_info?: boolean
    created_at?: boolean
    updated_at?: boolean
    canal_acquisition?: boolean
    discardedInformation?: boolean
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    last_browsing_date?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    collectivites_created?: boolean | User$collectivites_createdArgs<ExtArgs>
    projets_created?: boolean | User$projets_createdArgs<ExtArgs>
    estimations_created?: boolean | User$estimations_createdArgs<ExtArgs>
    estimations_deleted?: boolean | User$estimations_deletedArgs<ExtArgs>
    projets_deleted?: boolean | User$projets_deletedArgs<ExtArgs>
    collectivites?: boolean | User$collectivitesArgs<ExtArgs>
    projets?: boolean | User$projetsArgs<ExtArgs>
    user_projet_deleted?: boolean | User$user_projet_deletedArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    Analytics?: boolean | User$AnalyticsArgs<ExtArgs>
    sourcing_contacts_created?: boolean | User$sourcing_contacts_createdArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    estimations_aides?: boolean | User$estimations_aidesArgs<ExtArgs>
    fiches?: boolean | User$fichesArgs<ExtArgs>
    diagnostic_simulation?: boolean | User$diagnostic_simulationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    agentconnect_info?: boolean
    nom?: boolean
    prenom?: boolean
    poste?: boolean
    nom_etablissement?: boolean
    siren_info?: boolean
    created_at?: boolean
    updated_at?: boolean
    canal_acquisition?: boolean
    discardedInformation?: boolean
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    last_browsing_date?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    agentconnect_info?: boolean
    nom?: boolean
    prenom?: boolean
    poste?: boolean
    nom_etablissement?: boolean
    siren_info?: boolean
    created_at?: boolean
    updated_at?: boolean
    canal_acquisition?: boolean
    discardedInformation?: boolean
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    last_browsing_date?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    agentconnect_info?: boolean
    nom?: boolean
    prenom?: boolean
    poste?: boolean
    nom_etablissement?: boolean
    siren_info?: boolean
    created_at?: boolean
    updated_at?: boolean
    canal_acquisition?: boolean
    discardedInformation?: boolean
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    last_browsing_date?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "image" | "agentconnect_info" | "nom" | "prenom" | "poste" | "nom_etablissement" | "siren_info" | "created_at" | "updated_at" | "canal_acquisition" | "discardedInformation" | "accept_communication_produit" | "accept_communication_suivi_projet" | "statut" | "statut_updated_at" | "last_browsing_date", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    collectivites_created?: boolean | User$collectivites_createdArgs<ExtArgs>
    projets_created?: boolean | User$projets_createdArgs<ExtArgs>
    estimations_created?: boolean | User$estimations_createdArgs<ExtArgs>
    estimations_deleted?: boolean | User$estimations_deletedArgs<ExtArgs>
    projets_deleted?: boolean | User$projets_deletedArgs<ExtArgs>
    collectivites?: boolean | User$collectivitesArgs<ExtArgs>
    projets?: boolean | User$projetsArgs<ExtArgs>
    user_projet_deleted?: boolean | User$user_projet_deletedArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    Analytics?: boolean | User$AnalyticsArgs<ExtArgs>
    sourcing_contacts_created?: boolean | User$sourcing_contacts_createdArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    estimations_aides?: boolean | User$estimations_aidesArgs<ExtArgs>
    fiches?: boolean | User$fichesArgs<ExtArgs>
    diagnostic_simulation?: boolean | User$diagnostic_simulationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      collectivites_created: Prisma.$collectivitePayload<ExtArgs>[]
      projets_created: Prisma.$projetPayload<ExtArgs>[]
      estimations_created: Prisma.$estimationPayload<ExtArgs>[]
      estimations_deleted: Prisma.$estimationPayload<ExtArgs>[]
      projets_deleted: Prisma.$projetPayload<ExtArgs>[]
      collectivites: Prisma.$user_collectivitePayload<ExtArgs>[]
      projets: Prisma.$user_projetPayload<ExtArgs>[]
      user_projet_deleted: Prisma.$user_projetPayload<ExtArgs>[]
      conversations: Prisma.$conversationPayload<ExtArgs>[]
      Analytics: Prisma.$AnalyticsPayload<ExtArgs>[]
      sourcing_contacts_created: Prisma.$projet_sourcing_contactPayload<ExtArgs>[]
      emails: Prisma.$emailPayload<ExtArgs>[]
      estimations_aides: Prisma.$estimations_aidesPayload<ExtArgs>[]
      fiches: Prisma.$projet_fichePayload<ExtArgs>[]
      diagnostic_simulation: Prisma.$diagnostic_simulationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: Date | null
      image: string | null
      agentconnect_info: Prisma.JsonValue | null
      nom: string | null
      prenom: string | null
      poste: string | null
      nom_etablissement: string | null
      siren_info: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date | null
      canal_acquisition: string | null
      discardedInformation: string[]
      accept_communication_produit: boolean
      accept_communication_suivi_projet: boolean
      statut: $Enums.StatutUser | null
      statut_updated_at: Date | null
      last_browsing_date: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collectivites_created<T extends User$collectivites_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$collectivites_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projets_created<T extends User$projets_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$projets_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    estimations_created<T extends User$estimations_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$estimations_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    estimations_deleted<T extends User$estimations_deletedArgs<ExtArgs> = {}>(args?: Subset<T, User$estimations_deletedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projets_deleted<T extends User$projets_deletedArgs<ExtArgs> = {}>(args?: Subset<T, User$projets_deletedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collectivites<T extends User$collectivitesArgs<ExtArgs> = {}>(args?: Subset<T, User$collectivitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projets<T extends User$projetsArgs<ExtArgs> = {}>(args?: Subset<T, User$projetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_projet_deleted<T extends User$user_projet_deletedArgs<ExtArgs> = {}>(args?: Subset<T, User$user_projet_deletedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Analytics<T extends User$AnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$AnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourcing_contacts_created<T extends User$sourcing_contacts_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$sourcing_contacts_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends User$emailsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    estimations_aides<T extends User$estimations_aidesArgs<ExtArgs> = {}>(args?: Subset<T, User$estimations_aidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fiches<T extends User$fichesArgs<ExtArgs> = {}>(args?: Subset<T, User$fichesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnostic_simulation<T extends User$diagnostic_simulationArgs<ExtArgs> = {}>(args?: Subset<T, User$diagnostic_simulationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly agentconnect_info: FieldRef<"User", 'Json'>
    readonly nom: FieldRef<"User", 'String'>
    readonly prenom: FieldRef<"User", 'String'>
    readonly poste: FieldRef<"User", 'String'>
    readonly nom_etablissement: FieldRef<"User", 'String'>
    readonly siren_info: FieldRef<"User", 'Json'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly canal_acquisition: FieldRef<"User", 'String'>
    readonly discardedInformation: FieldRef<"User", 'String[]'>
    readonly accept_communication_produit: FieldRef<"User", 'Boolean'>
    readonly accept_communication_suivi_projet: FieldRef<"User", 'Boolean'>
    readonly statut: FieldRef<"User", 'StatutUser'>
    readonly statut_updated_at: FieldRef<"User", 'DateTime'>
    readonly last_browsing_date: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.collectivites_created
   */
  export type User$collectivites_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    where?: collectiviteWhereInput
    orderBy?: collectiviteOrderByWithRelationInput | collectiviteOrderByWithRelationInput[]
    cursor?: collectiviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectiviteScalarFieldEnum | CollectiviteScalarFieldEnum[]
  }

  /**
   * User.projets_created
   */
  export type User$projets_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    where?: projetWhereInput
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    cursor?: projetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetScalarFieldEnum | ProjetScalarFieldEnum[]
  }

  /**
   * User.estimations_created
   */
  export type User$estimations_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    where?: estimationWhereInput
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    cursor?: estimationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstimationScalarFieldEnum | EstimationScalarFieldEnum[]
  }

  /**
   * User.estimations_deleted
   */
  export type User$estimations_deletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    where?: estimationWhereInput
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    cursor?: estimationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstimationScalarFieldEnum | EstimationScalarFieldEnum[]
  }

  /**
   * User.projets_deleted
   */
  export type User$projets_deletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    where?: projetWhereInput
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    cursor?: projetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetScalarFieldEnum | ProjetScalarFieldEnum[]
  }

  /**
   * User.collectivites
   */
  export type User$collectivitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    where?: user_collectiviteWhereInput
    orderBy?: user_collectiviteOrderByWithRelationInput | user_collectiviteOrderByWithRelationInput[]
    cursor?: user_collectiviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_collectiviteScalarFieldEnum | User_collectiviteScalarFieldEnum[]
  }

  /**
   * User.projets
   */
  export type User$projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    where?: user_projetWhereInput
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    cursor?: user_projetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_projetScalarFieldEnum | User_projetScalarFieldEnum[]
  }

  /**
   * User.user_projet_deleted
   */
  export type User$user_projet_deletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    where?: user_projetWhereInput
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    cursor?: user_projetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_projetScalarFieldEnum | User_projetScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    where?: conversationWhereInput
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    cursor?: conversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.Analytics
   */
  export type User$AnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    cursor?: AnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * User.sourcing_contacts_created
   */
  export type User$sourcing_contacts_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    where?: projet_sourcing_contactWhereInput
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    cursor?: projet_sourcing_contactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_sourcing_contactScalarFieldEnum | Projet_sourcing_contactScalarFieldEnum[]
  }

  /**
   * User.emails
   */
  export type User$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    where?: emailWhereInput
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[]
    cursor?: emailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * User.estimations_aides
   */
  export type User$estimations_aidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    where?: estimations_aidesWhereInput
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    cursor?: estimations_aidesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Estimations_aidesScalarFieldEnum | Estimations_aidesScalarFieldEnum[]
  }

  /**
   * User.fiches
   */
  export type User$fichesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    where?: projet_ficheWhereInput
    orderBy?: projet_ficheOrderByWithRelationInput | projet_ficheOrderByWithRelationInput[]
    cursor?: projet_ficheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_ficheScalarFieldEnum | Projet_ficheScalarFieldEnum[]
  }

  /**
   * User.diagnostic_simulation
   */
  export type User$diagnostic_simulationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    where?: diagnostic_simulationWhereInput
    orderBy?: diagnostic_simulationOrderByWithRelationInput | diagnostic_simulationOrderByWithRelationInput[]
    cursor?: diagnostic_simulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Diagnostic_simulationScalarFieldEnum | Diagnostic_simulationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model collectivite
   */

  export type AggregateCollectivite = {
    _count: CollectiviteCountAggregateOutputType | null
    _avg: CollectiviteAvgAggregateOutputType | null
    _sum: CollectiviteSumAggregateOutputType | null
    _min: CollectiviteMinAggregateOutputType | null
    _max: CollectiviteMaxAggregateOutputType | null
  }

  export type CollectiviteAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type CollectiviteSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type CollectiviteMinAggregateOutputType = {
    id: number | null
    nom: string | null
    code_insee: string | null
    code_postal: string | null
    ban_id: string | null
    latitude: number | null
    longitude: number | null
    created_by: string | null
    created_at: Date | null
    aides_territoires_perimeter_id: string | null
  }

  export type CollectiviteMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    code_insee: string | null
    code_postal: string | null
    ban_id: string | null
    latitude: number | null
    longitude: number | null
    created_by: string | null
    created_at: Date | null
    aides_territoires_perimeter_id: string | null
  }

  export type CollectiviteCountAggregateOutputType = {
    id: number
    nom: number
    code_insee: number
    code_postal: number
    adresse_info: number
    adresse_all_infos: number
    ban_id: number
    latitude: number
    longitude: number
    created_by: number
    created_at: number
    aides_territoires_perimeter_id: number
    _all: number
  }


  export type CollectiviteAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type CollectiviteSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type CollectiviteMinAggregateInputType = {
    id?: true
    nom?: true
    code_insee?: true
    code_postal?: true
    ban_id?: true
    latitude?: true
    longitude?: true
    created_by?: true
    created_at?: true
    aides_territoires_perimeter_id?: true
  }

  export type CollectiviteMaxAggregateInputType = {
    id?: true
    nom?: true
    code_insee?: true
    code_postal?: true
    ban_id?: true
    latitude?: true
    longitude?: true
    created_by?: true
    created_at?: true
    aides_territoires_perimeter_id?: true
  }

  export type CollectiviteCountAggregateInputType = {
    id?: true
    nom?: true
    code_insee?: true
    code_postal?: true
    adresse_info?: true
    adresse_all_infos?: true
    ban_id?: true
    latitude?: true
    longitude?: true
    created_by?: true
    created_at?: true
    aides_territoires_perimeter_id?: true
    _all?: true
  }

  export type CollectiviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collectivite to aggregate.
     */
    where?: collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites to fetch.
     */
    orderBy?: collectiviteOrderByWithRelationInput | collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collectivites
    **/
    _count?: true | CollectiviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectiviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectiviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectiviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectiviteMaxAggregateInputType
  }

  export type GetCollectiviteAggregateType<T extends CollectiviteAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectivite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectivite[P]>
      : GetScalarType<T[P], AggregateCollectivite[P]>
  }




  export type collectiviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectiviteWhereInput
    orderBy?: collectiviteOrderByWithAggregationInput | collectiviteOrderByWithAggregationInput[]
    by: CollectiviteScalarFieldEnum[] | CollectiviteScalarFieldEnum
    having?: collectiviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectiviteCountAggregateInputType | true
    _avg?: CollectiviteAvgAggregateInputType
    _sum?: CollectiviteSumAggregateInputType
    _min?: CollectiviteMinAggregateInputType
    _max?: CollectiviteMaxAggregateInputType
  }

  export type CollectiviteGroupByOutputType = {
    id: number
    nom: string
    code_insee: string | null
    code_postal: string | null
    adresse_info: JsonValue | null
    adresse_all_infos: JsonValue | null
    ban_id: string | null
    latitude: number | null
    longitude: number | null
    created_by: string
    created_at: Date
    aides_territoires_perimeter_id: string | null
    _count: CollectiviteCountAggregateOutputType | null
    _avg: CollectiviteAvgAggregateOutputType | null
    _sum: CollectiviteSumAggregateOutputType | null
    _min: CollectiviteMinAggregateOutputType | null
    _max: CollectiviteMaxAggregateOutputType | null
  }

  type GetCollectiviteGroupByPayload<T extends collectiviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectiviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectiviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectiviteGroupByOutputType[P]>
            : GetScalarType<T[P], CollectiviteGroupByOutputType[P]>
        }
      >
    >


  export type collectiviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code_insee?: boolean
    code_postal?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    ban_id?: boolean
    latitude?: boolean
    longitude?: boolean
    created_by?: boolean
    created_at?: boolean
    aides_territoires_perimeter_id?: boolean
    users?: boolean | collectivite$usersArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | collectivite$projetArgs<ExtArgs>
    _count?: boolean | CollectiviteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectivite"]>

  export type collectiviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code_insee?: boolean
    code_postal?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    ban_id?: boolean
    latitude?: boolean
    longitude?: boolean
    created_by?: boolean
    created_at?: boolean
    aides_territoires_perimeter_id?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectivite"]>

  export type collectiviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code_insee?: boolean
    code_postal?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    ban_id?: boolean
    latitude?: boolean
    longitude?: boolean
    created_by?: boolean
    created_at?: boolean
    aides_territoires_perimeter_id?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectivite"]>

  export type collectiviteSelectScalar = {
    id?: boolean
    nom?: boolean
    code_insee?: boolean
    code_postal?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    ban_id?: boolean
    latitude?: boolean
    longitude?: boolean
    created_by?: boolean
    created_at?: boolean
    aides_territoires_perimeter_id?: boolean
  }

  export type collectiviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "code_insee" | "code_postal" | "adresse_info" | "adresse_all_infos" | "ban_id" | "latitude" | "longitude" | "created_by" | "created_at" | "aides_territoires_perimeter_id", ExtArgs["result"]["collectivite"]>
  export type collectiviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | collectivite$usersArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | collectivite$projetArgs<ExtArgs>
    _count?: boolean | CollectiviteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type collectiviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type collectiviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $collectivitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collectivite"
    objects: {
      users: Prisma.$user_collectivitePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      projet: Prisma.$projetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      code_insee: string | null
      code_postal: string | null
      adresse_info: Prisma.JsonValue | null
      adresse_all_infos: Prisma.JsonValue | null
      ban_id: string | null
      latitude: number | null
      longitude: number | null
      created_by: string
      created_at: Date
      aides_territoires_perimeter_id: string | null
    }, ExtArgs["result"]["collectivite"]>
    composites: {}
  }

  type collectiviteGetPayload<S extends boolean | null | undefined | collectiviteDefaultArgs> = $Result.GetResult<Prisma.$collectivitePayload, S>

  type collectiviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<collectiviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectiviteCountAggregateInputType | true
    }

  export interface collectiviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collectivite'], meta: { name: 'collectivite' } }
    /**
     * Find zero or one Collectivite that matches the filter.
     * @param {collectiviteFindUniqueArgs} args - Arguments to find a Collectivite
     * @example
     * // Get one Collectivite
     * const collectivite = await prisma.collectivite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collectiviteFindUniqueArgs>(args: SelectSubset<T, collectiviteFindUniqueArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collectivite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {collectiviteFindUniqueOrThrowArgs} args - Arguments to find a Collectivite
     * @example
     * // Get one Collectivite
     * const collectivite = await prisma.collectivite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collectiviteFindUniqueOrThrowArgs>(args: SelectSubset<T, collectiviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collectivite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectiviteFindFirstArgs} args - Arguments to find a Collectivite
     * @example
     * // Get one Collectivite
     * const collectivite = await prisma.collectivite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collectiviteFindFirstArgs>(args?: SelectSubset<T, collectiviteFindFirstArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collectivite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectiviteFindFirstOrThrowArgs} args - Arguments to find a Collectivite
     * @example
     * // Get one Collectivite
     * const collectivite = await prisma.collectivite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collectiviteFindFirstOrThrowArgs>(args?: SelectSubset<T, collectiviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collectivites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectiviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collectivites
     * const collectivites = await prisma.collectivite.findMany()
     * 
     * // Get first 10 Collectivites
     * const collectivites = await prisma.collectivite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectiviteWithIdOnly = await prisma.collectivite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collectiviteFindManyArgs>(args?: SelectSubset<T, collectiviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collectivite.
     * @param {collectiviteCreateArgs} args - Arguments to create a Collectivite.
     * @example
     * // Create one Collectivite
     * const Collectivite = await prisma.collectivite.create({
     *   data: {
     *     // ... data to create a Collectivite
     *   }
     * })
     * 
     */
    create<T extends collectiviteCreateArgs>(args: SelectSubset<T, collectiviteCreateArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collectivites.
     * @param {collectiviteCreateManyArgs} args - Arguments to create many Collectivites.
     * @example
     * // Create many Collectivites
     * const collectivite = await prisma.collectivite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collectiviteCreateManyArgs>(args?: SelectSubset<T, collectiviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collectivites and returns the data saved in the database.
     * @param {collectiviteCreateManyAndReturnArgs} args - Arguments to create many Collectivites.
     * @example
     * // Create many Collectivites
     * const collectivite = await prisma.collectivite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collectivites and only return the `id`
     * const collectiviteWithIdOnly = await prisma.collectivite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collectiviteCreateManyAndReturnArgs>(args?: SelectSubset<T, collectiviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collectivite.
     * @param {collectiviteDeleteArgs} args - Arguments to delete one Collectivite.
     * @example
     * // Delete one Collectivite
     * const Collectivite = await prisma.collectivite.delete({
     *   where: {
     *     // ... filter to delete one Collectivite
     *   }
     * })
     * 
     */
    delete<T extends collectiviteDeleteArgs>(args: SelectSubset<T, collectiviteDeleteArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collectivite.
     * @param {collectiviteUpdateArgs} args - Arguments to update one Collectivite.
     * @example
     * // Update one Collectivite
     * const collectivite = await prisma.collectivite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collectiviteUpdateArgs>(args: SelectSubset<T, collectiviteUpdateArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collectivites.
     * @param {collectiviteDeleteManyArgs} args - Arguments to filter Collectivites to delete.
     * @example
     * // Delete a few Collectivites
     * const { count } = await prisma.collectivite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collectiviteDeleteManyArgs>(args?: SelectSubset<T, collectiviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collectivites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectiviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collectivites
     * const collectivite = await prisma.collectivite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collectiviteUpdateManyArgs>(args: SelectSubset<T, collectiviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collectivites and returns the data updated in the database.
     * @param {collectiviteUpdateManyAndReturnArgs} args - Arguments to update many Collectivites.
     * @example
     * // Update many Collectivites
     * const collectivite = await prisma.collectivite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collectivites and only return the `id`
     * const collectiviteWithIdOnly = await prisma.collectivite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends collectiviteUpdateManyAndReturnArgs>(args: SelectSubset<T, collectiviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collectivite.
     * @param {collectiviteUpsertArgs} args - Arguments to update or create a Collectivite.
     * @example
     * // Update or create a Collectivite
     * const collectivite = await prisma.collectivite.upsert({
     *   create: {
     *     // ... data to create a Collectivite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collectivite we want to update
     *   }
     * })
     */
    upsert<T extends collectiviteUpsertArgs>(args: SelectSubset<T, collectiviteUpsertArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collectivites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectiviteCountArgs} args - Arguments to filter Collectivites to count.
     * @example
     * // Count the number of Collectivites
     * const count = await prisma.collectivite.count({
     *   where: {
     *     // ... the filter for the Collectivites we want to count
     *   }
     * })
    **/
    count<T extends collectiviteCountArgs>(
      args?: Subset<T, collectiviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectiviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collectivite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectiviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectiviteAggregateArgs>(args: Subset<T, CollectiviteAggregateArgs>): Prisma.PrismaPromise<GetCollectiviteAggregateType<T>>

    /**
     * Group by Collectivite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectiviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collectiviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collectiviteGroupByArgs['orderBy'] }
        : { orderBy?: collectiviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collectiviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectiviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collectivite model
   */
  readonly fields: collectiviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collectivite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collectiviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends collectivite$usersArgs<ExtArgs> = {}>(args?: Subset<T, collectivite$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projet<T extends collectivite$projetArgs<ExtArgs> = {}>(args?: Subset<T, collectivite$projetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collectivite model
   */
  interface collectiviteFieldRefs {
    readonly id: FieldRef<"collectivite", 'Int'>
    readonly nom: FieldRef<"collectivite", 'String'>
    readonly code_insee: FieldRef<"collectivite", 'String'>
    readonly code_postal: FieldRef<"collectivite", 'String'>
    readonly adresse_info: FieldRef<"collectivite", 'Json'>
    readonly adresse_all_infos: FieldRef<"collectivite", 'Json'>
    readonly ban_id: FieldRef<"collectivite", 'String'>
    readonly latitude: FieldRef<"collectivite", 'Float'>
    readonly longitude: FieldRef<"collectivite", 'Float'>
    readonly created_by: FieldRef<"collectivite", 'String'>
    readonly created_at: FieldRef<"collectivite", 'DateTime'>
    readonly aides_territoires_perimeter_id: FieldRef<"collectivite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collectivite findUnique
   */
  export type collectiviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which collectivite to fetch.
     */
    where: collectiviteWhereUniqueInput
  }

  /**
   * collectivite findUniqueOrThrow
   */
  export type collectiviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which collectivite to fetch.
     */
    where: collectiviteWhereUniqueInput
  }

  /**
   * collectivite findFirst
   */
  export type collectiviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which collectivite to fetch.
     */
    where?: collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites to fetch.
     */
    orderBy?: collectiviteOrderByWithRelationInput | collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectivites.
     */
    cursor?: collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectivites.
     */
    distinct?: CollectiviteScalarFieldEnum | CollectiviteScalarFieldEnum[]
  }

  /**
   * collectivite findFirstOrThrow
   */
  export type collectiviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which collectivite to fetch.
     */
    where?: collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites to fetch.
     */
    orderBy?: collectiviteOrderByWithRelationInput | collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectivites.
     */
    cursor?: collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectivites.
     */
    distinct?: CollectiviteScalarFieldEnum | CollectiviteScalarFieldEnum[]
  }

  /**
   * collectivite findMany
   */
  export type collectiviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which collectivites to fetch.
     */
    where?: collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites to fetch.
     */
    orderBy?: collectiviteOrderByWithRelationInput | collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collectivites.
     */
    cursor?: collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites.
     */
    skip?: number
    distinct?: CollectiviteScalarFieldEnum | CollectiviteScalarFieldEnum[]
  }

  /**
   * collectivite create
   */
  export type collectiviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * The data needed to create a collectivite.
     */
    data: XOR<collectiviteCreateInput, collectiviteUncheckedCreateInput>
  }

  /**
   * collectivite createMany
   */
  export type collectiviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collectivites.
     */
    data: collectiviteCreateManyInput | collectiviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collectivite createManyAndReturn
   */
  export type collectiviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * The data used to create many collectivites.
     */
    data: collectiviteCreateManyInput | collectiviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * collectivite update
   */
  export type collectiviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * The data needed to update a collectivite.
     */
    data: XOR<collectiviteUpdateInput, collectiviteUncheckedUpdateInput>
    /**
     * Choose, which collectivite to update.
     */
    where: collectiviteWhereUniqueInput
  }

  /**
   * collectivite updateMany
   */
  export type collectiviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collectivites.
     */
    data: XOR<collectiviteUpdateManyMutationInput, collectiviteUncheckedUpdateManyInput>
    /**
     * Filter which collectivites to update
     */
    where?: collectiviteWhereInput
    /**
     * Limit how many collectivites to update.
     */
    limit?: number
  }

  /**
   * collectivite updateManyAndReturn
   */
  export type collectiviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * The data used to update collectivites.
     */
    data: XOR<collectiviteUpdateManyMutationInput, collectiviteUncheckedUpdateManyInput>
    /**
     * Filter which collectivites to update
     */
    where?: collectiviteWhereInput
    /**
     * Limit how many collectivites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * collectivite upsert
   */
  export type collectiviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * The filter to search for the collectivite to update in case it exists.
     */
    where: collectiviteWhereUniqueInput
    /**
     * In case the collectivite found by the `where` argument doesn't exist, create a new collectivite with this data.
     */
    create: XOR<collectiviteCreateInput, collectiviteUncheckedCreateInput>
    /**
     * In case the collectivite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collectiviteUpdateInput, collectiviteUncheckedUpdateInput>
  }

  /**
   * collectivite delete
   */
  export type collectiviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
    /**
     * Filter which collectivite to delete.
     */
    where: collectiviteWhereUniqueInput
  }

  /**
   * collectivite deleteMany
   */
  export type collectiviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collectivites to delete
     */
    where?: collectiviteWhereInput
    /**
     * Limit how many collectivites to delete.
     */
    limit?: number
  }

  /**
   * collectivite.users
   */
  export type collectivite$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    where?: user_collectiviteWhereInput
    orderBy?: user_collectiviteOrderByWithRelationInput | user_collectiviteOrderByWithRelationInput[]
    cursor?: user_collectiviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_collectiviteScalarFieldEnum | User_collectiviteScalarFieldEnum[]
  }

  /**
   * collectivite.projet
   */
  export type collectivite$projetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    where?: projetWhereInput
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    cursor?: projetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetScalarFieldEnum | ProjetScalarFieldEnum[]
  }

  /**
   * collectivite without action
   */
  export type collectiviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivite
     */
    select?: collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivite
     */
    omit?: collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectiviteInclude<ExtArgs> | null
  }


  /**
   * Model user_projet
   */

  export type AggregateUser_projet = {
    _count: User_projetCountAggregateOutputType | null
    _avg: User_projetAvgAggregateOutputType | null
    _sum: User_projetSumAggregateOutputType | null
    _min: User_projetMinAggregateOutputType | null
    _max: User_projetMaxAggregateOutputType | null
  }

  export type User_projetAvgAggregateOutputType = {
    id: number | null
    projet_id: number | null
    nb_views: number | null
  }

  export type User_projetSumAggregateOutputType = {
    id: number | null
    projet_id: number | null
    nb_views: number | null
  }

  export type User_projetMinAggregateOutputType = {
    id: number | null
    email_address: string | null
    role: $Enums.RoleProjet | null
    projet_id: number | null
    user_id: string | null
    created_at: Date | null
    invitation_token: string | null
    invitation_status: $Enums.InvitationStatus | null
    deleted_at: Date | null
    deleted_by: string | null
    nb_views: number | null
    last_viewed_at: Date | null
  }

  export type User_projetMaxAggregateOutputType = {
    id: number | null
    email_address: string | null
    role: $Enums.RoleProjet | null
    projet_id: number | null
    user_id: string | null
    created_at: Date | null
    invitation_token: string | null
    invitation_status: $Enums.InvitationStatus | null
    deleted_at: Date | null
    deleted_by: string | null
    nb_views: number | null
    last_viewed_at: Date | null
  }

  export type User_projetCountAggregateOutputType = {
    id: number
    email_address: number
    role: number
    projet_id: number
    user_id: number
    created_at: number
    invitation_token: number
    invitation_status: number
    deleted_at: number
    deleted_by: number
    nb_views: number
    last_viewed_at: number
    _all: number
  }


  export type User_projetAvgAggregateInputType = {
    id?: true
    projet_id?: true
    nb_views?: true
  }

  export type User_projetSumAggregateInputType = {
    id?: true
    projet_id?: true
    nb_views?: true
  }

  export type User_projetMinAggregateInputType = {
    id?: true
    email_address?: true
    role?: true
    projet_id?: true
    user_id?: true
    created_at?: true
    invitation_token?: true
    invitation_status?: true
    deleted_at?: true
    deleted_by?: true
    nb_views?: true
    last_viewed_at?: true
  }

  export type User_projetMaxAggregateInputType = {
    id?: true
    email_address?: true
    role?: true
    projet_id?: true
    user_id?: true
    created_at?: true
    invitation_token?: true
    invitation_status?: true
    deleted_at?: true
    deleted_by?: true
    nb_views?: true
    last_viewed_at?: true
  }

  export type User_projetCountAggregateInputType = {
    id?: true
    email_address?: true
    role?: true
    projet_id?: true
    user_id?: true
    created_at?: true
    invitation_token?: true
    invitation_status?: true
    deleted_at?: true
    deleted_by?: true
    nb_views?: true
    last_viewed_at?: true
    _all?: true
  }

  export type User_projetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_projet to aggregate.
     */
    where?: user_projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_projets to fetch.
     */
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_projets
    **/
    _count?: true | User_projetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_projetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_projetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_projetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_projetMaxAggregateInputType
  }

  export type GetUser_projetAggregateType<T extends User_projetAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_projet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_projet[P]>
      : GetScalarType<T[P], AggregateUser_projet[P]>
  }




  export type user_projetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_projetWhereInput
    orderBy?: user_projetOrderByWithAggregationInput | user_projetOrderByWithAggregationInput[]
    by: User_projetScalarFieldEnum[] | User_projetScalarFieldEnum
    having?: user_projetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_projetCountAggregateInputType | true
    _avg?: User_projetAvgAggregateInputType
    _sum?: User_projetSumAggregateInputType
    _min?: User_projetMinAggregateInputType
    _max?: User_projetMaxAggregateInputType
  }

  export type User_projetGroupByOutputType = {
    id: number
    email_address: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id: string | null
    created_at: Date
    invitation_token: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at: Date | null
    deleted_by: string | null
    nb_views: number | null
    last_viewed_at: Date | null
    _count: User_projetCountAggregateOutputType | null
    _avg: User_projetAvgAggregateOutputType | null
    _sum: User_projetSumAggregateOutputType | null
    _min: User_projetMinAggregateOutputType | null
    _max: User_projetMaxAggregateOutputType | null
  }

  type GetUser_projetGroupByPayload<T extends user_projetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_projetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_projetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_projetGroupByOutputType[P]>
            : GetScalarType<T[P], User_projetGroupByOutputType[P]>
        }
      >
    >


  export type user_projetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email_address?: boolean
    role?: boolean
    projet_id?: boolean
    user_id?: boolean
    created_at?: boolean
    invitation_token?: boolean
    invitation_status?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    nb_views?: boolean
    last_viewed_at?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | user_projet$userArgs<ExtArgs>
    deleter?: boolean | user_projet$deleterArgs<ExtArgs>
    email?: boolean | user_projet$emailArgs<ExtArgs>
    sourced_by_projets?: boolean | user_projet$sourced_by_projetsArgs<ExtArgs>
    _count?: boolean | User_projetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_projet"]>

  export type user_projetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email_address?: boolean
    role?: boolean
    projet_id?: boolean
    user_id?: boolean
    created_at?: boolean
    invitation_token?: boolean
    invitation_status?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    nb_views?: boolean
    last_viewed_at?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | user_projet$userArgs<ExtArgs>
    deleter?: boolean | user_projet$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["user_projet"]>

  export type user_projetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email_address?: boolean
    role?: boolean
    projet_id?: boolean
    user_id?: boolean
    created_at?: boolean
    invitation_token?: boolean
    invitation_status?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    nb_views?: boolean
    last_viewed_at?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | user_projet$userArgs<ExtArgs>
    deleter?: boolean | user_projet$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["user_projet"]>

  export type user_projetSelectScalar = {
    id?: boolean
    email_address?: boolean
    role?: boolean
    projet_id?: boolean
    user_id?: boolean
    created_at?: boolean
    invitation_token?: boolean
    invitation_status?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    nb_views?: boolean
    last_viewed_at?: boolean
  }

  export type user_projetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email_address" | "role" | "projet_id" | "user_id" | "created_at" | "invitation_token" | "invitation_status" | "deleted_at" | "deleted_by" | "nb_views" | "last_viewed_at", ExtArgs["result"]["user_projet"]>
  export type user_projetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | user_projet$userArgs<ExtArgs>
    deleter?: boolean | user_projet$deleterArgs<ExtArgs>
    email?: boolean | user_projet$emailArgs<ExtArgs>
    sourced_by_projets?: boolean | user_projet$sourced_by_projetsArgs<ExtArgs>
    _count?: boolean | User_projetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type user_projetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | user_projet$userArgs<ExtArgs>
    deleter?: boolean | user_projet$deleterArgs<ExtArgs>
  }
  export type user_projetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | user_projet$userArgs<ExtArgs>
    deleter?: boolean | user_projet$deleterArgs<ExtArgs>
  }

  export type $user_projetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_projet"
    objects: {
      projet: Prisma.$projetPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      deleter: Prisma.$UserPayload<ExtArgs> | null
      email: Prisma.$emailPayload<ExtArgs>[]
      sourced_by_projets: Prisma.$projet_sourcing_contactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email_address: string | null
      role: $Enums.RoleProjet
      projet_id: number
      user_id: string | null
      created_at: Date
      invitation_token: string | null
      invitation_status: $Enums.InvitationStatus
      deleted_at: Date | null
      deleted_by: string | null
      nb_views: number | null
      last_viewed_at: Date | null
    }, ExtArgs["result"]["user_projet"]>
    composites: {}
  }

  type user_projetGetPayload<S extends boolean | null | undefined | user_projetDefaultArgs> = $Result.GetResult<Prisma.$user_projetPayload, S>

  type user_projetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_projetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_projetCountAggregateInputType | true
    }

  export interface user_projetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_projet'], meta: { name: 'user_projet' } }
    /**
     * Find zero or one User_projet that matches the filter.
     * @param {user_projetFindUniqueArgs} args - Arguments to find a User_projet
     * @example
     * // Get one User_projet
     * const user_projet = await prisma.user_projet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_projetFindUniqueArgs>(args: SelectSubset<T, user_projetFindUniqueArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_projet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_projetFindUniqueOrThrowArgs} args - Arguments to find a User_projet
     * @example
     * // Get one User_projet
     * const user_projet = await prisma.user_projet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_projetFindUniqueOrThrowArgs>(args: SelectSubset<T, user_projetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_projet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_projetFindFirstArgs} args - Arguments to find a User_projet
     * @example
     * // Get one User_projet
     * const user_projet = await prisma.user_projet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_projetFindFirstArgs>(args?: SelectSubset<T, user_projetFindFirstArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_projet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_projetFindFirstOrThrowArgs} args - Arguments to find a User_projet
     * @example
     * // Get one User_projet
     * const user_projet = await prisma.user_projet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_projetFindFirstOrThrowArgs>(args?: SelectSubset<T, user_projetFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_projets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_projetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_projets
     * const user_projets = await prisma.user_projet.findMany()
     * 
     * // Get first 10 User_projets
     * const user_projets = await prisma.user_projet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_projetWithIdOnly = await prisma.user_projet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_projetFindManyArgs>(args?: SelectSubset<T, user_projetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_projet.
     * @param {user_projetCreateArgs} args - Arguments to create a User_projet.
     * @example
     * // Create one User_projet
     * const User_projet = await prisma.user_projet.create({
     *   data: {
     *     // ... data to create a User_projet
     *   }
     * })
     * 
     */
    create<T extends user_projetCreateArgs>(args: SelectSubset<T, user_projetCreateArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_projets.
     * @param {user_projetCreateManyArgs} args - Arguments to create many User_projets.
     * @example
     * // Create many User_projets
     * const user_projet = await prisma.user_projet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_projetCreateManyArgs>(args?: SelectSubset<T, user_projetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_projets and returns the data saved in the database.
     * @param {user_projetCreateManyAndReturnArgs} args - Arguments to create many User_projets.
     * @example
     * // Create many User_projets
     * const user_projet = await prisma.user_projet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_projets and only return the `id`
     * const user_projetWithIdOnly = await prisma.user_projet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_projetCreateManyAndReturnArgs>(args?: SelectSubset<T, user_projetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_projet.
     * @param {user_projetDeleteArgs} args - Arguments to delete one User_projet.
     * @example
     * // Delete one User_projet
     * const User_projet = await prisma.user_projet.delete({
     *   where: {
     *     // ... filter to delete one User_projet
     *   }
     * })
     * 
     */
    delete<T extends user_projetDeleteArgs>(args: SelectSubset<T, user_projetDeleteArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_projet.
     * @param {user_projetUpdateArgs} args - Arguments to update one User_projet.
     * @example
     * // Update one User_projet
     * const user_projet = await prisma.user_projet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_projetUpdateArgs>(args: SelectSubset<T, user_projetUpdateArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_projets.
     * @param {user_projetDeleteManyArgs} args - Arguments to filter User_projets to delete.
     * @example
     * // Delete a few User_projets
     * const { count } = await prisma.user_projet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_projetDeleteManyArgs>(args?: SelectSubset<T, user_projetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_projetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_projets
     * const user_projet = await prisma.user_projet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_projetUpdateManyArgs>(args: SelectSubset<T, user_projetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_projets and returns the data updated in the database.
     * @param {user_projetUpdateManyAndReturnArgs} args - Arguments to update many User_projets.
     * @example
     * // Update many User_projets
     * const user_projet = await prisma.user_projet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_projets and only return the `id`
     * const user_projetWithIdOnly = await prisma.user_projet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_projetUpdateManyAndReturnArgs>(args: SelectSubset<T, user_projetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_projet.
     * @param {user_projetUpsertArgs} args - Arguments to update or create a User_projet.
     * @example
     * // Update or create a User_projet
     * const user_projet = await prisma.user_projet.upsert({
     *   create: {
     *     // ... data to create a User_projet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_projet we want to update
     *   }
     * })
     */
    upsert<T extends user_projetUpsertArgs>(args: SelectSubset<T, user_projetUpsertArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_projetCountArgs} args - Arguments to filter User_projets to count.
     * @example
     * // Count the number of User_projets
     * const count = await prisma.user_projet.count({
     *   where: {
     *     // ... the filter for the User_projets we want to count
     *   }
     * })
    **/
    count<T extends user_projetCountArgs>(
      args?: Subset<T, user_projetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_projetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_projet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_projetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_projetAggregateArgs>(args: Subset<T, User_projetAggregateArgs>): Prisma.PrismaPromise<GetUser_projetAggregateType<T>>

    /**
     * Group by User_projet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_projetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_projetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_projetGroupByArgs['orderBy'] }
        : { orderBy?: user_projetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_projetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_projetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_projet model
   */
  readonly fields: user_projetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_projet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_projetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projet<T extends projetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetDefaultArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends user_projet$userArgs<ExtArgs> = {}>(args?: Subset<T, user_projet$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deleter<T extends user_projet$deleterArgs<ExtArgs> = {}>(args?: Subset<T, user_projet$deleterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    email<T extends user_projet$emailArgs<ExtArgs> = {}>(args?: Subset<T, user_projet$emailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourced_by_projets<T extends user_projet$sourced_by_projetsArgs<ExtArgs> = {}>(args?: Subset<T, user_projet$sourced_by_projetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_projet model
   */
  interface user_projetFieldRefs {
    readonly id: FieldRef<"user_projet", 'Int'>
    readonly email_address: FieldRef<"user_projet", 'String'>
    readonly role: FieldRef<"user_projet", 'RoleProjet'>
    readonly projet_id: FieldRef<"user_projet", 'Int'>
    readonly user_id: FieldRef<"user_projet", 'String'>
    readonly created_at: FieldRef<"user_projet", 'DateTime'>
    readonly invitation_token: FieldRef<"user_projet", 'String'>
    readonly invitation_status: FieldRef<"user_projet", 'InvitationStatus'>
    readonly deleted_at: FieldRef<"user_projet", 'DateTime'>
    readonly deleted_by: FieldRef<"user_projet", 'String'>
    readonly nb_views: FieldRef<"user_projet", 'Int'>
    readonly last_viewed_at: FieldRef<"user_projet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_projet findUnique
   */
  export type user_projetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * Filter, which user_projet to fetch.
     */
    where: user_projetWhereUniqueInput
  }

  /**
   * user_projet findUniqueOrThrow
   */
  export type user_projetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * Filter, which user_projet to fetch.
     */
    where: user_projetWhereUniqueInput
  }

  /**
   * user_projet findFirst
   */
  export type user_projetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * Filter, which user_projet to fetch.
     */
    where?: user_projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_projets to fetch.
     */
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_projets.
     */
    cursor?: user_projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_projets.
     */
    distinct?: User_projetScalarFieldEnum | User_projetScalarFieldEnum[]
  }

  /**
   * user_projet findFirstOrThrow
   */
  export type user_projetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * Filter, which user_projet to fetch.
     */
    where?: user_projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_projets to fetch.
     */
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_projets.
     */
    cursor?: user_projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_projets.
     */
    distinct?: User_projetScalarFieldEnum | User_projetScalarFieldEnum[]
  }

  /**
   * user_projet findMany
   */
  export type user_projetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * Filter, which user_projets to fetch.
     */
    where?: user_projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_projets to fetch.
     */
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_projets.
     */
    cursor?: user_projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_projets.
     */
    skip?: number
    distinct?: User_projetScalarFieldEnum | User_projetScalarFieldEnum[]
  }

  /**
   * user_projet create
   */
  export type user_projetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * The data needed to create a user_projet.
     */
    data: XOR<user_projetCreateInput, user_projetUncheckedCreateInput>
  }

  /**
   * user_projet createMany
   */
  export type user_projetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_projets.
     */
    data: user_projetCreateManyInput | user_projetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_projet createManyAndReturn
   */
  export type user_projetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * The data used to create many user_projets.
     */
    data: user_projetCreateManyInput | user_projetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_projet update
   */
  export type user_projetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * The data needed to update a user_projet.
     */
    data: XOR<user_projetUpdateInput, user_projetUncheckedUpdateInput>
    /**
     * Choose, which user_projet to update.
     */
    where: user_projetWhereUniqueInput
  }

  /**
   * user_projet updateMany
   */
  export type user_projetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_projets.
     */
    data: XOR<user_projetUpdateManyMutationInput, user_projetUncheckedUpdateManyInput>
    /**
     * Filter which user_projets to update
     */
    where?: user_projetWhereInput
    /**
     * Limit how many user_projets to update.
     */
    limit?: number
  }

  /**
   * user_projet updateManyAndReturn
   */
  export type user_projetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * The data used to update user_projets.
     */
    data: XOR<user_projetUpdateManyMutationInput, user_projetUncheckedUpdateManyInput>
    /**
     * Filter which user_projets to update
     */
    where?: user_projetWhereInput
    /**
     * Limit how many user_projets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_projet upsert
   */
  export type user_projetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * The filter to search for the user_projet to update in case it exists.
     */
    where: user_projetWhereUniqueInput
    /**
     * In case the user_projet found by the `where` argument doesn't exist, create a new user_projet with this data.
     */
    create: XOR<user_projetCreateInput, user_projetUncheckedCreateInput>
    /**
     * In case the user_projet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_projetUpdateInput, user_projetUncheckedUpdateInput>
  }

  /**
   * user_projet delete
   */
  export type user_projetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    /**
     * Filter which user_projet to delete.
     */
    where: user_projetWhereUniqueInput
  }

  /**
   * user_projet deleteMany
   */
  export type user_projetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_projets to delete
     */
    where?: user_projetWhereInput
    /**
     * Limit how many user_projets to delete.
     */
    limit?: number
  }

  /**
   * user_projet.user
   */
  export type user_projet$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * user_projet.deleter
   */
  export type user_projet$deleterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * user_projet.email
   */
  export type user_projet$emailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    where?: emailWhereInput
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[]
    cursor?: emailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * user_projet.sourced_by_projets
   */
  export type user_projet$sourced_by_projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    where?: projet_sourcing_contactWhereInput
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    cursor?: projet_sourcing_contactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_sourcing_contactScalarFieldEnum | Projet_sourcing_contactScalarFieldEnum[]
  }

  /**
   * user_projet without action
   */
  export type user_projetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
  }


  /**
   * Model email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailAvgAggregateOutputType = {
    user_projet_id: number | null
  }

  export type EmailSumAggregateOutputType = {
    user_projet_id: number | null
  }

  export type EmailMinAggregateOutputType = {
    id: string | null
    destination_address: string | null
    type: $Enums.emailType | null
    sending_time: Date | null
    brevo_id: string | null
    email_status: $Enums.emailStatus | null
    user_projet_id: number | null
    user_id: string | null
  }

  export type EmailMaxAggregateOutputType = {
    id: string | null
    destination_address: string | null
    type: $Enums.emailType | null
    sending_time: Date | null
    brevo_id: string | null
    email_status: $Enums.emailStatus | null
    user_projet_id: number | null
    user_id: string | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    destination_address: number
    type: number
    sending_time: number
    brevo_id: number
    email_status: number
    user_projet_id: number
    user_id: number
    extra: number
    _all: number
  }


  export type EmailAvgAggregateInputType = {
    user_projet_id?: true
  }

  export type EmailSumAggregateInputType = {
    user_projet_id?: true
  }

  export type EmailMinAggregateInputType = {
    id?: true
    destination_address?: true
    type?: true
    sending_time?: true
    brevo_id?: true
    email_status?: true
    user_projet_id?: true
    user_id?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    destination_address?: true
    type?: true
    sending_time?: true
    brevo_id?: true
    email_status?: true
    user_projet_id?: true
    user_id?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    destination_address?: true
    type?: true
    sending_time?: true
    brevo_id?: true
    email_status?: true
    user_projet_id?: true
    user_id?: true
    extra?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email to aggregate.
     */
    where?: emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type emailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: emailWhereInput
    orderBy?: emailOrderByWithAggregationInput | emailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: emailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _avg?: EmailAvgAggregateInputType
    _sum?: EmailSumAggregateInputType
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: string
    destination_address: string
    type: $Enums.emailType
    sending_time: Date
    brevo_id: string | null
    email_status: $Enums.emailStatus
    user_projet_id: number | null
    user_id: string | null
    extra: JsonValue | null
    _count: EmailCountAggregateOutputType | null
    _avg: EmailAvgAggregateOutputType | null
    _sum: EmailSumAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends emailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type emailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destination_address?: boolean
    type?: boolean
    sending_time?: boolean
    brevo_id?: boolean
    email_status?: boolean
    user_projet_id?: boolean
    user_id?: boolean
    extra?: boolean
    user_projet?: boolean | email$user_projetArgs<ExtArgs>
    user?: boolean | email$userArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type emailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destination_address?: boolean
    type?: boolean
    sending_time?: boolean
    brevo_id?: boolean
    email_status?: boolean
    user_projet_id?: boolean
    user_id?: boolean
    extra?: boolean
    user_projet?: boolean | email$user_projetArgs<ExtArgs>
    user?: boolean | email$userArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type emailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    destination_address?: boolean
    type?: boolean
    sending_time?: boolean
    brevo_id?: boolean
    email_status?: boolean
    user_projet_id?: boolean
    user_id?: boolean
    extra?: boolean
    user_projet?: boolean | email$user_projetArgs<ExtArgs>
    user?: boolean | email$userArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type emailSelectScalar = {
    id?: boolean
    destination_address?: boolean
    type?: boolean
    sending_time?: boolean
    brevo_id?: boolean
    email_status?: boolean
    user_projet_id?: boolean
    user_id?: boolean
    extra?: boolean
  }

  export type emailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "destination_address" | "type" | "sending_time" | "brevo_id" | "email_status" | "user_projet_id" | "user_id" | "extra", ExtArgs["result"]["email"]>
  export type emailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_projet?: boolean | email$user_projetArgs<ExtArgs>
    user?: boolean | email$userArgs<ExtArgs>
  }
  export type emailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_projet?: boolean | email$user_projetArgs<ExtArgs>
    user?: boolean | email$userArgs<ExtArgs>
  }
  export type emailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_projet?: boolean | email$user_projetArgs<ExtArgs>
    user?: boolean | email$userArgs<ExtArgs>
  }

  export type $emailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email"
    objects: {
      user_projet: Prisma.$user_projetPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      destination_address: string
      type: $Enums.emailType
      sending_time: Date
      brevo_id: string | null
      email_status: $Enums.emailStatus
      user_projet_id: number | null
      user_id: string | null
      extra: Prisma.JsonValue | null
    }, ExtArgs["result"]["email"]>
    composites: {}
  }

  type emailGetPayload<S extends boolean | null | undefined | emailDefaultArgs> = $Result.GetResult<Prisma.$emailPayload, S>

  type emailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<emailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface emailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email'], meta: { name: 'email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {emailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends emailFindUniqueArgs>(args: SelectSubset<T, emailFindUniqueArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {emailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends emailFindUniqueOrThrowArgs>(args: SelectSubset<T, emailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends emailFindFirstArgs>(args?: SelectSubset<T, emailFindFirstArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends emailFindFirstOrThrowArgs>(args?: SelectSubset<T, emailFindFirstOrThrowArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends emailFindManyArgs>(args?: SelectSubset<T, emailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email.
     * @param {emailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
     */
    create<T extends emailCreateArgs>(args: SelectSubset<T, emailCreateArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emails.
     * @param {emailCreateManyArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends emailCreateManyArgs>(args?: SelectSubset<T, emailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emails and returns the data saved in the database.
     * @param {emailCreateManyAndReturnArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emails and only return the `id`
     * const emailWithIdOnly = await prisma.email.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends emailCreateManyAndReturnArgs>(args?: SelectSubset<T, emailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email.
     * @param {emailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
     */
    delete<T extends emailDeleteArgs>(args: SelectSubset<T, emailDeleteArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email.
     * @param {emailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends emailUpdateArgs>(args: SelectSubset<T, emailUpdateArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emails.
     * @param {emailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends emailDeleteManyArgs>(args?: SelectSubset<T, emailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends emailUpdateManyArgs>(args: SelectSubset<T, emailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails and returns the data updated in the database.
     * @param {emailUpdateManyAndReturnArgs} args - Arguments to update many Emails.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emails and only return the `id`
     * const emailWithIdOnly = await prisma.email.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends emailUpdateManyAndReturnArgs>(args: SelectSubset<T, emailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email.
     * @param {emailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
     */
    upsert<T extends emailUpsertArgs>(args: SelectSubset<T, emailUpsertArgs<ExtArgs>>): Prisma__emailClient<$Result.GetResult<Prisma.$emailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends emailCountArgs>(
      args?: Subset<T, emailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends emailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: emailGroupByArgs['orderBy'] }
        : { orderBy?: emailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, emailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email model
   */
  readonly fields: emailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__emailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_projet<T extends email$user_projetArgs<ExtArgs> = {}>(args?: Subset<T, email$user_projetArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends email$userArgs<ExtArgs> = {}>(args?: Subset<T, email$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email model
   */
  interface emailFieldRefs {
    readonly id: FieldRef<"email", 'String'>
    readonly destination_address: FieldRef<"email", 'String'>
    readonly type: FieldRef<"email", 'emailType'>
    readonly sending_time: FieldRef<"email", 'DateTime'>
    readonly brevo_id: FieldRef<"email", 'String'>
    readonly email_status: FieldRef<"email", 'emailStatus'>
    readonly user_projet_id: FieldRef<"email", 'Int'>
    readonly user_id: FieldRef<"email", 'String'>
    readonly extra: FieldRef<"email", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * email findUnique
   */
  export type emailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * Filter, which email to fetch.
     */
    where: emailWhereUniqueInput
  }

  /**
   * email findUniqueOrThrow
   */
  export type emailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * Filter, which email to fetch.
     */
    where: emailWhereUniqueInput
  }

  /**
   * email findFirst
   */
  export type emailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * Filter, which email to fetch.
     */
    where?: emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emails.
     */
    cursor?: emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * email findFirstOrThrow
   */
  export type emailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * Filter, which email to fetch.
     */
    where?: emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emails.
     */
    cursor?: emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * email findMany
   */
  export type emailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * Filter, which emails to fetch.
     */
    where?: emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing emails.
     */
    cursor?: emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * email create
   */
  export type emailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * The data needed to create a email.
     */
    data: XOR<emailCreateInput, emailUncheckedCreateInput>
  }

  /**
   * email createMany
   */
  export type emailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many emails.
     */
    data: emailCreateManyInput | emailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email createManyAndReturn
   */
  export type emailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * The data used to create many emails.
     */
    data: emailCreateManyInput | emailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * email update
   */
  export type emailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * The data needed to update a email.
     */
    data: XOR<emailUpdateInput, emailUncheckedUpdateInput>
    /**
     * Choose, which email to update.
     */
    where: emailWhereUniqueInput
  }

  /**
   * email updateMany
   */
  export type emailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update emails.
     */
    data: XOR<emailUpdateManyMutationInput, emailUncheckedUpdateManyInput>
    /**
     * Filter which emails to update
     */
    where?: emailWhereInput
    /**
     * Limit how many emails to update.
     */
    limit?: number
  }

  /**
   * email updateManyAndReturn
   */
  export type emailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * The data used to update emails.
     */
    data: XOR<emailUpdateManyMutationInput, emailUncheckedUpdateManyInput>
    /**
     * Filter which emails to update
     */
    where?: emailWhereInput
    /**
     * Limit how many emails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * email upsert
   */
  export type emailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * The filter to search for the email to update in case it exists.
     */
    where: emailWhereUniqueInput
    /**
     * In case the email found by the `where` argument doesn't exist, create a new email with this data.
     */
    create: XOR<emailCreateInput, emailUncheckedCreateInput>
    /**
     * In case the email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<emailUpdateInput, emailUncheckedUpdateInput>
  }

  /**
   * email delete
   */
  export type emailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
    /**
     * Filter which email to delete.
     */
    where: emailWhereUniqueInput
  }

  /**
   * email deleteMany
   */
  export type emailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which emails to delete
     */
    where?: emailWhereInput
    /**
     * Limit how many emails to delete.
     */
    limit?: number
  }

  /**
   * email.user_projet
   */
  export type email$user_projetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    where?: user_projetWhereInput
  }

  /**
   * email.user
   */
  export type email$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * email without action
   */
  export type emailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null
  }


  /**
   * Model user_collectivite
   */

  export type AggregateUser_collectivite = {
    _count: User_collectiviteCountAggregateOutputType | null
    _avg: User_collectiviteAvgAggregateOutputType | null
    _sum: User_collectiviteSumAggregateOutputType | null
    _min: User_collectiviteMinAggregateOutputType | null
    _max: User_collectiviteMaxAggregateOutputType | null
  }

  export type User_collectiviteAvgAggregateOutputType = {
    collectivite_id: number | null
  }

  export type User_collectiviteSumAggregateOutputType = {
    collectivite_id: number | null
  }

  export type User_collectiviteMinAggregateOutputType = {
    user_id: string | null
    collectivite_id: number | null
    verified: boolean | null
    created_at: Date | null
  }

  export type User_collectiviteMaxAggregateOutputType = {
    user_id: string | null
    collectivite_id: number | null
    verified: boolean | null
    created_at: Date | null
  }

  export type User_collectiviteCountAggregateOutputType = {
    user_id: number
    collectivite_id: number
    verified: number
    created_at: number
    _all: number
  }


  export type User_collectiviteAvgAggregateInputType = {
    collectivite_id?: true
  }

  export type User_collectiviteSumAggregateInputType = {
    collectivite_id?: true
  }

  export type User_collectiviteMinAggregateInputType = {
    user_id?: true
    collectivite_id?: true
    verified?: true
    created_at?: true
  }

  export type User_collectiviteMaxAggregateInputType = {
    user_id?: true
    collectivite_id?: true
    verified?: true
    created_at?: true
  }

  export type User_collectiviteCountAggregateInputType = {
    user_id?: true
    collectivite_id?: true
    verified?: true
    created_at?: true
    _all?: true
  }

  export type User_collectiviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_collectivite to aggregate.
     */
    where?: user_collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_collectivites to fetch.
     */
    orderBy?: user_collectiviteOrderByWithRelationInput | user_collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_collectivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_collectivites
    **/
    _count?: true | User_collectiviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_collectiviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_collectiviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_collectiviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_collectiviteMaxAggregateInputType
  }

  export type GetUser_collectiviteAggregateType<T extends User_collectiviteAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_collectivite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_collectivite[P]>
      : GetScalarType<T[P], AggregateUser_collectivite[P]>
  }




  export type user_collectiviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_collectiviteWhereInput
    orderBy?: user_collectiviteOrderByWithAggregationInput | user_collectiviteOrderByWithAggregationInput[]
    by: User_collectiviteScalarFieldEnum[] | User_collectiviteScalarFieldEnum
    having?: user_collectiviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_collectiviteCountAggregateInputType | true
    _avg?: User_collectiviteAvgAggregateInputType
    _sum?: User_collectiviteSumAggregateInputType
    _min?: User_collectiviteMinAggregateInputType
    _max?: User_collectiviteMaxAggregateInputType
  }

  export type User_collectiviteGroupByOutputType = {
    user_id: string
    collectivite_id: number
    verified: boolean
    created_at: Date
    _count: User_collectiviteCountAggregateOutputType | null
    _avg: User_collectiviteAvgAggregateOutputType | null
    _sum: User_collectiviteSumAggregateOutputType | null
    _min: User_collectiviteMinAggregateOutputType | null
    _max: User_collectiviteMaxAggregateOutputType | null
  }

  type GetUser_collectiviteGroupByPayload<T extends user_collectiviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_collectiviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_collectiviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_collectiviteGroupByOutputType[P]>
            : GetScalarType<T[P], User_collectiviteGroupByOutputType[P]>
        }
      >
    >


  export type user_collectiviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    collectivite_id?: boolean
    verified?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_collectivite"]>

  export type user_collectiviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    collectivite_id?: boolean
    verified?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_collectivite"]>

  export type user_collectiviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    collectivite_id?: boolean
    verified?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_collectivite"]>

  export type user_collectiviteSelectScalar = {
    user_id?: boolean
    collectivite_id?: boolean
    verified?: boolean
    created_at?: boolean
  }

  export type user_collectiviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "collectivite_id" | "verified" | "created_at", ExtArgs["result"]["user_collectivite"]>
  export type user_collectiviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
  }
  export type user_collectiviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
  }
  export type user_collectiviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
  }

  export type $user_collectivitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_collectivite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      collectivite: Prisma.$collectivitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      collectivite_id: number
      verified: boolean
      created_at: Date
    }, ExtArgs["result"]["user_collectivite"]>
    composites: {}
  }

  type user_collectiviteGetPayload<S extends boolean | null | undefined | user_collectiviteDefaultArgs> = $Result.GetResult<Prisma.$user_collectivitePayload, S>

  type user_collectiviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_collectiviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_collectiviteCountAggregateInputType | true
    }

  export interface user_collectiviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_collectivite'], meta: { name: 'user_collectivite' } }
    /**
     * Find zero or one User_collectivite that matches the filter.
     * @param {user_collectiviteFindUniqueArgs} args - Arguments to find a User_collectivite
     * @example
     * // Get one User_collectivite
     * const user_collectivite = await prisma.user_collectivite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_collectiviteFindUniqueArgs>(args: SelectSubset<T, user_collectiviteFindUniqueArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_collectivite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_collectiviteFindUniqueOrThrowArgs} args - Arguments to find a User_collectivite
     * @example
     * // Get one User_collectivite
     * const user_collectivite = await prisma.user_collectivite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_collectiviteFindUniqueOrThrowArgs>(args: SelectSubset<T, user_collectiviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_collectivite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_collectiviteFindFirstArgs} args - Arguments to find a User_collectivite
     * @example
     * // Get one User_collectivite
     * const user_collectivite = await prisma.user_collectivite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_collectiviteFindFirstArgs>(args?: SelectSubset<T, user_collectiviteFindFirstArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_collectivite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_collectiviteFindFirstOrThrowArgs} args - Arguments to find a User_collectivite
     * @example
     * // Get one User_collectivite
     * const user_collectivite = await prisma.user_collectivite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_collectiviteFindFirstOrThrowArgs>(args?: SelectSubset<T, user_collectiviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_collectivites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_collectiviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_collectivites
     * const user_collectivites = await prisma.user_collectivite.findMany()
     * 
     * // Get first 10 User_collectivites
     * const user_collectivites = await prisma.user_collectivite.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_collectiviteWithUser_idOnly = await prisma.user_collectivite.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_collectiviteFindManyArgs>(args?: SelectSubset<T, user_collectiviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_collectivite.
     * @param {user_collectiviteCreateArgs} args - Arguments to create a User_collectivite.
     * @example
     * // Create one User_collectivite
     * const User_collectivite = await prisma.user_collectivite.create({
     *   data: {
     *     // ... data to create a User_collectivite
     *   }
     * })
     * 
     */
    create<T extends user_collectiviteCreateArgs>(args: SelectSubset<T, user_collectiviteCreateArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_collectivites.
     * @param {user_collectiviteCreateManyArgs} args - Arguments to create many User_collectivites.
     * @example
     * // Create many User_collectivites
     * const user_collectivite = await prisma.user_collectivite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_collectiviteCreateManyArgs>(args?: SelectSubset<T, user_collectiviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_collectivites and returns the data saved in the database.
     * @param {user_collectiviteCreateManyAndReturnArgs} args - Arguments to create many User_collectivites.
     * @example
     * // Create many User_collectivites
     * const user_collectivite = await prisma.user_collectivite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_collectivites and only return the `user_id`
     * const user_collectiviteWithUser_idOnly = await prisma.user_collectivite.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_collectiviteCreateManyAndReturnArgs>(args?: SelectSubset<T, user_collectiviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_collectivite.
     * @param {user_collectiviteDeleteArgs} args - Arguments to delete one User_collectivite.
     * @example
     * // Delete one User_collectivite
     * const User_collectivite = await prisma.user_collectivite.delete({
     *   where: {
     *     // ... filter to delete one User_collectivite
     *   }
     * })
     * 
     */
    delete<T extends user_collectiviteDeleteArgs>(args: SelectSubset<T, user_collectiviteDeleteArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_collectivite.
     * @param {user_collectiviteUpdateArgs} args - Arguments to update one User_collectivite.
     * @example
     * // Update one User_collectivite
     * const user_collectivite = await prisma.user_collectivite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_collectiviteUpdateArgs>(args: SelectSubset<T, user_collectiviteUpdateArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_collectivites.
     * @param {user_collectiviteDeleteManyArgs} args - Arguments to filter User_collectivites to delete.
     * @example
     * // Delete a few User_collectivites
     * const { count } = await prisma.user_collectivite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_collectiviteDeleteManyArgs>(args?: SelectSubset<T, user_collectiviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_collectivites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_collectiviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_collectivites
     * const user_collectivite = await prisma.user_collectivite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_collectiviteUpdateManyArgs>(args: SelectSubset<T, user_collectiviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_collectivites and returns the data updated in the database.
     * @param {user_collectiviteUpdateManyAndReturnArgs} args - Arguments to update many User_collectivites.
     * @example
     * // Update many User_collectivites
     * const user_collectivite = await prisma.user_collectivite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_collectivites and only return the `user_id`
     * const user_collectiviteWithUser_idOnly = await prisma.user_collectivite.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_collectiviteUpdateManyAndReturnArgs>(args: SelectSubset<T, user_collectiviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_collectivite.
     * @param {user_collectiviteUpsertArgs} args - Arguments to update or create a User_collectivite.
     * @example
     * // Update or create a User_collectivite
     * const user_collectivite = await prisma.user_collectivite.upsert({
     *   create: {
     *     // ... data to create a User_collectivite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_collectivite we want to update
     *   }
     * })
     */
    upsert<T extends user_collectiviteUpsertArgs>(args: SelectSubset<T, user_collectiviteUpsertArgs<ExtArgs>>): Prisma__user_collectiviteClient<$Result.GetResult<Prisma.$user_collectivitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_collectivites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_collectiviteCountArgs} args - Arguments to filter User_collectivites to count.
     * @example
     * // Count the number of User_collectivites
     * const count = await prisma.user_collectivite.count({
     *   where: {
     *     // ... the filter for the User_collectivites we want to count
     *   }
     * })
    **/
    count<T extends user_collectiviteCountArgs>(
      args?: Subset<T, user_collectiviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_collectiviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_collectivite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_collectiviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_collectiviteAggregateArgs>(args: Subset<T, User_collectiviteAggregateArgs>): Prisma.PrismaPromise<GetUser_collectiviteAggregateType<T>>

    /**
     * Group by User_collectivite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_collectiviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_collectiviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_collectiviteGroupByArgs['orderBy'] }
        : { orderBy?: user_collectiviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_collectiviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_collectiviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_collectivite model
   */
  readonly fields: user_collectiviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_collectivite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_collectiviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    collectivite<T extends collectiviteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectiviteDefaultArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_collectivite model
   */
  interface user_collectiviteFieldRefs {
    readonly user_id: FieldRef<"user_collectivite", 'String'>
    readonly collectivite_id: FieldRef<"user_collectivite", 'Int'>
    readonly verified: FieldRef<"user_collectivite", 'Boolean'>
    readonly created_at: FieldRef<"user_collectivite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_collectivite findUnique
   */
  export type user_collectiviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which user_collectivite to fetch.
     */
    where: user_collectiviteWhereUniqueInput
  }

  /**
   * user_collectivite findUniqueOrThrow
   */
  export type user_collectiviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which user_collectivite to fetch.
     */
    where: user_collectiviteWhereUniqueInput
  }

  /**
   * user_collectivite findFirst
   */
  export type user_collectiviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which user_collectivite to fetch.
     */
    where?: user_collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_collectivites to fetch.
     */
    orderBy?: user_collectiviteOrderByWithRelationInput | user_collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_collectivites.
     */
    cursor?: user_collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_collectivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_collectivites.
     */
    distinct?: User_collectiviteScalarFieldEnum | User_collectiviteScalarFieldEnum[]
  }

  /**
   * user_collectivite findFirstOrThrow
   */
  export type user_collectiviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which user_collectivite to fetch.
     */
    where?: user_collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_collectivites to fetch.
     */
    orderBy?: user_collectiviteOrderByWithRelationInput | user_collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_collectivites.
     */
    cursor?: user_collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_collectivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_collectivites.
     */
    distinct?: User_collectiviteScalarFieldEnum | User_collectiviteScalarFieldEnum[]
  }

  /**
   * user_collectivite findMany
   */
  export type user_collectiviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * Filter, which user_collectivites to fetch.
     */
    where?: user_collectiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_collectivites to fetch.
     */
    orderBy?: user_collectiviteOrderByWithRelationInput | user_collectiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_collectivites.
     */
    cursor?: user_collectiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_collectivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_collectivites.
     */
    skip?: number
    distinct?: User_collectiviteScalarFieldEnum | User_collectiviteScalarFieldEnum[]
  }

  /**
   * user_collectivite create
   */
  export type user_collectiviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * The data needed to create a user_collectivite.
     */
    data: XOR<user_collectiviteCreateInput, user_collectiviteUncheckedCreateInput>
  }

  /**
   * user_collectivite createMany
   */
  export type user_collectiviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_collectivites.
     */
    data: user_collectiviteCreateManyInput | user_collectiviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_collectivite createManyAndReturn
   */
  export type user_collectiviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * The data used to create many user_collectivites.
     */
    data: user_collectiviteCreateManyInput | user_collectiviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_collectivite update
   */
  export type user_collectiviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * The data needed to update a user_collectivite.
     */
    data: XOR<user_collectiviteUpdateInput, user_collectiviteUncheckedUpdateInput>
    /**
     * Choose, which user_collectivite to update.
     */
    where: user_collectiviteWhereUniqueInput
  }

  /**
   * user_collectivite updateMany
   */
  export type user_collectiviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_collectivites.
     */
    data: XOR<user_collectiviteUpdateManyMutationInput, user_collectiviteUncheckedUpdateManyInput>
    /**
     * Filter which user_collectivites to update
     */
    where?: user_collectiviteWhereInput
    /**
     * Limit how many user_collectivites to update.
     */
    limit?: number
  }

  /**
   * user_collectivite updateManyAndReturn
   */
  export type user_collectiviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * The data used to update user_collectivites.
     */
    data: XOR<user_collectiviteUpdateManyMutationInput, user_collectiviteUncheckedUpdateManyInput>
    /**
     * Filter which user_collectivites to update
     */
    where?: user_collectiviteWhereInput
    /**
     * Limit how many user_collectivites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_collectivite upsert
   */
  export type user_collectiviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * The filter to search for the user_collectivite to update in case it exists.
     */
    where: user_collectiviteWhereUniqueInput
    /**
     * In case the user_collectivite found by the `where` argument doesn't exist, create a new user_collectivite with this data.
     */
    create: XOR<user_collectiviteCreateInput, user_collectiviteUncheckedCreateInput>
    /**
     * In case the user_collectivite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_collectiviteUpdateInput, user_collectiviteUncheckedUpdateInput>
  }

  /**
   * user_collectivite delete
   */
  export type user_collectiviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
    /**
     * Filter which user_collectivite to delete.
     */
    where: user_collectiviteWhereUniqueInput
  }

  /**
   * user_collectivite deleteMany
   */
  export type user_collectiviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_collectivites to delete
     */
    where?: user_collectiviteWhereInput
    /**
     * Limit how many user_collectivites to delete.
     */
    limit?: number
  }

  /**
   * user_collectivite without action
   */
  export type user_collectiviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_collectivite
     */
    select?: user_collectiviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_collectivite
     */
    omit?: user_collectiviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_collectiviteInclude<ExtArgs> | null
  }


  /**
   * Model projet
   */

  export type AggregateProjet = {
    _count: ProjetCountAggregateOutputType | null
    _avg: ProjetAvgAggregateOutputType | null
    _sum: ProjetSumAggregateOutputType | null
    _min: ProjetMinAggregateOutputType | null
    _max: ProjetMaxAggregateOutputType | null
  }

  export type ProjetAvgAggregateOutputType = {
    id: number | null
    fiches_solutions_id: number | null
    fiches_diagnostic_id: number | null
    collectiviteId: number | null
    budget: number | null
  }

  export type ProjetSumAggregateOutputType = {
    id: number | null
    fiches_solutions_id: number[]
    fiches_diagnostic_id: number[]
    collectiviteId: number | null
    budget: number | null
  }

  export type ProjetMinAggregateOutputType = {
    id: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
    nom: string | null
    type_espace: string | null
    adresse: string | null
    niveau_maturite: string | null
    date_echeance: Date | null
    collectiviteId: number | null
    deleted_at: Date | null
    deleted_by: string | null
    is_public: boolean | null
    budget: number | null
    statut: $Enums.StatutProjet | null
    statut_updated_at: Date | null
  }

  export type ProjetMaxAggregateOutputType = {
    id: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
    nom: string | null
    type_espace: string | null
    adresse: string | null
    niveau_maturite: string | null
    date_echeance: Date | null
    collectiviteId: number | null
    deleted_at: Date | null
    deleted_by: string | null
    is_public: boolean | null
    budget: number | null
    statut: $Enums.StatutProjet | null
    statut_updated_at: Date | null
  }

  export type ProjetCountAggregateOutputType = {
    id: number
    created_by: number
    created_at: number
    updated_at: number
    nom: number
    type_espace: number
    adresse: number
    niveau_maturite: number
    adresse_info: number
    adresse_all_infos: number
    date_echeance: number
    fiches_solutions_id: number
    fiches_diagnostic_id: number
    collectiviteId: number
    recommandations_viewed_by: number
    deleted_at: number
    deleted_by: number
    is_public: number
    budget: number
    sourcing_rex: number
    statut: number
    statut_updated_at: number
    _all: number
  }


  export type ProjetAvgAggregateInputType = {
    id?: true
    fiches_solutions_id?: true
    fiches_diagnostic_id?: true
    collectiviteId?: true
    budget?: true
  }

  export type ProjetSumAggregateInputType = {
    id?: true
    fiches_solutions_id?: true
    fiches_diagnostic_id?: true
    collectiviteId?: true
    budget?: true
  }

  export type ProjetMinAggregateInputType = {
    id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    nom?: true
    type_espace?: true
    adresse?: true
    niveau_maturite?: true
    date_echeance?: true
    collectiviteId?: true
    deleted_at?: true
    deleted_by?: true
    is_public?: true
    budget?: true
    statut?: true
    statut_updated_at?: true
  }

  export type ProjetMaxAggregateInputType = {
    id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    nom?: true
    type_espace?: true
    adresse?: true
    niveau_maturite?: true
    date_echeance?: true
    collectiviteId?: true
    deleted_at?: true
    deleted_by?: true
    is_public?: true
    budget?: true
    statut?: true
    statut_updated_at?: true
  }

  export type ProjetCountAggregateInputType = {
    id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    nom?: true
    type_espace?: true
    adresse?: true
    niveau_maturite?: true
    adresse_info?: true
    adresse_all_infos?: true
    date_echeance?: true
    fiches_solutions_id?: true
    fiches_diagnostic_id?: true
    collectiviteId?: true
    recommandations_viewed_by?: true
    deleted_at?: true
    deleted_by?: true
    is_public?: true
    budget?: true
    sourcing_rex?: true
    statut?: true
    statut_updated_at?: true
    _all?: true
  }

  export type ProjetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet to aggregate.
     */
    where?: projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projets
    **/
    _count?: true | ProjetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetMaxAggregateInputType
  }

  export type GetProjetAggregateType<T extends ProjetAggregateArgs> = {
        [P in keyof T & keyof AggregateProjet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjet[P]>
      : GetScalarType<T[P], AggregateProjet[P]>
  }




  export type projetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetWhereInput
    orderBy?: projetOrderByWithAggregationInput | projetOrderByWithAggregationInput[]
    by: ProjetScalarFieldEnum[] | ProjetScalarFieldEnum
    having?: projetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetCountAggregateInputType | true
    _avg?: ProjetAvgAggregateInputType
    _sum?: ProjetSumAggregateInputType
    _min?: ProjetMinAggregateInputType
    _max?: ProjetMaxAggregateInputType
  }

  export type ProjetGroupByOutputType = {
    id: number
    created_by: string
    created_at: Date
    updated_at: Date | null
    nom: string
    type_espace: string | null
    adresse: string | null
    niveau_maturite: string | null
    adresse_info: JsonValue | null
    adresse_all_infos: JsonValue | null
    date_echeance: Date | null
    fiches_solutions_id: number[]
    fiches_diagnostic_id: number[]
    collectiviteId: number
    recommandations_viewed_by: string[]
    deleted_at: Date | null
    deleted_by: string | null
    is_public: boolean | null
    budget: number | null
    sourcing_rex: JsonValue | null
    statut: $Enums.StatutProjet | null
    statut_updated_at: Date | null
    _count: ProjetCountAggregateOutputType | null
    _avg: ProjetAvgAggregateOutputType | null
    _sum: ProjetSumAggregateOutputType | null
    _min: ProjetMinAggregateOutputType | null
    _max: ProjetMaxAggregateOutputType | null
  }

  type GetProjetGroupByPayload<T extends projetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetGroupByOutputType[P]>
        }
      >
    >


  export type projetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    nom?: boolean
    type_espace?: boolean
    adresse?: boolean
    niveau_maturite?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    date_echeance?: boolean
    fiches_solutions_id?: boolean
    fiches_diagnostic_id?: boolean
    collectiviteId?: boolean
    recommandations_viewed_by?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_public?: boolean
    budget?: boolean
    sourcing_rex?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    estimations?: boolean | projet$estimationsArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
    deleter?: boolean | projet$deleterArgs<ExtArgs>
    users?: boolean | projet$usersArgs<ExtArgs>
    sourcing_user_projets?: boolean | projet$sourcing_user_projetsArgs<ExtArgs>
    fiches?: boolean | projet$fichesArgs<ExtArgs>
    diagnostic_simulations?: boolean | projet$diagnostic_simulationsArgs<ExtArgs>
    _count?: boolean | ProjetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet"]>

  export type projetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    nom?: boolean
    type_espace?: boolean
    adresse?: boolean
    niveau_maturite?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    date_echeance?: boolean
    fiches_solutions_id?: boolean
    fiches_diagnostic_id?: boolean
    collectiviteId?: boolean
    recommandations_viewed_by?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_public?: boolean
    budget?: boolean
    sourcing_rex?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
    deleter?: boolean | projet$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["projet"]>

  export type projetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    nom?: boolean
    type_espace?: boolean
    adresse?: boolean
    niveau_maturite?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    date_echeance?: boolean
    fiches_solutions_id?: boolean
    fiches_diagnostic_id?: boolean
    collectiviteId?: boolean
    recommandations_viewed_by?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_public?: boolean
    budget?: boolean
    sourcing_rex?: boolean
    statut?: boolean
    statut_updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
    deleter?: boolean | projet$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["projet"]>

  export type projetSelectScalar = {
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    nom?: boolean
    type_espace?: boolean
    adresse?: boolean
    niveau_maturite?: boolean
    adresse_info?: boolean
    adresse_all_infos?: boolean
    date_echeance?: boolean
    fiches_solutions_id?: boolean
    fiches_diagnostic_id?: boolean
    collectiviteId?: boolean
    recommandations_viewed_by?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_public?: boolean
    budget?: boolean
    sourcing_rex?: boolean
    statut?: boolean
    statut_updated_at?: boolean
  }

  export type projetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_by" | "created_at" | "updated_at" | "nom" | "type_espace" | "adresse" | "niveau_maturite" | "adresse_info" | "adresse_all_infos" | "date_echeance" | "fiches_solutions_id" | "fiches_diagnostic_id" | "collectiviteId" | "recommandations_viewed_by" | "deleted_at" | "deleted_by" | "is_public" | "budget" | "sourcing_rex" | "statut" | "statut_updated_at", ExtArgs["result"]["projet"]>
  export type projetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    estimations?: boolean | projet$estimationsArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
    deleter?: boolean | projet$deleterArgs<ExtArgs>
    users?: boolean | projet$usersArgs<ExtArgs>
    sourcing_user_projets?: boolean | projet$sourcing_user_projetsArgs<ExtArgs>
    fiches?: boolean | projet$fichesArgs<ExtArgs>
    diagnostic_simulations?: boolean | projet$diagnostic_simulationsArgs<ExtArgs>
    _count?: boolean | ProjetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
    deleter?: boolean | projet$deleterArgs<ExtArgs>
  }
  export type projetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    collectivite?: boolean | collectiviteDefaultArgs<ExtArgs>
    deleter?: boolean | projet$deleterArgs<ExtArgs>
  }

  export type $projetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projet"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      estimations: Prisma.$estimationPayload<ExtArgs>[]
      collectivite: Prisma.$collectivitePayload<ExtArgs>
      deleter: Prisma.$UserPayload<ExtArgs> | null
      users: Prisma.$user_projetPayload<ExtArgs>[]
      sourcing_user_projets: Prisma.$projet_sourcing_contactPayload<ExtArgs>[]
      fiches: Prisma.$projet_fichePayload<ExtArgs>[]
      diagnostic_simulations: Prisma.$diagnostic_simulationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_by: string
      created_at: Date
      updated_at: Date | null
      nom: string
      type_espace: string | null
      adresse: string | null
      niveau_maturite: string | null
      adresse_info: Prisma.JsonValue | null
      adresse_all_infos: Prisma.JsonValue | null
      date_echeance: Date | null
      fiches_solutions_id: number[]
      fiches_diagnostic_id: number[]
      collectiviteId: number
      recommandations_viewed_by: string[]
      deleted_at: Date | null
      deleted_by: string | null
      is_public: boolean | null
      budget: number | null
      sourcing_rex: Prisma.JsonValue | null
      statut: $Enums.StatutProjet | null
      statut_updated_at: Date | null
    }, ExtArgs["result"]["projet"]>
    composites: {}
  }

  type projetGetPayload<S extends boolean | null | undefined | projetDefaultArgs> = $Result.GetResult<Prisma.$projetPayload, S>

  type projetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjetCountAggregateInputType | true
    }

  export interface projetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projet'], meta: { name: 'projet' } }
    /**
     * Find zero or one Projet that matches the filter.
     * @param {projetFindUniqueArgs} args - Arguments to find a Projet
     * @example
     * // Get one Projet
     * const projet = await prisma.projet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetFindUniqueArgs>(args: SelectSubset<T, projetFindUniqueArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projetFindUniqueOrThrowArgs} args - Arguments to find a Projet
     * @example
     * // Get one Projet
     * const projet = await prisma.projet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetFindUniqueOrThrowArgs>(args: SelectSubset<T, projetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetFindFirstArgs} args - Arguments to find a Projet
     * @example
     * // Get one Projet
     * const projet = await prisma.projet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetFindFirstArgs>(args?: SelectSubset<T, projetFindFirstArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetFindFirstOrThrowArgs} args - Arguments to find a Projet
     * @example
     * // Get one Projet
     * const projet = await prisma.projet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetFindFirstOrThrowArgs>(args?: SelectSubset<T, projetFindFirstOrThrowArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projets
     * const projets = await prisma.projet.findMany()
     * 
     * // Get first 10 Projets
     * const projets = await prisma.projet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projetWithIdOnly = await prisma.projet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projetFindManyArgs>(args?: SelectSubset<T, projetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projet.
     * @param {projetCreateArgs} args - Arguments to create a Projet.
     * @example
     * // Create one Projet
     * const Projet = await prisma.projet.create({
     *   data: {
     *     // ... data to create a Projet
     *   }
     * })
     * 
     */
    create<T extends projetCreateArgs>(args: SelectSubset<T, projetCreateArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projets.
     * @param {projetCreateManyArgs} args - Arguments to create many Projets.
     * @example
     * // Create many Projets
     * const projet = await prisma.projet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projetCreateManyArgs>(args?: SelectSubset<T, projetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projets and returns the data saved in the database.
     * @param {projetCreateManyAndReturnArgs} args - Arguments to create many Projets.
     * @example
     * // Create many Projets
     * const projet = await prisma.projet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projets and only return the `id`
     * const projetWithIdOnly = await prisma.projet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projetCreateManyAndReturnArgs>(args?: SelectSubset<T, projetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Projet.
     * @param {projetDeleteArgs} args - Arguments to delete one Projet.
     * @example
     * // Delete one Projet
     * const Projet = await prisma.projet.delete({
     *   where: {
     *     // ... filter to delete one Projet
     *   }
     * })
     * 
     */
    delete<T extends projetDeleteArgs>(args: SelectSubset<T, projetDeleteArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projet.
     * @param {projetUpdateArgs} args - Arguments to update one Projet.
     * @example
     * // Update one Projet
     * const projet = await prisma.projet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projetUpdateArgs>(args: SelectSubset<T, projetUpdateArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projets.
     * @param {projetDeleteManyArgs} args - Arguments to filter Projets to delete.
     * @example
     * // Delete a few Projets
     * const { count } = await prisma.projet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projetDeleteManyArgs>(args?: SelectSubset<T, projetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projets
     * const projet = await prisma.projet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projetUpdateManyArgs>(args: SelectSubset<T, projetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projets and returns the data updated in the database.
     * @param {projetUpdateManyAndReturnArgs} args - Arguments to update many Projets.
     * @example
     * // Update many Projets
     * const projet = await prisma.projet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projets and only return the `id`
     * const projetWithIdOnly = await prisma.projet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projetUpdateManyAndReturnArgs>(args: SelectSubset<T, projetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Projet.
     * @param {projetUpsertArgs} args - Arguments to update or create a Projet.
     * @example
     * // Update or create a Projet
     * const projet = await prisma.projet.upsert({
     *   create: {
     *     // ... data to create a Projet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projet we want to update
     *   }
     * })
     */
    upsert<T extends projetUpsertArgs>(args: SelectSubset<T, projetUpsertArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetCountArgs} args - Arguments to filter Projets to count.
     * @example
     * // Count the number of Projets
     * const count = await prisma.projet.count({
     *   where: {
     *     // ... the filter for the Projets we want to count
     *   }
     * })
    **/
    count<T extends projetCountArgs>(
      args?: Subset<T, projetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetAggregateArgs>(args: Subset<T, ProjetAggregateArgs>): Prisma.PrismaPromise<GetProjetAggregateType<T>>

    /**
     * Group by Projet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetGroupByArgs['orderBy'] }
        : { orderBy?: projetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projet model
   */
  readonly fields: projetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estimations<T extends projet$estimationsArgs<ExtArgs> = {}>(args?: Subset<T, projet$estimationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collectivite<T extends collectiviteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectiviteDefaultArgs<ExtArgs>>): Prisma__collectiviteClient<$Result.GetResult<Prisma.$collectivitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deleter<T extends projet$deleterArgs<ExtArgs> = {}>(args?: Subset<T, projet$deleterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends projet$usersArgs<ExtArgs> = {}>(args?: Subset<T, projet$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourcing_user_projets<T extends projet$sourcing_user_projetsArgs<ExtArgs> = {}>(args?: Subset<T, projet$sourcing_user_projetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fiches<T extends projet$fichesArgs<ExtArgs> = {}>(args?: Subset<T, projet$fichesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diagnostic_simulations<T extends projet$diagnostic_simulationsArgs<ExtArgs> = {}>(args?: Subset<T, projet$diagnostic_simulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projet model
   */
  interface projetFieldRefs {
    readonly id: FieldRef<"projet", 'Int'>
    readonly created_by: FieldRef<"projet", 'String'>
    readonly created_at: FieldRef<"projet", 'DateTime'>
    readonly updated_at: FieldRef<"projet", 'DateTime'>
    readonly nom: FieldRef<"projet", 'String'>
    readonly type_espace: FieldRef<"projet", 'String'>
    readonly adresse: FieldRef<"projet", 'String'>
    readonly niveau_maturite: FieldRef<"projet", 'String'>
    readonly adresse_info: FieldRef<"projet", 'Json'>
    readonly adresse_all_infos: FieldRef<"projet", 'Json'>
    readonly date_echeance: FieldRef<"projet", 'DateTime'>
    readonly fiches_solutions_id: FieldRef<"projet", 'Int[]'>
    readonly fiches_diagnostic_id: FieldRef<"projet", 'Int[]'>
    readonly collectiviteId: FieldRef<"projet", 'Int'>
    readonly recommandations_viewed_by: FieldRef<"projet", 'String[]'>
    readonly deleted_at: FieldRef<"projet", 'DateTime'>
    readonly deleted_by: FieldRef<"projet", 'String'>
    readonly is_public: FieldRef<"projet", 'Boolean'>
    readonly budget: FieldRef<"projet", 'Int'>
    readonly sourcing_rex: FieldRef<"projet", 'Json'>
    readonly statut: FieldRef<"projet", 'StatutProjet'>
    readonly statut_updated_at: FieldRef<"projet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * projet findUnique
   */
  export type projetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * Filter, which projet to fetch.
     */
    where: projetWhereUniqueInput
  }

  /**
   * projet findUniqueOrThrow
   */
  export type projetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * Filter, which projet to fetch.
     */
    where: projetWhereUniqueInput
  }

  /**
   * projet findFirst
   */
  export type projetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * Filter, which projet to fetch.
     */
    where?: projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projets.
     */
    cursor?: projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projets.
     */
    distinct?: ProjetScalarFieldEnum | ProjetScalarFieldEnum[]
  }

  /**
   * projet findFirstOrThrow
   */
  export type projetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * Filter, which projet to fetch.
     */
    where?: projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projets.
     */
    cursor?: projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projets.
     */
    distinct?: ProjetScalarFieldEnum | ProjetScalarFieldEnum[]
  }

  /**
   * projet findMany
   */
  export type projetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * Filter, which projets to fetch.
     */
    where?: projetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projets to fetch.
     */
    orderBy?: projetOrderByWithRelationInput | projetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projets.
     */
    cursor?: projetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projets.
     */
    skip?: number
    distinct?: ProjetScalarFieldEnum | ProjetScalarFieldEnum[]
  }

  /**
   * projet create
   */
  export type projetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * The data needed to create a projet.
     */
    data: XOR<projetCreateInput, projetUncheckedCreateInput>
  }

  /**
   * projet createMany
   */
  export type projetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projets.
     */
    data: projetCreateManyInput | projetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projet createManyAndReturn
   */
  export type projetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * The data used to create many projets.
     */
    data: projetCreateManyInput | projetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projet update
   */
  export type projetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * The data needed to update a projet.
     */
    data: XOR<projetUpdateInput, projetUncheckedUpdateInput>
    /**
     * Choose, which projet to update.
     */
    where: projetWhereUniqueInput
  }

  /**
   * projet updateMany
   */
  export type projetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projets.
     */
    data: XOR<projetUpdateManyMutationInput, projetUncheckedUpdateManyInput>
    /**
     * Filter which projets to update
     */
    where?: projetWhereInput
    /**
     * Limit how many projets to update.
     */
    limit?: number
  }

  /**
   * projet updateManyAndReturn
   */
  export type projetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * The data used to update projets.
     */
    data: XOR<projetUpdateManyMutationInput, projetUncheckedUpdateManyInput>
    /**
     * Filter which projets to update
     */
    where?: projetWhereInput
    /**
     * Limit how many projets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projet upsert
   */
  export type projetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * The filter to search for the projet to update in case it exists.
     */
    where: projetWhereUniqueInput
    /**
     * In case the projet found by the `where` argument doesn't exist, create a new projet with this data.
     */
    create: XOR<projetCreateInput, projetUncheckedCreateInput>
    /**
     * In case the projet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetUpdateInput, projetUncheckedUpdateInput>
  }

  /**
   * projet delete
   */
  export type projetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
    /**
     * Filter which projet to delete.
     */
    where: projetWhereUniqueInput
  }

  /**
   * projet deleteMany
   */
  export type projetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projets to delete
     */
    where?: projetWhereInput
    /**
     * Limit how many projets to delete.
     */
    limit?: number
  }

  /**
   * projet.estimations
   */
  export type projet$estimationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    where?: estimationWhereInput
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    cursor?: estimationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstimationScalarFieldEnum | EstimationScalarFieldEnum[]
  }

  /**
   * projet.deleter
   */
  export type projet$deleterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * projet.users
   */
  export type projet$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_projet
     */
    select?: user_projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_projet
     */
    omit?: user_projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_projetInclude<ExtArgs> | null
    where?: user_projetWhereInput
    orderBy?: user_projetOrderByWithRelationInput | user_projetOrderByWithRelationInput[]
    cursor?: user_projetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_projetScalarFieldEnum | User_projetScalarFieldEnum[]
  }

  /**
   * projet.sourcing_user_projets
   */
  export type projet$sourcing_user_projetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    where?: projet_sourcing_contactWhereInput
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    cursor?: projet_sourcing_contactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_sourcing_contactScalarFieldEnum | Projet_sourcing_contactScalarFieldEnum[]
  }

  /**
   * projet.fiches
   */
  export type projet$fichesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    where?: projet_ficheWhereInput
    orderBy?: projet_ficheOrderByWithRelationInput | projet_ficheOrderByWithRelationInput[]
    cursor?: projet_ficheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Projet_ficheScalarFieldEnum | Projet_ficheScalarFieldEnum[]
  }

  /**
   * projet.diagnostic_simulations
   */
  export type projet$diagnostic_simulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    where?: diagnostic_simulationWhereInput
    orderBy?: diagnostic_simulationOrderByWithRelationInput | diagnostic_simulationOrderByWithRelationInput[]
    cursor?: diagnostic_simulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Diagnostic_simulationScalarFieldEnum | Diagnostic_simulationScalarFieldEnum[]
  }

  /**
   * projet without action
   */
  export type projetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet
     */
    select?: projetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet
     */
    omit?: projetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetInclude<ExtArgs> | null
  }


  /**
   * Model projet_fiche
   */

  export type AggregateProjet_fiche = {
    _count: Projet_ficheCountAggregateOutputType | null
    _avg: Projet_ficheAvgAggregateOutputType | null
    _sum: Projet_ficheSumAggregateOutputType | null
    _min: Projet_ficheMinAggregateOutputType | null
    _max: Projet_ficheMaxAggregateOutputType | null
  }

  export type Projet_ficheAvgAggregateOutputType = {
    id: number | null
    projet_id: number | null
    fiche_id: number | null
  }

  export type Projet_ficheSumAggregateOutputType = {
    id: number | null
    projet_id: number | null
    fiche_id: number | null
  }

  export type Projet_ficheMinAggregateOutputType = {
    id: number | null
    projet_id: number | null
    fiche_id: number | null
    type: $Enums.FicheType | null
    created_at: Date | null
    user_id: string | null
  }

  export type Projet_ficheMaxAggregateOutputType = {
    id: number | null
    projet_id: number | null
    fiche_id: number | null
    type: $Enums.FicheType | null
    created_at: Date | null
    user_id: string | null
  }

  export type Projet_ficheCountAggregateOutputType = {
    id: number
    projet_id: number
    fiche_id: number
    type: number
    created_at: number
    user_id: number
    _all: number
  }


  export type Projet_ficheAvgAggregateInputType = {
    id?: true
    projet_id?: true
    fiche_id?: true
  }

  export type Projet_ficheSumAggregateInputType = {
    id?: true
    projet_id?: true
    fiche_id?: true
  }

  export type Projet_ficheMinAggregateInputType = {
    id?: true
    projet_id?: true
    fiche_id?: true
    type?: true
    created_at?: true
    user_id?: true
  }

  export type Projet_ficheMaxAggregateInputType = {
    id?: true
    projet_id?: true
    fiche_id?: true
    type?: true
    created_at?: true
    user_id?: true
  }

  export type Projet_ficheCountAggregateInputType = {
    id?: true
    projet_id?: true
    fiche_id?: true
    type?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type Projet_ficheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_fiche to aggregate.
     */
    where?: projet_ficheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_fiches to fetch.
     */
    orderBy?: projet_ficheOrderByWithRelationInput | projet_ficheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projet_ficheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_fiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_fiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projet_fiches
    **/
    _count?: true | Projet_ficheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Projet_ficheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Projet_ficheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Projet_ficheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Projet_ficheMaxAggregateInputType
  }

  export type GetProjet_ficheAggregateType<T extends Projet_ficheAggregateArgs> = {
        [P in keyof T & keyof AggregateProjet_fiche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjet_fiche[P]>
      : GetScalarType<T[P], AggregateProjet_fiche[P]>
  }




  export type projet_ficheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_ficheWhereInput
    orderBy?: projet_ficheOrderByWithAggregationInput | projet_ficheOrderByWithAggregationInput[]
    by: Projet_ficheScalarFieldEnum[] | Projet_ficheScalarFieldEnum
    having?: projet_ficheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Projet_ficheCountAggregateInputType | true
    _avg?: Projet_ficheAvgAggregateInputType
    _sum?: Projet_ficheSumAggregateInputType
    _min?: Projet_ficheMinAggregateInputType
    _max?: Projet_ficheMaxAggregateInputType
  }

  export type Projet_ficheGroupByOutputType = {
    id: number
    projet_id: number
    fiche_id: number
    type: $Enums.FicheType
    created_at: Date
    user_id: string
    _count: Projet_ficheCountAggregateOutputType | null
    _avg: Projet_ficheAvgAggregateOutputType | null
    _sum: Projet_ficheSumAggregateOutputType | null
    _min: Projet_ficheMinAggregateOutputType | null
    _max: Projet_ficheMaxAggregateOutputType | null
  }

  type GetProjet_ficheGroupByPayload<T extends projet_ficheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Projet_ficheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Projet_ficheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Projet_ficheGroupByOutputType[P]>
            : GetScalarType<T[P], Projet_ficheGroupByOutputType[P]>
        }
      >
    >


  export type projet_ficheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projet_id?: boolean
    fiche_id?: boolean
    type?: boolean
    created_at?: boolean
    user_id?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_fiche"]>

  export type projet_ficheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projet_id?: boolean
    fiche_id?: boolean
    type?: boolean
    created_at?: boolean
    user_id?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_fiche"]>

  export type projet_ficheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projet_id?: boolean
    fiche_id?: boolean
    type?: boolean
    created_at?: boolean
    user_id?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_fiche"]>

  export type projet_ficheSelectScalar = {
    id?: boolean
    projet_id?: boolean
    fiche_id?: boolean
    type?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type projet_ficheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projet_id" | "fiche_id" | "type" | "created_at" | "user_id", ExtArgs["result"]["projet_fiche"]>
  export type projet_ficheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type projet_ficheIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type projet_ficheIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $projet_fichePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projet_fiche"
    objects: {
      projet: Prisma.$projetPayload<ExtArgs>
      created_by: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projet_id: number
      fiche_id: number
      type: $Enums.FicheType
      created_at: Date
      user_id: string
    }, ExtArgs["result"]["projet_fiche"]>
    composites: {}
  }

  type projet_ficheGetPayload<S extends boolean | null | undefined | projet_ficheDefaultArgs> = $Result.GetResult<Prisma.$projet_fichePayload, S>

  type projet_ficheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projet_ficheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Projet_ficheCountAggregateInputType | true
    }

  export interface projet_ficheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projet_fiche'], meta: { name: 'projet_fiche' } }
    /**
     * Find zero or one Projet_fiche that matches the filter.
     * @param {projet_ficheFindUniqueArgs} args - Arguments to find a Projet_fiche
     * @example
     * // Get one Projet_fiche
     * const projet_fiche = await prisma.projet_fiche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projet_ficheFindUniqueArgs>(args: SelectSubset<T, projet_ficheFindUniqueArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projet_fiche that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projet_ficheFindUniqueOrThrowArgs} args - Arguments to find a Projet_fiche
     * @example
     * // Get one Projet_fiche
     * const projet_fiche = await prisma.projet_fiche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projet_ficheFindUniqueOrThrowArgs>(args: SelectSubset<T, projet_ficheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projet_fiche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_ficheFindFirstArgs} args - Arguments to find a Projet_fiche
     * @example
     * // Get one Projet_fiche
     * const projet_fiche = await prisma.projet_fiche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projet_ficheFindFirstArgs>(args?: SelectSubset<T, projet_ficheFindFirstArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projet_fiche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_ficheFindFirstOrThrowArgs} args - Arguments to find a Projet_fiche
     * @example
     * // Get one Projet_fiche
     * const projet_fiche = await prisma.projet_fiche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projet_ficheFindFirstOrThrowArgs>(args?: SelectSubset<T, projet_ficheFindFirstOrThrowArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projet_fiches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_ficheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projet_fiches
     * const projet_fiches = await prisma.projet_fiche.findMany()
     * 
     * // Get first 10 Projet_fiches
     * const projet_fiches = await prisma.projet_fiche.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projet_ficheWithIdOnly = await prisma.projet_fiche.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projet_ficheFindManyArgs>(args?: SelectSubset<T, projet_ficheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projet_fiche.
     * @param {projet_ficheCreateArgs} args - Arguments to create a Projet_fiche.
     * @example
     * // Create one Projet_fiche
     * const Projet_fiche = await prisma.projet_fiche.create({
     *   data: {
     *     // ... data to create a Projet_fiche
     *   }
     * })
     * 
     */
    create<T extends projet_ficheCreateArgs>(args: SelectSubset<T, projet_ficheCreateArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projet_fiches.
     * @param {projet_ficheCreateManyArgs} args - Arguments to create many Projet_fiches.
     * @example
     * // Create many Projet_fiches
     * const projet_fiche = await prisma.projet_fiche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projet_ficheCreateManyArgs>(args?: SelectSubset<T, projet_ficheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projet_fiches and returns the data saved in the database.
     * @param {projet_ficheCreateManyAndReturnArgs} args - Arguments to create many Projet_fiches.
     * @example
     * // Create many Projet_fiches
     * const projet_fiche = await prisma.projet_fiche.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projet_fiches and only return the `id`
     * const projet_ficheWithIdOnly = await prisma.projet_fiche.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projet_ficheCreateManyAndReturnArgs>(args?: SelectSubset<T, projet_ficheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Projet_fiche.
     * @param {projet_ficheDeleteArgs} args - Arguments to delete one Projet_fiche.
     * @example
     * // Delete one Projet_fiche
     * const Projet_fiche = await prisma.projet_fiche.delete({
     *   where: {
     *     // ... filter to delete one Projet_fiche
     *   }
     * })
     * 
     */
    delete<T extends projet_ficheDeleteArgs>(args: SelectSubset<T, projet_ficheDeleteArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projet_fiche.
     * @param {projet_ficheUpdateArgs} args - Arguments to update one Projet_fiche.
     * @example
     * // Update one Projet_fiche
     * const projet_fiche = await prisma.projet_fiche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projet_ficheUpdateArgs>(args: SelectSubset<T, projet_ficheUpdateArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projet_fiches.
     * @param {projet_ficheDeleteManyArgs} args - Arguments to filter Projet_fiches to delete.
     * @example
     * // Delete a few Projet_fiches
     * const { count } = await prisma.projet_fiche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projet_ficheDeleteManyArgs>(args?: SelectSubset<T, projet_ficheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projet_fiches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_ficheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projet_fiches
     * const projet_fiche = await prisma.projet_fiche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projet_ficheUpdateManyArgs>(args: SelectSubset<T, projet_ficheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projet_fiches and returns the data updated in the database.
     * @param {projet_ficheUpdateManyAndReturnArgs} args - Arguments to update many Projet_fiches.
     * @example
     * // Update many Projet_fiches
     * const projet_fiche = await prisma.projet_fiche.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projet_fiches and only return the `id`
     * const projet_ficheWithIdOnly = await prisma.projet_fiche.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projet_ficheUpdateManyAndReturnArgs>(args: SelectSubset<T, projet_ficheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Projet_fiche.
     * @param {projet_ficheUpsertArgs} args - Arguments to update or create a Projet_fiche.
     * @example
     * // Update or create a Projet_fiche
     * const projet_fiche = await prisma.projet_fiche.upsert({
     *   create: {
     *     // ... data to create a Projet_fiche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projet_fiche we want to update
     *   }
     * })
     */
    upsert<T extends projet_ficheUpsertArgs>(args: SelectSubset<T, projet_ficheUpsertArgs<ExtArgs>>): Prisma__projet_ficheClient<$Result.GetResult<Prisma.$projet_fichePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projet_fiches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_ficheCountArgs} args - Arguments to filter Projet_fiches to count.
     * @example
     * // Count the number of Projet_fiches
     * const count = await prisma.projet_fiche.count({
     *   where: {
     *     // ... the filter for the Projet_fiches we want to count
     *   }
     * })
    **/
    count<T extends projet_ficheCountArgs>(
      args?: Subset<T, projet_ficheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Projet_ficheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projet_fiche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Projet_ficheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Projet_ficheAggregateArgs>(args: Subset<T, Projet_ficheAggregateArgs>): Prisma.PrismaPromise<GetProjet_ficheAggregateType<T>>

    /**
     * Group by Projet_fiche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_ficheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projet_ficheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projet_ficheGroupByArgs['orderBy'] }
        : { orderBy?: projet_ficheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projet_ficheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjet_ficheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projet_fiche model
   */
  readonly fields: projet_ficheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projet_fiche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projet_ficheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projet<T extends projetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetDefaultArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projet_fiche model
   */
  interface projet_ficheFieldRefs {
    readonly id: FieldRef<"projet_fiche", 'Int'>
    readonly projet_id: FieldRef<"projet_fiche", 'Int'>
    readonly fiche_id: FieldRef<"projet_fiche", 'Int'>
    readonly type: FieldRef<"projet_fiche", 'FicheType'>
    readonly created_at: FieldRef<"projet_fiche", 'DateTime'>
    readonly user_id: FieldRef<"projet_fiche", 'String'>
  }
    

  // Custom InputTypes
  /**
   * projet_fiche findUnique
   */
  export type projet_ficheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * Filter, which projet_fiche to fetch.
     */
    where: projet_ficheWhereUniqueInput
  }

  /**
   * projet_fiche findUniqueOrThrow
   */
  export type projet_ficheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * Filter, which projet_fiche to fetch.
     */
    where: projet_ficheWhereUniqueInput
  }

  /**
   * projet_fiche findFirst
   */
  export type projet_ficheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * Filter, which projet_fiche to fetch.
     */
    where?: projet_ficheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_fiches to fetch.
     */
    orderBy?: projet_ficheOrderByWithRelationInput | projet_ficheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_fiches.
     */
    cursor?: projet_ficheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_fiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_fiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_fiches.
     */
    distinct?: Projet_ficheScalarFieldEnum | Projet_ficheScalarFieldEnum[]
  }

  /**
   * projet_fiche findFirstOrThrow
   */
  export type projet_ficheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * Filter, which projet_fiche to fetch.
     */
    where?: projet_ficheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_fiches to fetch.
     */
    orderBy?: projet_ficheOrderByWithRelationInput | projet_ficheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_fiches.
     */
    cursor?: projet_ficheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_fiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_fiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_fiches.
     */
    distinct?: Projet_ficheScalarFieldEnum | Projet_ficheScalarFieldEnum[]
  }

  /**
   * projet_fiche findMany
   */
  export type projet_ficheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * Filter, which projet_fiches to fetch.
     */
    where?: projet_ficheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_fiches to fetch.
     */
    orderBy?: projet_ficheOrderByWithRelationInput | projet_ficheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projet_fiches.
     */
    cursor?: projet_ficheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_fiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_fiches.
     */
    skip?: number
    distinct?: Projet_ficheScalarFieldEnum | Projet_ficheScalarFieldEnum[]
  }

  /**
   * projet_fiche create
   */
  export type projet_ficheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * The data needed to create a projet_fiche.
     */
    data: XOR<projet_ficheCreateInput, projet_ficheUncheckedCreateInput>
  }

  /**
   * projet_fiche createMany
   */
  export type projet_ficheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projet_fiches.
     */
    data: projet_ficheCreateManyInput | projet_ficheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projet_fiche createManyAndReturn
   */
  export type projet_ficheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * The data used to create many projet_fiches.
     */
    data: projet_ficheCreateManyInput | projet_ficheCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projet_fiche update
   */
  export type projet_ficheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * The data needed to update a projet_fiche.
     */
    data: XOR<projet_ficheUpdateInput, projet_ficheUncheckedUpdateInput>
    /**
     * Choose, which projet_fiche to update.
     */
    where: projet_ficheWhereUniqueInput
  }

  /**
   * projet_fiche updateMany
   */
  export type projet_ficheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projet_fiches.
     */
    data: XOR<projet_ficheUpdateManyMutationInput, projet_ficheUncheckedUpdateManyInput>
    /**
     * Filter which projet_fiches to update
     */
    where?: projet_ficheWhereInput
    /**
     * Limit how many projet_fiches to update.
     */
    limit?: number
  }

  /**
   * projet_fiche updateManyAndReturn
   */
  export type projet_ficheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * The data used to update projet_fiches.
     */
    data: XOR<projet_ficheUpdateManyMutationInput, projet_ficheUncheckedUpdateManyInput>
    /**
     * Filter which projet_fiches to update
     */
    where?: projet_ficheWhereInput
    /**
     * Limit how many projet_fiches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projet_fiche upsert
   */
  export type projet_ficheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * The filter to search for the projet_fiche to update in case it exists.
     */
    where: projet_ficheWhereUniqueInput
    /**
     * In case the projet_fiche found by the `where` argument doesn't exist, create a new projet_fiche with this data.
     */
    create: XOR<projet_ficheCreateInput, projet_ficheUncheckedCreateInput>
    /**
     * In case the projet_fiche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projet_ficheUpdateInput, projet_ficheUncheckedUpdateInput>
  }

  /**
   * projet_fiche delete
   */
  export type projet_ficheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
    /**
     * Filter which projet_fiche to delete.
     */
    where: projet_ficheWhereUniqueInput
  }

  /**
   * projet_fiche deleteMany
   */
  export type projet_ficheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_fiches to delete
     */
    where?: projet_ficheWhereInput
    /**
     * Limit how many projet_fiches to delete.
     */
    limit?: number
  }

  /**
   * projet_fiche without action
   */
  export type projet_ficheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_fiche
     */
    select?: projet_ficheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_fiche
     */
    omit?: projet_ficheOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_ficheInclude<ExtArgs> | null
  }


  /**
   * Model projet_sourcing_contact
   */

  export type AggregateProjet_sourcing_contact = {
    _count: Projet_sourcing_contactCountAggregateOutputType | null
    _avg: Projet_sourcing_contactAvgAggregateOutputType | null
    _sum: Projet_sourcing_contactSumAggregateOutputType | null
    _min: Projet_sourcing_contactMinAggregateOutputType | null
    _max: Projet_sourcing_contactMaxAggregateOutputType | null
  }

  export type Projet_sourcing_contactAvgAggregateOutputType = {
    id: number | null
    projet_id: number | null
    sourced_user_projet_id: number | null
  }

  export type Projet_sourcing_contactSumAggregateOutputType = {
    id: number | null
    projet_id: number | null
    sourced_user_projet_id: number | null
  }

  export type Projet_sourcing_contactMinAggregateOutputType = {
    id: number | null
    projet_id: number | null
    sourced_user_projet_id: number | null
    created_at: Date | null
    created_by: string | null
  }

  export type Projet_sourcing_contactMaxAggregateOutputType = {
    id: number | null
    projet_id: number | null
    sourced_user_projet_id: number | null
    created_at: Date | null
    created_by: string | null
  }

  export type Projet_sourcing_contactCountAggregateOutputType = {
    id: number
    projet_id: number
    sourced_user_projet_id: number
    created_at: number
    created_by: number
    _all: number
  }


  export type Projet_sourcing_contactAvgAggregateInputType = {
    id?: true
    projet_id?: true
    sourced_user_projet_id?: true
  }

  export type Projet_sourcing_contactSumAggregateInputType = {
    id?: true
    projet_id?: true
    sourced_user_projet_id?: true
  }

  export type Projet_sourcing_contactMinAggregateInputType = {
    id?: true
    projet_id?: true
    sourced_user_projet_id?: true
    created_at?: true
    created_by?: true
  }

  export type Projet_sourcing_contactMaxAggregateInputType = {
    id?: true
    projet_id?: true
    sourced_user_projet_id?: true
    created_at?: true
    created_by?: true
  }

  export type Projet_sourcing_contactCountAggregateInputType = {
    id?: true
    projet_id?: true
    sourced_user_projet_id?: true
    created_at?: true
    created_by?: true
    _all?: true
  }

  export type Projet_sourcing_contactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_sourcing_contact to aggregate.
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_sourcing_contacts to fetch.
     */
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projet_sourcing_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_sourcing_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_sourcing_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projet_sourcing_contacts
    **/
    _count?: true | Projet_sourcing_contactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Projet_sourcing_contactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Projet_sourcing_contactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Projet_sourcing_contactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Projet_sourcing_contactMaxAggregateInputType
  }

  export type GetProjet_sourcing_contactAggregateType<T extends Projet_sourcing_contactAggregateArgs> = {
        [P in keyof T & keyof AggregateProjet_sourcing_contact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjet_sourcing_contact[P]>
      : GetScalarType<T[P], AggregateProjet_sourcing_contact[P]>
  }




  export type projet_sourcing_contactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projet_sourcing_contactWhereInput
    orderBy?: projet_sourcing_contactOrderByWithAggregationInput | projet_sourcing_contactOrderByWithAggregationInput[]
    by: Projet_sourcing_contactScalarFieldEnum[] | Projet_sourcing_contactScalarFieldEnum
    having?: projet_sourcing_contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Projet_sourcing_contactCountAggregateInputType | true
    _avg?: Projet_sourcing_contactAvgAggregateInputType
    _sum?: Projet_sourcing_contactSumAggregateInputType
    _min?: Projet_sourcing_contactMinAggregateInputType
    _max?: Projet_sourcing_contactMaxAggregateInputType
  }

  export type Projet_sourcing_contactGroupByOutputType = {
    id: number
    projet_id: number
    sourced_user_projet_id: number
    created_at: Date
    created_by: string
    _count: Projet_sourcing_contactCountAggregateOutputType | null
    _avg: Projet_sourcing_contactAvgAggregateOutputType | null
    _sum: Projet_sourcing_contactSumAggregateOutputType | null
    _min: Projet_sourcing_contactMinAggregateOutputType | null
    _max: Projet_sourcing_contactMaxAggregateOutputType | null
  }

  type GetProjet_sourcing_contactGroupByPayload<T extends projet_sourcing_contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Projet_sourcing_contactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Projet_sourcing_contactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Projet_sourcing_contactGroupByOutputType[P]>
            : GetScalarType<T[P], Projet_sourcing_contactGroupByOutputType[P]>
        }
      >
    >


  export type projet_sourcing_contactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projet_id?: boolean
    sourced_user_projet_id?: boolean
    created_at?: boolean
    created_by?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    sourced_user_projet?: boolean | user_projetDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_sourcing_contact"]>

  export type projet_sourcing_contactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projet_id?: boolean
    sourced_user_projet_id?: boolean
    created_at?: boolean
    created_by?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    sourced_user_projet?: boolean | user_projetDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_sourcing_contact"]>

  export type projet_sourcing_contactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projet_id?: boolean
    sourced_user_projet_id?: boolean
    created_at?: boolean
    created_by?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    sourced_user_projet?: boolean | user_projetDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projet_sourcing_contact"]>

  export type projet_sourcing_contactSelectScalar = {
    id?: boolean
    projet_id?: boolean
    sourced_user_projet_id?: boolean
    created_at?: boolean
    created_by?: boolean
  }

  export type projet_sourcing_contactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projet_id" | "sourced_user_projet_id" | "created_at" | "created_by", ExtArgs["result"]["projet_sourcing_contact"]>
  export type projet_sourcing_contactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    sourced_user_projet?: boolean | user_projetDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type projet_sourcing_contactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    sourced_user_projet?: boolean | user_projetDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type projet_sourcing_contactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    sourced_user_projet?: boolean | user_projetDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $projet_sourcing_contactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projet_sourcing_contact"
    objects: {
      projet: Prisma.$projetPayload<ExtArgs>
      sourced_user_projet: Prisma.$user_projetPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projet_id: number
      sourced_user_projet_id: number
      created_at: Date
      created_by: string
    }, ExtArgs["result"]["projet_sourcing_contact"]>
    composites: {}
  }

  type projet_sourcing_contactGetPayload<S extends boolean | null | undefined | projet_sourcing_contactDefaultArgs> = $Result.GetResult<Prisma.$projet_sourcing_contactPayload, S>

  type projet_sourcing_contactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projet_sourcing_contactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Projet_sourcing_contactCountAggregateInputType | true
    }

  export interface projet_sourcing_contactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projet_sourcing_contact'], meta: { name: 'projet_sourcing_contact' } }
    /**
     * Find zero or one Projet_sourcing_contact that matches the filter.
     * @param {projet_sourcing_contactFindUniqueArgs} args - Arguments to find a Projet_sourcing_contact
     * @example
     * // Get one Projet_sourcing_contact
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projet_sourcing_contactFindUniqueArgs>(args: SelectSubset<T, projet_sourcing_contactFindUniqueArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projet_sourcing_contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projet_sourcing_contactFindUniqueOrThrowArgs} args - Arguments to find a Projet_sourcing_contact
     * @example
     * // Get one Projet_sourcing_contact
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projet_sourcing_contactFindUniqueOrThrowArgs>(args: SelectSubset<T, projet_sourcing_contactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projet_sourcing_contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_sourcing_contactFindFirstArgs} args - Arguments to find a Projet_sourcing_contact
     * @example
     * // Get one Projet_sourcing_contact
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projet_sourcing_contactFindFirstArgs>(args?: SelectSubset<T, projet_sourcing_contactFindFirstArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projet_sourcing_contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_sourcing_contactFindFirstOrThrowArgs} args - Arguments to find a Projet_sourcing_contact
     * @example
     * // Get one Projet_sourcing_contact
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projet_sourcing_contactFindFirstOrThrowArgs>(args?: SelectSubset<T, projet_sourcing_contactFindFirstOrThrowArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projet_sourcing_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_sourcing_contactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projet_sourcing_contacts
     * const projet_sourcing_contacts = await prisma.projet_sourcing_contact.findMany()
     * 
     * // Get first 10 Projet_sourcing_contacts
     * const projet_sourcing_contacts = await prisma.projet_sourcing_contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projet_sourcing_contactWithIdOnly = await prisma.projet_sourcing_contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projet_sourcing_contactFindManyArgs>(args?: SelectSubset<T, projet_sourcing_contactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projet_sourcing_contact.
     * @param {projet_sourcing_contactCreateArgs} args - Arguments to create a Projet_sourcing_contact.
     * @example
     * // Create one Projet_sourcing_contact
     * const Projet_sourcing_contact = await prisma.projet_sourcing_contact.create({
     *   data: {
     *     // ... data to create a Projet_sourcing_contact
     *   }
     * })
     * 
     */
    create<T extends projet_sourcing_contactCreateArgs>(args: SelectSubset<T, projet_sourcing_contactCreateArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projet_sourcing_contacts.
     * @param {projet_sourcing_contactCreateManyArgs} args - Arguments to create many Projet_sourcing_contacts.
     * @example
     * // Create many Projet_sourcing_contacts
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projet_sourcing_contactCreateManyArgs>(args?: SelectSubset<T, projet_sourcing_contactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projet_sourcing_contacts and returns the data saved in the database.
     * @param {projet_sourcing_contactCreateManyAndReturnArgs} args - Arguments to create many Projet_sourcing_contacts.
     * @example
     * // Create many Projet_sourcing_contacts
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projet_sourcing_contacts and only return the `id`
     * const projet_sourcing_contactWithIdOnly = await prisma.projet_sourcing_contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projet_sourcing_contactCreateManyAndReturnArgs>(args?: SelectSubset<T, projet_sourcing_contactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Projet_sourcing_contact.
     * @param {projet_sourcing_contactDeleteArgs} args - Arguments to delete one Projet_sourcing_contact.
     * @example
     * // Delete one Projet_sourcing_contact
     * const Projet_sourcing_contact = await prisma.projet_sourcing_contact.delete({
     *   where: {
     *     // ... filter to delete one Projet_sourcing_contact
     *   }
     * })
     * 
     */
    delete<T extends projet_sourcing_contactDeleteArgs>(args: SelectSubset<T, projet_sourcing_contactDeleteArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projet_sourcing_contact.
     * @param {projet_sourcing_contactUpdateArgs} args - Arguments to update one Projet_sourcing_contact.
     * @example
     * // Update one Projet_sourcing_contact
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projet_sourcing_contactUpdateArgs>(args: SelectSubset<T, projet_sourcing_contactUpdateArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projet_sourcing_contacts.
     * @param {projet_sourcing_contactDeleteManyArgs} args - Arguments to filter Projet_sourcing_contacts to delete.
     * @example
     * // Delete a few Projet_sourcing_contacts
     * const { count } = await prisma.projet_sourcing_contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projet_sourcing_contactDeleteManyArgs>(args?: SelectSubset<T, projet_sourcing_contactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projet_sourcing_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_sourcing_contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projet_sourcing_contacts
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projet_sourcing_contactUpdateManyArgs>(args: SelectSubset<T, projet_sourcing_contactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projet_sourcing_contacts and returns the data updated in the database.
     * @param {projet_sourcing_contactUpdateManyAndReturnArgs} args - Arguments to update many Projet_sourcing_contacts.
     * @example
     * // Update many Projet_sourcing_contacts
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projet_sourcing_contacts and only return the `id`
     * const projet_sourcing_contactWithIdOnly = await prisma.projet_sourcing_contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projet_sourcing_contactUpdateManyAndReturnArgs>(args: SelectSubset<T, projet_sourcing_contactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Projet_sourcing_contact.
     * @param {projet_sourcing_contactUpsertArgs} args - Arguments to update or create a Projet_sourcing_contact.
     * @example
     * // Update or create a Projet_sourcing_contact
     * const projet_sourcing_contact = await prisma.projet_sourcing_contact.upsert({
     *   create: {
     *     // ... data to create a Projet_sourcing_contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projet_sourcing_contact we want to update
     *   }
     * })
     */
    upsert<T extends projet_sourcing_contactUpsertArgs>(args: SelectSubset<T, projet_sourcing_contactUpsertArgs<ExtArgs>>): Prisma__projet_sourcing_contactClient<$Result.GetResult<Prisma.$projet_sourcing_contactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projet_sourcing_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_sourcing_contactCountArgs} args - Arguments to filter Projet_sourcing_contacts to count.
     * @example
     * // Count the number of Projet_sourcing_contacts
     * const count = await prisma.projet_sourcing_contact.count({
     *   where: {
     *     // ... the filter for the Projet_sourcing_contacts we want to count
     *   }
     * })
    **/
    count<T extends projet_sourcing_contactCountArgs>(
      args?: Subset<T, projet_sourcing_contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Projet_sourcing_contactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projet_sourcing_contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Projet_sourcing_contactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Projet_sourcing_contactAggregateArgs>(args: Subset<T, Projet_sourcing_contactAggregateArgs>): Prisma.PrismaPromise<GetProjet_sourcing_contactAggregateType<T>>

    /**
     * Group by Projet_sourcing_contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projet_sourcing_contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projet_sourcing_contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projet_sourcing_contactGroupByArgs['orderBy'] }
        : { orderBy?: projet_sourcing_contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projet_sourcing_contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjet_sourcing_contactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projet_sourcing_contact model
   */
  readonly fields: projet_sourcing_contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projet_sourcing_contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projet_sourcing_contactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projet<T extends projetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetDefaultArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sourced_user_projet<T extends user_projetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_projetDefaultArgs<ExtArgs>>): Prisma__user_projetClient<$Result.GetResult<Prisma.$user_projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projet_sourcing_contact model
   */
  interface projet_sourcing_contactFieldRefs {
    readonly id: FieldRef<"projet_sourcing_contact", 'Int'>
    readonly projet_id: FieldRef<"projet_sourcing_contact", 'Int'>
    readonly sourced_user_projet_id: FieldRef<"projet_sourcing_contact", 'Int'>
    readonly created_at: FieldRef<"projet_sourcing_contact", 'DateTime'>
    readonly created_by: FieldRef<"projet_sourcing_contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * projet_sourcing_contact findUnique
   */
  export type projet_sourcing_contactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * Filter, which projet_sourcing_contact to fetch.
     */
    where: projet_sourcing_contactWhereUniqueInput
  }

  /**
   * projet_sourcing_contact findUniqueOrThrow
   */
  export type projet_sourcing_contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * Filter, which projet_sourcing_contact to fetch.
     */
    where: projet_sourcing_contactWhereUniqueInput
  }

  /**
   * projet_sourcing_contact findFirst
   */
  export type projet_sourcing_contactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * Filter, which projet_sourcing_contact to fetch.
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_sourcing_contacts to fetch.
     */
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_sourcing_contacts.
     */
    cursor?: projet_sourcing_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_sourcing_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_sourcing_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_sourcing_contacts.
     */
    distinct?: Projet_sourcing_contactScalarFieldEnum | Projet_sourcing_contactScalarFieldEnum[]
  }

  /**
   * projet_sourcing_contact findFirstOrThrow
   */
  export type projet_sourcing_contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * Filter, which projet_sourcing_contact to fetch.
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_sourcing_contacts to fetch.
     */
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projet_sourcing_contacts.
     */
    cursor?: projet_sourcing_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_sourcing_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_sourcing_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projet_sourcing_contacts.
     */
    distinct?: Projet_sourcing_contactScalarFieldEnum | Projet_sourcing_contactScalarFieldEnum[]
  }

  /**
   * projet_sourcing_contact findMany
   */
  export type projet_sourcing_contactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * Filter, which projet_sourcing_contacts to fetch.
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projet_sourcing_contacts to fetch.
     */
    orderBy?: projet_sourcing_contactOrderByWithRelationInput | projet_sourcing_contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projet_sourcing_contacts.
     */
    cursor?: projet_sourcing_contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projet_sourcing_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projet_sourcing_contacts.
     */
    skip?: number
    distinct?: Projet_sourcing_contactScalarFieldEnum | Projet_sourcing_contactScalarFieldEnum[]
  }

  /**
   * projet_sourcing_contact create
   */
  export type projet_sourcing_contactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * The data needed to create a projet_sourcing_contact.
     */
    data: XOR<projet_sourcing_contactCreateInput, projet_sourcing_contactUncheckedCreateInput>
  }

  /**
   * projet_sourcing_contact createMany
   */
  export type projet_sourcing_contactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projet_sourcing_contacts.
     */
    data: projet_sourcing_contactCreateManyInput | projet_sourcing_contactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projet_sourcing_contact createManyAndReturn
   */
  export type projet_sourcing_contactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * The data used to create many projet_sourcing_contacts.
     */
    data: projet_sourcing_contactCreateManyInput | projet_sourcing_contactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projet_sourcing_contact update
   */
  export type projet_sourcing_contactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * The data needed to update a projet_sourcing_contact.
     */
    data: XOR<projet_sourcing_contactUpdateInput, projet_sourcing_contactUncheckedUpdateInput>
    /**
     * Choose, which projet_sourcing_contact to update.
     */
    where: projet_sourcing_contactWhereUniqueInput
  }

  /**
   * projet_sourcing_contact updateMany
   */
  export type projet_sourcing_contactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projet_sourcing_contacts.
     */
    data: XOR<projet_sourcing_contactUpdateManyMutationInput, projet_sourcing_contactUncheckedUpdateManyInput>
    /**
     * Filter which projet_sourcing_contacts to update
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * Limit how many projet_sourcing_contacts to update.
     */
    limit?: number
  }

  /**
   * projet_sourcing_contact updateManyAndReturn
   */
  export type projet_sourcing_contactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * The data used to update projet_sourcing_contacts.
     */
    data: XOR<projet_sourcing_contactUpdateManyMutationInput, projet_sourcing_contactUncheckedUpdateManyInput>
    /**
     * Filter which projet_sourcing_contacts to update
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * Limit how many projet_sourcing_contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projet_sourcing_contact upsert
   */
  export type projet_sourcing_contactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * The filter to search for the projet_sourcing_contact to update in case it exists.
     */
    where: projet_sourcing_contactWhereUniqueInput
    /**
     * In case the projet_sourcing_contact found by the `where` argument doesn't exist, create a new projet_sourcing_contact with this data.
     */
    create: XOR<projet_sourcing_contactCreateInput, projet_sourcing_contactUncheckedCreateInput>
    /**
     * In case the projet_sourcing_contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projet_sourcing_contactUpdateInput, projet_sourcing_contactUncheckedUpdateInput>
  }

  /**
   * projet_sourcing_contact delete
   */
  export type projet_sourcing_contactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
    /**
     * Filter which projet_sourcing_contact to delete.
     */
    where: projet_sourcing_contactWhereUniqueInput
  }

  /**
   * projet_sourcing_contact deleteMany
   */
  export type projet_sourcing_contactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projet_sourcing_contacts to delete
     */
    where?: projet_sourcing_contactWhereInput
    /**
     * Limit how many projet_sourcing_contacts to delete.
     */
    limit?: number
  }

  /**
   * projet_sourcing_contact without action
   */
  export type projet_sourcing_contactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projet_sourcing_contact
     */
    select?: projet_sourcing_contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projet_sourcing_contact
     */
    omit?: projet_sourcing_contactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projet_sourcing_contactInclude<ExtArgs> | null
  }


  /**
   * Model estimation
   */

  export type AggregateEstimation = {
    _count: EstimationCountAggregateOutputType | null
    _avg: EstimationAvgAggregateOutputType | null
    _sum: EstimationSumAggregateOutputType | null
    _min: EstimationMinAggregateOutputType | null
    _max: EstimationMaxAggregateOutputType | null
  }

  export type EstimationAvgAggregateOutputType = {
    id: number | null
    projet_id: number | null
    fiches_solutions_id: number | null
  }

  export type EstimationSumAggregateOutputType = {
    id: number | null
    projet_id: number | null
    fiches_solutions_id: number[]
  }

  export type EstimationMinAggregateOutputType = {
    id: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
    projet_id: number | null
    deleted_at: Date | null
    deleted_by: string | null
  }

  export type EstimationMaxAggregateOutputType = {
    id: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
    projet_id: number | null
    deleted_at: Date | null
    deleted_by: string | null
  }

  export type EstimationCountAggregateOutputType = {
    id: number
    created_by: number
    created_at: number
    updated_at: number
    projet_id: number
    fiches_solutions_id: number
    materiaux: number
    deleted_at: number
    deleted_by: number
    _all: number
  }


  export type EstimationAvgAggregateInputType = {
    id?: true
    projet_id?: true
    fiches_solutions_id?: true
  }

  export type EstimationSumAggregateInputType = {
    id?: true
    projet_id?: true
    fiches_solutions_id?: true
  }

  export type EstimationMinAggregateInputType = {
    id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    projet_id?: true
    deleted_at?: true
    deleted_by?: true
  }

  export type EstimationMaxAggregateInputType = {
    id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    projet_id?: true
    deleted_at?: true
    deleted_by?: true
  }

  export type EstimationCountAggregateInputType = {
    id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    projet_id?: true
    fiches_solutions_id?: true
    materiaux?: true
    deleted_at?: true
    deleted_by?: true
    _all?: true
  }

  export type EstimationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimation to aggregate.
     */
    where?: estimationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations to fetch.
     */
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estimationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estimations
    **/
    _count?: true | EstimationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstimationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstimationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstimationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstimationMaxAggregateInputType
  }

  export type GetEstimationAggregateType<T extends EstimationAggregateArgs> = {
        [P in keyof T & keyof AggregateEstimation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstimation[P]>
      : GetScalarType<T[P], AggregateEstimation[P]>
  }




  export type estimationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimationWhereInput
    orderBy?: estimationOrderByWithAggregationInput | estimationOrderByWithAggregationInput[]
    by: EstimationScalarFieldEnum[] | EstimationScalarFieldEnum
    having?: estimationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstimationCountAggregateInputType | true
    _avg?: EstimationAvgAggregateInputType
    _sum?: EstimationSumAggregateInputType
    _min?: EstimationMinAggregateInputType
    _max?: EstimationMaxAggregateInputType
  }

  export type EstimationGroupByOutputType = {
    id: number
    created_by: string
    created_at: Date
    updated_at: Date
    projet_id: number
    fiches_solutions_id: number[]
    materiaux: JsonValue | null
    deleted_at: Date | null
    deleted_by: string | null
    _count: EstimationCountAggregateOutputType | null
    _avg: EstimationAvgAggregateOutputType | null
    _sum: EstimationSumAggregateOutputType | null
    _min: EstimationMinAggregateOutputType | null
    _max: EstimationMaxAggregateOutputType | null
  }

  type GetEstimationGroupByPayload<T extends estimationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstimationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstimationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstimationGroupByOutputType[P]>
            : GetScalarType<T[P], EstimationGroupByOutputType[P]>
        }
      >
    >


  export type estimationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet_id?: boolean
    fiches_solutions_id?: boolean
    materiaux?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | projetDefaultArgs<ExtArgs>
    deleter?: boolean | estimation$deleterArgs<ExtArgs>
    estimations_aides?: boolean | estimation$estimations_aidesArgs<ExtArgs>
    estimations_fiches_solutions?: boolean | estimation$estimations_fiches_solutionsArgs<ExtArgs>
    _count?: boolean | EstimationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation"]>

  export type estimationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet_id?: boolean
    fiches_solutions_id?: boolean
    materiaux?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | projetDefaultArgs<ExtArgs>
    deleter?: boolean | estimation$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["estimation"]>

  export type estimationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet_id?: boolean
    fiches_solutions_id?: boolean
    materiaux?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | projetDefaultArgs<ExtArgs>
    deleter?: boolean | estimation$deleterArgs<ExtArgs>
  }, ExtArgs["result"]["estimation"]>

  export type estimationSelectScalar = {
    id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet_id?: boolean
    fiches_solutions_id?: boolean
    materiaux?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
  }

  export type estimationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_by" | "created_at" | "updated_at" | "projet_id" | "fiches_solutions_id" | "materiaux" | "deleted_at" | "deleted_by", ExtArgs["result"]["estimation"]>
  export type estimationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | projetDefaultArgs<ExtArgs>
    deleter?: boolean | estimation$deleterArgs<ExtArgs>
    estimations_aides?: boolean | estimation$estimations_aidesArgs<ExtArgs>
    estimations_fiches_solutions?: boolean | estimation$estimations_fiches_solutionsArgs<ExtArgs>
    _count?: boolean | EstimationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estimationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | projetDefaultArgs<ExtArgs>
    deleter?: boolean | estimation$deleterArgs<ExtArgs>
  }
  export type estimationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    projet?: boolean | projetDefaultArgs<ExtArgs>
    deleter?: boolean | estimation$deleterArgs<ExtArgs>
  }

  export type $estimationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estimation"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      projet: Prisma.$projetPayload<ExtArgs>
      deleter: Prisma.$UserPayload<ExtArgs> | null
      estimations_aides: Prisma.$estimations_aidesPayload<ExtArgs>[]
      estimations_fiches_solutions: Prisma.$estimation_fiche_solutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      created_by: string
      created_at: Date
      updated_at: Date
      projet_id: number
      fiches_solutions_id: number[]
      materiaux: Prisma.JsonValue | null
      deleted_at: Date | null
      deleted_by: string | null
    }, ExtArgs["result"]["estimation"]>
    composites: {}
  }

  type estimationGetPayload<S extends boolean | null | undefined | estimationDefaultArgs> = $Result.GetResult<Prisma.$estimationPayload, S>

  type estimationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estimationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstimationCountAggregateInputType | true
    }

  export interface estimationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estimation'], meta: { name: 'estimation' } }
    /**
     * Find zero or one Estimation that matches the filter.
     * @param {estimationFindUniqueArgs} args - Arguments to find a Estimation
     * @example
     * // Get one Estimation
     * const estimation = await prisma.estimation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estimationFindUniqueArgs>(args: SelectSubset<T, estimationFindUniqueArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estimation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estimationFindUniqueOrThrowArgs} args - Arguments to find a Estimation
     * @example
     * // Get one Estimation
     * const estimation = await prisma.estimation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estimationFindUniqueOrThrowArgs>(args: SelectSubset<T, estimationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimationFindFirstArgs} args - Arguments to find a Estimation
     * @example
     * // Get one Estimation
     * const estimation = await prisma.estimation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estimationFindFirstArgs>(args?: SelectSubset<T, estimationFindFirstArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimationFindFirstOrThrowArgs} args - Arguments to find a Estimation
     * @example
     * // Get one Estimation
     * const estimation = await prisma.estimation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estimationFindFirstOrThrowArgs>(args?: SelectSubset<T, estimationFindFirstOrThrowArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estimations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estimations
     * const estimations = await prisma.estimation.findMany()
     * 
     * // Get first 10 Estimations
     * const estimations = await prisma.estimation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estimationWithIdOnly = await prisma.estimation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estimationFindManyArgs>(args?: SelectSubset<T, estimationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estimation.
     * @param {estimationCreateArgs} args - Arguments to create a Estimation.
     * @example
     * // Create one Estimation
     * const Estimation = await prisma.estimation.create({
     *   data: {
     *     // ... data to create a Estimation
     *   }
     * })
     * 
     */
    create<T extends estimationCreateArgs>(args: SelectSubset<T, estimationCreateArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estimations.
     * @param {estimationCreateManyArgs} args - Arguments to create many Estimations.
     * @example
     * // Create many Estimations
     * const estimation = await prisma.estimation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estimationCreateManyArgs>(args?: SelectSubset<T, estimationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estimations and returns the data saved in the database.
     * @param {estimationCreateManyAndReturnArgs} args - Arguments to create many Estimations.
     * @example
     * // Create many Estimations
     * const estimation = await prisma.estimation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estimations and only return the `id`
     * const estimationWithIdOnly = await prisma.estimation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estimationCreateManyAndReturnArgs>(args?: SelectSubset<T, estimationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estimation.
     * @param {estimationDeleteArgs} args - Arguments to delete one Estimation.
     * @example
     * // Delete one Estimation
     * const Estimation = await prisma.estimation.delete({
     *   where: {
     *     // ... filter to delete one Estimation
     *   }
     * })
     * 
     */
    delete<T extends estimationDeleteArgs>(args: SelectSubset<T, estimationDeleteArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estimation.
     * @param {estimationUpdateArgs} args - Arguments to update one Estimation.
     * @example
     * // Update one Estimation
     * const estimation = await prisma.estimation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estimationUpdateArgs>(args: SelectSubset<T, estimationUpdateArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estimations.
     * @param {estimationDeleteManyArgs} args - Arguments to filter Estimations to delete.
     * @example
     * // Delete a few Estimations
     * const { count } = await prisma.estimation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estimationDeleteManyArgs>(args?: SelectSubset<T, estimationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estimations
     * const estimation = await prisma.estimation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estimationUpdateManyArgs>(args: SelectSubset<T, estimationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimations and returns the data updated in the database.
     * @param {estimationUpdateManyAndReturnArgs} args - Arguments to update many Estimations.
     * @example
     * // Update many Estimations
     * const estimation = await prisma.estimation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estimations and only return the `id`
     * const estimationWithIdOnly = await prisma.estimation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estimationUpdateManyAndReturnArgs>(args: SelectSubset<T, estimationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estimation.
     * @param {estimationUpsertArgs} args - Arguments to update or create a Estimation.
     * @example
     * // Update or create a Estimation
     * const estimation = await prisma.estimation.upsert({
     *   create: {
     *     // ... data to create a Estimation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estimation we want to update
     *   }
     * })
     */
    upsert<T extends estimationUpsertArgs>(args: SelectSubset<T, estimationUpsertArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estimations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimationCountArgs} args - Arguments to filter Estimations to count.
     * @example
     * // Count the number of Estimations
     * const count = await prisma.estimation.count({
     *   where: {
     *     // ... the filter for the Estimations we want to count
     *   }
     * })
    **/
    count<T extends estimationCountArgs>(
      args?: Subset<T, estimationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstimationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estimation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstimationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstimationAggregateArgs>(args: Subset<T, EstimationAggregateArgs>): Prisma.PrismaPromise<GetEstimationAggregateType<T>>

    /**
     * Group by Estimation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estimationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estimationGroupByArgs['orderBy'] }
        : { orderBy?: estimationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estimationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstimationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estimation model
   */
  readonly fields: estimationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estimation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estimationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projet<T extends projetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetDefaultArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deleter<T extends estimation$deleterArgs<ExtArgs> = {}>(args?: Subset<T, estimation$deleterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    estimations_aides<T extends estimation$estimations_aidesArgs<ExtArgs> = {}>(args?: Subset<T, estimation$estimations_aidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    estimations_fiches_solutions<T extends estimation$estimations_fiches_solutionsArgs<ExtArgs> = {}>(args?: Subset<T, estimation$estimations_fiches_solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estimation model
   */
  interface estimationFieldRefs {
    readonly id: FieldRef<"estimation", 'Int'>
    readonly created_by: FieldRef<"estimation", 'String'>
    readonly created_at: FieldRef<"estimation", 'DateTime'>
    readonly updated_at: FieldRef<"estimation", 'DateTime'>
    readonly projet_id: FieldRef<"estimation", 'Int'>
    readonly fiches_solutions_id: FieldRef<"estimation", 'Int[]'>
    readonly materiaux: FieldRef<"estimation", 'Json'>
    readonly deleted_at: FieldRef<"estimation", 'DateTime'>
    readonly deleted_by: FieldRef<"estimation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * estimation findUnique
   */
  export type estimationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * Filter, which estimation to fetch.
     */
    where: estimationWhereUniqueInput
  }

  /**
   * estimation findUniqueOrThrow
   */
  export type estimationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * Filter, which estimation to fetch.
     */
    where: estimationWhereUniqueInput
  }

  /**
   * estimation findFirst
   */
  export type estimationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * Filter, which estimation to fetch.
     */
    where?: estimationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations to fetch.
     */
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimations.
     */
    cursor?: estimationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimations.
     */
    distinct?: EstimationScalarFieldEnum | EstimationScalarFieldEnum[]
  }

  /**
   * estimation findFirstOrThrow
   */
  export type estimationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * Filter, which estimation to fetch.
     */
    where?: estimationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations to fetch.
     */
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimations.
     */
    cursor?: estimationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimations.
     */
    distinct?: EstimationScalarFieldEnum | EstimationScalarFieldEnum[]
  }

  /**
   * estimation findMany
   */
  export type estimationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * Filter, which estimations to fetch.
     */
    where?: estimationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations to fetch.
     */
    orderBy?: estimationOrderByWithRelationInput | estimationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estimations.
     */
    cursor?: estimationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations.
     */
    skip?: number
    distinct?: EstimationScalarFieldEnum | EstimationScalarFieldEnum[]
  }

  /**
   * estimation create
   */
  export type estimationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * The data needed to create a estimation.
     */
    data: XOR<estimationCreateInput, estimationUncheckedCreateInput>
  }

  /**
   * estimation createMany
   */
  export type estimationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estimations.
     */
    data: estimationCreateManyInput | estimationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estimation createManyAndReturn
   */
  export type estimationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * The data used to create many estimations.
     */
    data: estimationCreateManyInput | estimationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimation update
   */
  export type estimationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * The data needed to update a estimation.
     */
    data: XOR<estimationUpdateInput, estimationUncheckedUpdateInput>
    /**
     * Choose, which estimation to update.
     */
    where: estimationWhereUniqueInput
  }

  /**
   * estimation updateMany
   */
  export type estimationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estimations.
     */
    data: XOR<estimationUpdateManyMutationInput, estimationUncheckedUpdateManyInput>
    /**
     * Filter which estimations to update
     */
    where?: estimationWhereInput
    /**
     * Limit how many estimations to update.
     */
    limit?: number
  }

  /**
   * estimation updateManyAndReturn
   */
  export type estimationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * The data used to update estimations.
     */
    data: XOR<estimationUpdateManyMutationInput, estimationUncheckedUpdateManyInput>
    /**
     * Filter which estimations to update
     */
    where?: estimationWhereInput
    /**
     * Limit how many estimations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimation upsert
   */
  export type estimationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * The filter to search for the estimation to update in case it exists.
     */
    where: estimationWhereUniqueInput
    /**
     * In case the estimation found by the `where` argument doesn't exist, create a new estimation with this data.
     */
    create: XOR<estimationCreateInput, estimationUncheckedCreateInput>
    /**
     * In case the estimation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estimationUpdateInput, estimationUncheckedUpdateInput>
  }

  /**
   * estimation delete
   */
  export type estimationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
    /**
     * Filter which estimation to delete.
     */
    where: estimationWhereUniqueInput
  }

  /**
   * estimation deleteMany
   */
  export type estimationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimations to delete
     */
    where?: estimationWhereInput
    /**
     * Limit how many estimations to delete.
     */
    limit?: number
  }

  /**
   * estimation.deleter
   */
  export type estimation$deleterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * estimation.estimations_aides
   */
  export type estimation$estimations_aidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    where?: estimations_aidesWhereInput
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    cursor?: estimations_aidesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Estimations_aidesScalarFieldEnum | Estimations_aidesScalarFieldEnum[]
  }

  /**
   * estimation.estimations_fiches_solutions
   */
  export type estimation$estimations_fiches_solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    where?: estimation_fiche_solutionWhereInput
    orderBy?: estimation_fiche_solutionOrderByWithRelationInput | estimation_fiche_solutionOrderByWithRelationInput[]
    cursor?: estimation_fiche_solutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Estimation_fiche_solutionScalarFieldEnum | Estimation_fiche_solutionScalarFieldEnum[]
  }

  /**
   * estimation without action
   */
  export type estimationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation
     */
    select?: estimationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation
     */
    omit?: estimationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimationInclude<ExtArgs> | null
  }


  /**
   * Model climadiag
   */

  export type AggregateClimadiag = {
    _count: ClimadiagCountAggregateOutputType | null
    _avg: ClimadiagAvgAggregateOutputType | null
    _sum: ClimadiagSumAggregateOutputType | null
    _min: ClimadiagMinAggregateOutputType | null
    _max: ClimadiagMaxAggregateOutputType | null
  }

  export type ClimadiagAvgAggregateOutputType = {
    id: number | null
    epci_parent_id: number | null
    jours_tres_chauds_ref: number | null
    nuits_chaudes_ref: number | null
    jours_vdc_ref: number | null
    population: number | null
    superficie: number | null
    couverture_lcz: number | null
  }

  export type ClimadiagSumAggregateOutputType = {
    id: number | null
    epci_parent_id: number | null
    jours_tres_chauds_ref: number | null
    nuits_chaudes_ref: number | null
    jours_vdc_ref: number | null
    population: number | null
    superficie: number | null
    couverture_lcz: number | null
  }

  export type ClimadiagMinAggregateOutputType = {
    id: number | null
    nom: string | null
    type_lieu: $Enums.TypeLieuClimadiag | null
    code_insee: string | null
    code_postal: string | null
    epci_parent_id: number | null
    jours_tres_chauds_ref: number | null
    nuits_chaudes_ref: number | null
    jours_vdc_ref: number | null
    population: number | null
    superficie: number | null
    couverture_lcz: number | null
    searchable_field: string | null
  }

  export type ClimadiagMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    type_lieu: $Enums.TypeLieuClimadiag | null
    code_insee: string | null
    code_postal: string | null
    epci_parent_id: number | null
    jours_tres_chauds_ref: number | null
    nuits_chaudes_ref: number | null
    jours_vdc_ref: number | null
    population: number | null
    superficie: number | null
    couverture_lcz: number | null
    searchable_field: string | null
  }

  export type ClimadiagCountAggregateOutputType = {
    id: number
    nom: number
    type_lieu: number
    code_insee: number
    code_postal: number
    epci_parent_id: number
    jours_tres_chauds_ref: number
    jours_tres_chauds_prevision: number
    nuits_chaudes_ref: number
    nuits_chaudes_prevision: number
    jours_vdc_ref: number
    jours_vdc_prevision: number
    population: number
    superficie: number
    couverture_lcz: number
    adresse_all_infos: number
    searchable_field: number
    _all: number
  }


  export type ClimadiagAvgAggregateInputType = {
    id?: true
    epci_parent_id?: true
    jours_tres_chauds_ref?: true
    nuits_chaudes_ref?: true
    jours_vdc_ref?: true
    population?: true
    superficie?: true
    couverture_lcz?: true
  }

  export type ClimadiagSumAggregateInputType = {
    id?: true
    epci_parent_id?: true
    jours_tres_chauds_ref?: true
    nuits_chaudes_ref?: true
    jours_vdc_ref?: true
    population?: true
    superficie?: true
    couverture_lcz?: true
  }

  export type ClimadiagMinAggregateInputType = {
    id?: true
    nom?: true
    type_lieu?: true
    code_insee?: true
    code_postal?: true
    epci_parent_id?: true
    jours_tres_chauds_ref?: true
    nuits_chaudes_ref?: true
    jours_vdc_ref?: true
    population?: true
    superficie?: true
    couverture_lcz?: true
    searchable_field?: true
  }

  export type ClimadiagMaxAggregateInputType = {
    id?: true
    nom?: true
    type_lieu?: true
    code_insee?: true
    code_postal?: true
    epci_parent_id?: true
    jours_tres_chauds_ref?: true
    nuits_chaudes_ref?: true
    jours_vdc_ref?: true
    population?: true
    superficie?: true
    couverture_lcz?: true
    searchable_field?: true
  }

  export type ClimadiagCountAggregateInputType = {
    id?: true
    nom?: true
    type_lieu?: true
    code_insee?: true
    code_postal?: true
    epci_parent_id?: true
    jours_tres_chauds_ref?: true
    jours_tres_chauds_prevision?: true
    nuits_chaudes_ref?: true
    nuits_chaudes_prevision?: true
    jours_vdc_ref?: true
    jours_vdc_prevision?: true
    population?: true
    superficie?: true
    couverture_lcz?: true
    adresse_all_infos?: true
    searchable_field?: true
    _all?: true
  }

  export type ClimadiagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which climadiag to aggregate.
     */
    where?: climadiagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of climadiags to fetch.
     */
    orderBy?: climadiagOrderByWithRelationInput | climadiagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: climadiagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` climadiags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` climadiags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned climadiags
    **/
    _count?: true | ClimadiagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClimadiagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClimadiagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClimadiagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClimadiagMaxAggregateInputType
  }

  export type GetClimadiagAggregateType<T extends ClimadiagAggregateArgs> = {
        [P in keyof T & keyof AggregateClimadiag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClimadiag[P]>
      : GetScalarType<T[P], AggregateClimadiag[P]>
  }




  export type climadiagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: climadiagWhereInput
    orderBy?: climadiagOrderByWithAggregationInput | climadiagOrderByWithAggregationInput[]
    by: ClimadiagScalarFieldEnum[] | ClimadiagScalarFieldEnum
    having?: climadiagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClimadiagCountAggregateInputType | true
    _avg?: ClimadiagAvgAggregateInputType
    _sum?: ClimadiagSumAggregateInputType
    _min?: ClimadiagMinAggregateInputType
    _max?: ClimadiagMaxAggregateInputType
  }

  export type ClimadiagGroupByOutputType = {
    id: number
    nom: string
    type_lieu: $Enums.TypeLieuClimadiag
    code_insee: string
    code_postal: string
    epci_parent_id: number | null
    jours_tres_chauds_ref: number | null
    jours_tres_chauds_prevision: JsonValue
    nuits_chaudes_ref: number | null
    nuits_chaudes_prevision: JsonValue
    jours_vdc_ref: number | null
    jours_vdc_prevision: JsonValue
    population: number
    superficie: number
    couverture_lcz: number
    adresse_all_infos: JsonValue | null
    searchable_field: string
    _count: ClimadiagCountAggregateOutputType | null
    _avg: ClimadiagAvgAggregateOutputType | null
    _sum: ClimadiagSumAggregateOutputType | null
    _min: ClimadiagMinAggregateOutputType | null
    _max: ClimadiagMaxAggregateOutputType | null
  }

  type GetClimadiagGroupByPayload<T extends climadiagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClimadiagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClimadiagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClimadiagGroupByOutputType[P]>
            : GetScalarType<T[P], ClimadiagGroupByOutputType[P]>
        }
      >
    >


  export type climadiagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type_lieu?: boolean
    code_insee?: boolean
    code_postal?: boolean
    epci_parent_id?: boolean
    jours_tres_chauds_ref?: boolean
    jours_tres_chauds_prevision?: boolean
    nuits_chaudes_ref?: boolean
    nuits_chaudes_prevision?: boolean
    jours_vdc_ref?: boolean
    jours_vdc_prevision?: boolean
    population?: boolean
    superficie?: boolean
    couverture_lcz?: boolean
    adresse_all_infos?: boolean
    searchable_field?: boolean
  }, ExtArgs["result"]["climadiag"]>

  export type climadiagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type_lieu?: boolean
    code_insee?: boolean
    code_postal?: boolean
    epci_parent_id?: boolean
    jours_tres_chauds_ref?: boolean
    jours_tres_chauds_prevision?: boolean
    nuits_chaudes_ref?: boolean
    nuits_chaudes_prevision?: boolean
    jours_vdc_ref?: boolean
    jours_vdc_prevision?: boolean
    population?: boolean
    superficie?: boolean
    couverture_lcz?: boolean
    adresse_all_infos?: boolean
    searchable_field?: boolean
  }, ExtArgs["result"]["climadiag"]>

  export type climadiagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type_lieu?: boolean
    code_insee?: boolean
    code_postal?: boolean
    epci_parent_id?: boolean
    jours_tres_chauds_ref?: boolean
    jours_tres_chauds_prevision?: boolean
    nuits_chaudes_ref?: boolean
    nuits_chaudes_prevision?: boolean
    jours_vdc_ref?: boolean
    jours_vdc_prevision?: boolean
    population?: boolean
    superficie?: boolean
    couverture_lcz?: boolean
    adresse_all_infos?: boolean
    searchable_field?: boolean
  }, ExtArgs["result"]["climadiag"]>

  export type climadiagSelectScalar = {
    id?: boolean
    nom?: boolean
    type_lieu?: boolean
    code_insee?: boolean
    code_postal?: boolean
    epci_parent_id?: boolean
    jours_tres_chauds_ref?: boolean
    jours_tres_chauds_prevision?: boolean
    nuits_chaudes_ref?: boolean
    nuits_chaudes_prevision?: boolean
    jours_vdc_ref?: boolean
    jours_vdc_prevision?: boolean
    population?: boolean
    superficie?: boolean
    couverture_lcz?: boolean
    adresse_all_infos?: boolean
    searchable_field?: boolean
  }

  export type climadiagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "type_lieu" | "code_insee" | "code_postal" | "epci_parent_id" | "jours_tres_chauds_ref" | "jours_tres_chauds_prevision" | "nuits_chaudes_ref" | "nuits_chaudes_prevision" | "jours_vdc_ref" | "jours_vdc_prevision" | "population" | "superficie" | "couverture_lcz" | "adresse_all_infos" | "searchable_field", ExtArgs["result"]["climadiag"]>

  export type $climadiagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "climadiag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      type_lieu: $Enums.TypeLieuClimadiag
      code_insee: string
      code_postal: string
      epci_parent_id: number | null
      jours_tres_chauds_ref: number | null
      jours_tres_chauds_prevision: Prisma.JsonValue
      nuits_chaudes_ref: number | null
      nuits_chaudes_prevision: Prisma.JsonValue
      jours_vdc_ref: number | null
      jours_vdc_prevision: Prisma.JsonValue
      population: number
      superficie: number
      couverture_lcz: number
      adresse_all_infos: Prisma.JsonValue | null
      searchable_field: string
    }, ExtArgs["result"]["climadiag"]>
    composites: {}
  }

  type climadiagGetPayload<S extends boolean | null | undefined | climadiagDefaultArgs> = $Result.GetResult<Prisma.$climadiagPayload, S>

  type climadiagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<climadiagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClimadiagCountAggregateInputType | true
    }

  export interface climadiagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['climadiag'], meta: { name: 'climadiag' } }
    /**
     * Find zero or one Climadiag that matches the filter.
     * @param {climadiagFindUniqueArgs} args - Arguments to find a Climadiag
     * @example
     * // Get one Climadiag
     * const climadiag = await prisma.climadiag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends climadiagFindUniqueArgs>(args: SelectSubset<T, climadiagFindUniqueArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Climadiag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {climadiagFindUniqueOrThrowArgs} args - Arguments to find a Climadiag
     * @example
     * // Get one Climadiag
     * const climadiag = await prisma.climadiag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends climadiagFindUniqueOrThrowArgs>(args: SelectSubset<T, climadiagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Climadiag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {climadiagFindFirstArgs} args - Arguments to find a Climadiag
     * @example
     * // Get one Climadiag
     * const climadiag = await prisma.climadiag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends climadiagFindFirstArgs>(args?: SelectSubset<T, climadiagFindFirstArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Climadiag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {climadiagFindFirstOrThrowArgs} args - Arguments to find a Climadiag
     * @example
     * // Get one Climadiag
     * const climadiag = await prisma.climadiag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends climadiagFindFirstOrThrowArgs>(args?: SelectSubset<T, climadiagFindFirstOrThrowArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Climadiags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {climadiagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Climadiags
     * const climadiags = await prisma.climadiag.findMany()
     * 
     * // Get first 10 Climadiags
     * const climadiags = await prisma.climadiag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const climadiagWithIdOnly = await prisma.climadiag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends climadiagFindManyArgs>(args?: SelectSubset<T, climadiagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Climadiag.
     * @param {climadiagCreateArgs} args - Arguments to create a Climadiag.
     * @example
     * // Create one Climadiag
     * const Climadiag = await prisma.climadiag.create({
     *   data: {
     *     // ... data to create a Climadiag
     *   }
     * })
     * 
     */
    create<T extends climadiagCreateArgs>(args: SelectSubset<T, climadiagCreateArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Climadiags.
     * @param {climadiagCreateManyArgs} args - Arguments to create many Climadiags.
     * @example
     * // Create many Climadiags
     * const climadiag = await prisma.climadiag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends climadiagCreateManyArgs>(args?: SelectSubset<T, climadiagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Climadiags and returns the data saved in the database.
     * @param {climadiagCreateManyAndReturnArgs} args - Arguments to create many Climadiags.
     * @example
     * // Create many Climadiags
     * const climadiag = await prisma.climadiag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Climadiags and only return the `id`
     * const climadiagWithIdOnly = await prisma.climadiag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends climadiagCreateManyAndReturnArgs>(args?: SelectSubset<T, climadiagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Climadiag.
     * @param {climadiagDeleteArgs} args - Arguments to delete one Climadiag.
     * @example
     * // Delete one Climadiag
     * const Climadiag = await prisma.climadiag.delete({
     *   where: {
     *     // ... filter to delete one Climadiag
     *   }
     * })
     * 
     */
    delete<T extends climadiagDeleteArgs>(args: SelectSubset<T, climadiagDeleteArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Climadiag.
     * @param {climadiagUpdateArgs} args - Arguments to update one Climadiag.
     * @example
     * // Update one Climadiag
     * const climadiag = await prisma.climadiag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends climadiagUpdateArgs>(args: SelectSubset<T, climadiagUpdateArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Climadiags.
     * @param {climadiagDeleteManyArgs} args - Arguments to filter Climadiags to delete.
     * @example
     * // Delete a few Climadiags
     * const { count } = await prisma.climadiag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends climadiagDeleteManyArgs>(args?: SelectSubset<T, climadiagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Climadiags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {climadiagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Climadiags
     * const climadiag = await prisma.climadiag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends climadiagUpdateManyArgs>(args: SelectSubset<T, climadiagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Climadiags and returns the data updated in the database.
     * @param {climadiagUpdateManyAndReturnArgs} args - Arguments to update many Climadiags.
     * @example
     * // Update many Climadiags
     * const climadiag = await prisma.climadiag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Climadiags and only return the `id`
     * const climadiagWithIdOnly = await prisma.climadiag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends climadiagUpdateManyAndReturnArgs>(args: SelectSubset<T, climadiagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Climadiag.
     * @param {climadiagUpsertArgs} args - Arguments to update or create a Climadiag.
     * @example
     * // Update or create a Climadiag
     * const climadiag = await prisma.climadiag.upsert({
     *   create: {
     *     // ... data to create a Climadiag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Climadiag we want to update
     *   }
     * })
     */
    upsert<T extends climadiagUpsertArgs>(args: SelectSubset<T, climadiagUpsertArgs<ExtArgs>>): Prisma__climadiagClient<$Result.GetResult<Prisma.$climadiagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Climadiags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {climadiagCountArgs} args - Arguments to filter Climadiags to count.
     * @example
     * // Count the number of Climadiags
     * const count = await prisma.climadiag.count({
     *   where: {
     *     // ... the filter for the Climadiags we want to count
     *   }
     * })
    **/
    count<T extends climadiagCountArgs>(
      args?: Subset<T, climadiagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClimadiagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Climadiag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClimadiagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClimadiagAggregateArgs>(args: Subset<T, ClimadiagAggregateArgs>): Prisma.PrismaPromise<GetClimadiagAggregateType<T>>

    /**
     * Group by Climadiag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {climadiagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends climadiagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: climadiagGroupByArgs['orderBy'] }
        : { orderBy?: climadiagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, climadiagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClimadiagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the climadiag model
   */
  readonly fields: climadiagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for climadiag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__climadiagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the climadiag model
   */
  interface climadiagFieldRefs {
    readonly id: FieldRef<"climadiag", 'Int'>
    readonly nom: FieldRef<"climadiag", 'String'>
    readonly type_lieu: FieldRef<"climadiag", 'TypeLieuClimadiag'>
    readonly code_insee: FieldRef<"climadiag", 'String'>
    readonly code_postal: FieldRef<"climadiag", 'String'>
    readonly epci_parent_id: FieldRef<"climadiag", 'Int'>
    readonly jours_tres_chauds_ref: FieldRef<"climadiag", 'Float'>
    readonly jours_tres_chauds_prevision: FieldRef<"climadiag", 'Json'>
    readonly nuits_chaudes_ref: FieldRef<"climadiag", 'Float'>
    readonly nuits_chaudes_prevision: FieldRef<"climadiag", 'Json'>
    readonly jours_vdc_ref: FieldRef<"climadiag", 'Float'>
    readonly jours_vdc_prevision: FieldRef<"climadiag", 'Json'>
    readonly population: FieldRef<"climadiag", 'Int'>
    readonly superficie: FieldRef<"climadiag", 'Int'>
    readonly couverture_lcz: FieldRef<"climadiag", 'Float'>
    readonly adresse_all_infos: FieldRef<"climadiag", 'Json'>
    readonly searchable_field: FieldRef<"climadiag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * climadiag findUnique
   */
  export type climadiagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * Filter, which climadiag to fetch.
     */
    where: climadiagWhereUniqueInput
  }

  /**
   * climadiag findUniqueOrThrow
   */
  export type climadiagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * Filter, which climadiag to fetch.
     */
    where: climadiagWhereUniqueInput
  }

  /**
   * climadiag findFirst
   */
  export type climadiagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * Filter, which climadiag to fetch.
     */
    where?: climadiagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of climadiags to fetch.
     */
    orderBy?: climadiagOrderByWithRelationInput | climadiagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for climadiags.
     */
    cursor?: climadiagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` climadiags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` climadiags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of climadiags.
     */
    distinct?: ClimadiagScalarFieldEnum | ClimadiagScalarFieldEnum[]
  }

  /**
   * climadiag findFirstOrThrow
   */
  export type climadiagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * Filter, which climadiag to fetch.
     */
    where?: climadiagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of climadiags to fetch.
     */
    orderBy?: climadiagOrderByWithRelationInput | climadiagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for climadiags.
     */
    cursor?: climadiagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` climadiags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` climadiags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of climadiags.
     */
    distinct?: ClimadiagScalarFieldEnum | ClimadiagScalarFieldEnum[]
  }

  /**
   * climadiag findMany
   */
  export type climadiagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * Filter, which climadiags to fetch.
     */
    where?: climadiagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of climadiags to fetch.
     */
    orderBy?: climadiagOrderByWithRelationInput | climadiagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing climadiags.
     */
    cursor?: climadiagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` climadiags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` climadiags.
     */
    skip?: number
    distinct?: ClimadiagScalarFieldEnum | ClimadiagScalarFieldEnum[]
  }

  /**
   * climadiag create
   */
  export type climadiagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * The data needed to create a climadiag.
     */
    data: XOR<climadiagCreateInput, climadiagUncheckedCreateInput>
  }

  /**
   * climadiag createMany
   */
  export type climadiagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many climadiags.
     */
    data: climadiagCreateManyInput | climadiagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * climadiag createManyAndReturn
   */
  export type climadiagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * The data used to create many climadiags.
     */
    data: climadiagCreateManyInput | climadiagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * climadiag update
   */
  export type climadiagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * The data needed to update a climadiag.
     */
    data: XOR<climadiagUpdateInput, climadiagUncheckedUpdateInput>
    /**
     * Choose, which climadiag to update.
     */
    where: climadiagWhereUniqueInput
  }

  /**
   * climadiag updateMany
   */
  export type climadiagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update climadiags.
     */
    data: XOR<climadiagUpdateManyMutationInput, climadiagUncheckedUpdateManyInput>
    /**
     * Filter which climadiags to update
     */
    where?: climadiagWhereInput
    /**
     * Limit how many climadiags to update.
     */
    limit?: number
  }

  /**
   * climadiag updateManyAndReturn
   */
  export type climadiagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * The data used to update climadiags.
     */
    data: XOR<climadiagUpdateManyMutationInput, climadiagUncheckedUpdateManyInput>
    /**
     * Filter which climadiags to update
     */
    where?: climadiagWhereInput
    /**
     * Limit how many climadiags to update.
     */
    limit?: number
  }

  /**
   * climadiag upsert
   */
  export type climadiagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * The filter to search for the climadiag to update in case it exists.
     */
    where: climadiagWhereUniqueInput
    /**
     * In case the climadiag found by the `where` argument doesn't exist, create a new climadiag with this data.
     */
    create: XOR<climadiagCreateInput, climadiagUncheckedCreateInput>
    /**
     * In case the climadiag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<climadiagUpdateInput, climadiagUncheckedUpdateInput>
  }

  /**
   * climadiag delete
   */
  export type climadiagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
    /**
     * Filter which climadiag to delete.
     */
    where: climadiagWhereUniqueInput
  }

  /**
   * climadiag deleteMany
   */
  export type climadiagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which climadiags to delete
     */
    where?: climadiagWhereInput
    /**
     * Limit how many climadiags to delete.
     */
    limit?: number
  }

  /**
   * climadiag without action
   */
  export type climadiagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the climadiag
     */
    select?: climadiagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the climadiag
     */
    omit?: climadiagOmit<ExtArgs> | null
  }


  /**
   * Model aide
   */

  export type AggregateAide = {
    _count: AideCountAggregateOutputType | null
    _avg: AideAvgAggregateOutputType | null
    _sum: AideSumAggregateOutputType | null
    _min: AideMinAggregateOutputType | null
    _max: AideMaxAggregateOutputType | null
  }

  export type AideAvgAggregateOutputType = {
    id: number | null
    aideTerritoireId: number | null
  }

  export type AideSumAggregateOutputType = {
    id: number | null
    aideTerritoireId: number | null
  }

  export type AideMinAggregateOutputType = {
    id: number | null
    aideTerritoireId: number | null
    submission_deadline: Date | null
    type: string | null
    name: string | null
  }

  export type AideMaxAggregateOutputType = {
    id: number | null
    aideTerritoireId: number | null
    submission_deadline: Date | null
    type: string | null
    name: string | null
  }

  export type AideCountAggregateOutputType = {
    id: number
    aideTerritoireId: number
    submission_deadline: number
    type: number
    name: number
    financers: number
    _all: number
  }


  export type AideAvgAggregateInputType = {
    id?: true
    aideTerritoireId?: true
  }

  export type AideSumAggregateInputType = {
    id?: true
    aideTerritoireId?: true
  }

  export type AideMinAggregateInputType = {
    id?: true
    aideTerritoireId?: true
    submission_deadline?: true
    type?: true
    name?: true
  }

  export type AideMaxAggregateInputType = {
    id?: true
    aideTerritoireId?: true
    submission_deadline?: true
    type?: true
    name?: true
  }

  export type AideCountAggregateInputType = {
    id?: true
    aideTerritoireId?: true
    submission_deadline?: true
    type?: true
    name?: true
    financers?: true
    _all?: true
  }

  export type AideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aide to aggregate.
     */
    where?: aideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aides to fetch.
     */
    orderBy?: aideOrderByWithRelationInput | aideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aides
    **/
    _count?: true | AideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AideMaxAggregateInputType
  }

  export type GetAideAggregateType<T extends AideAggregateArgs> = {
        [P in keyof T & keyof AggregateAide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAide[P]>
      : GetScalarType<T[P], AggregateAide[P]>
  }




  export type aideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aideWhereInput
    orderBy?: aideOrderByWithAggregationInput | aideOrderByWithAggregationInput[]
    by: AideScalarFieldEnum[] | AideScalarFieldEnum
    having?: aideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AideCountAggregateInputType | true
    _avg?: AideAvgAggregateInputType
    _sum?: AideSumAggregateInputType
    _min?: AideMinAggregateInputType
    _max?: AideMaxAggregateInputType
  }

  export type AideGroupByOutputType = {
    id: number
    aideTerritoireId: number
    submission_deadline: Date | null
    type: string
    name: string | null
    financers: string[]
    _count: AideCountAggregateOutputType | null
    _avg: AideAvgAggregateOutputType | null
    _sum: AideSumAggregateOutputType | null
    _min: AideMinAggregateOutputType | null
    _max: AideMaxAggregateOutputType | null
  }

  type GetAideGroupByPayload<T extends aideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AideGroupByOutputType[P]>
            : GetScalarType<T[P], AideGroupByOutputType[P]>
        }
      >
    >


  export type aideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aideTerritoireId?: boolean
    submission_deadline?: boolean
    type?: boolean
    name?: boolean
    financers?: boolean
    estimations_aides?: boolean | aide$estimations_aidesArgs<ExtArgs>
    _count?: boolean | AideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aide"]>

  export type aideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aideTerritoireId?: boolean
    submission_deadline?: boolean
    type?: boolean
    name?: boolean
    financers?: boolean
  }, ExtArgs["result"]["aide"]>

  export type aideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aideTerritoireId?: boolean
    submission_deadline?: boolean
    type?: boolean
    name?: boolean
    financers?: boolean
  }, ExtArgs["result"]["aide"]>

  export type aideSelectScalar = {
    id?: boolean
    aideTerritoireId?: boolean
    submission_deadline?: boolean
    type?: boolean
    name?: boolean
    financers?: boolean
  }

  export type aideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "aideTerritoireId" | "submission_deadline" | "type" | "name" | "financers", ExtArgs["result"]["aide"]>
  export type aideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimations_aides?: boolean | aide$estimations_aidesArgs<ExtArgs>
    _count?: boolean | AideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type aideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type aideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $aidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aide"
    objects: {
      estimations_aides: Prisma.$estimations_aidesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      aideTerritoireId: number
      submission_deadline: Date | null
      type: string
      name: string | null
      financers: string[]
    }, ExtArgs["result"]["aide"]>
    composites: {}
  }

  type aideGetPayload<S extends boolean | null | undefined | aideDefaultArgs> = $Result.GetResult<Prisma.$aidePayload, S>

  type aideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AideCountAggregateInputType | true
    }

  export interface aideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aide'], meta: { name: 'aide' } }
    /**
     * Find zero or one Aide that matches the filter.
     * @param {aideFindUniqueArgs} args - Arguments to find a Aide
     * @example
     * // Get one Aide
     * const aide = await prisma.aide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aideFindUniqueArgs>(args: SelectSubset<T, aideFindUniqueArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aide that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aideFindUniqueOrThrowArgs} args - Arguments to find a Aide
     * @example
     * // Get one Aide
     * const aide = await prisma.aide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aideFindUniqueOrThrowArgs>(args: SelectSubset<T, aideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aideFindFirstArgs} args - Arguments to find a Aide
     * @example
     * // Get one Aide
     * const aide = await prisma.aide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aideFindFirstArgs>(args?: SelectSubset<T, aideFindFirstArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aideFindFirstOrThrowArgs} args - Arguments to find a Aide
     * @example
     * // Get one Aide
     * const aide = await prisma.aide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aideFindFirstOrThrowArgs>(args?: SelectSubset<T, aideFindFirstOrThrowArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Aides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aides
     * const aides = await prisma.aide.findMany()
     * 
     * // Get first 10 Aides
     * const aides = await prisma.aide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aideWithIdOnly = await prisma.aide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends aideFindManyArgs>(args?: SelectSubset<T, aideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aide.
     * @param {aideCreateArgs} args - Arguments to create a Aide.
     * @example
     * // Create one Aide
     * const Aide = await prisma.aide.create({
     *   data: {
     *     // ... data to create a Aide
     *   }
     * })
     * 
     */
    create<T extends aideCreateArgs>(args: SelectSubset<T, aideCreateArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Aides.
     * @param {aideCreateManyArgs} args - Arguments to create many Aides.
     * @example
     * // Create many Aides
     * const aide = await prisma.aide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aideCreateManyArgs>(args?: SelectSubset<T, aideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Aides and returns the data saved in the database.
     * @param {aideCreateManyAndReturnArgs} args - Arguments to create many Aides.
     * @example
     * // Create many Aides
     * const aide = await prisma.aide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Aides and only return the `id`
     * const aideWithIdOnly = await prisma.aide.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends aideCreateManyAndReturnArgs>(args?: SelectSubset<T, aideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Aide.
     * @param {aideDeleteArgs} args - Arguments to delete one Aide.
     * @example
     * // Delete one Aide
     * const Aide = await prisma.aide.delete({
     *   where: {
     *     // ... filter to delete one Aide
     *   }
     * })
     * 
     */
    delete<T extends aideDeleteArgs>(args: SelectSubset<T, aideDeleteArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aide.
     * @param {aideUpdateArgs} args - Arguments to update one Aide.
     * @example
     * // Update one Aide
     * const aide = await prisma.aide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aideUpdateArgs>(args: SelectSubset<T, aideUpdateArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Aides.
     * @param {aideDeleteManyArgs} args - Arguments to filter Aides to delete.
     * @example
     * // Delete a few Aides
     * const { count } = await prisma.aide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aideDeleteManyArgs>(args?: SelectSubset<T, aideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aides
     * const aide = await prisma.aide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aideUpdateManyArgs>(args: SelectSubset<T, aideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aides and returns the data updated in the database.
     * @param {aideUpdateManyAndReturnArgs} args - Arguments to update many Aides.
     * @example
     * // Update many Aides
     * const aide = await prisma.aide.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Aides and only return the `id`
     * const aideWithIdOnly = await prisma.aide.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends aideUpdateManyAndReturnArgs>(args: SelectSubset<T, aideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Aide.
     * @param {aideUpsertArgs} args - Arguments to update or create a Aide.
     * @example
     * // Update or create a Aide
     * const aide = await prisma.aide.upsert({
     *   create: {
     *     // ... data to create a Aide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aide we want to update
     *   }
     * })
     */
    upsert<T extends aideUpsertArgs>(args: SelectSubset<T, aideUpsertArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Aides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aideCountArgs} args - Arguments to filter Aides to count.
     * @example
     * // Count the number of Aides
     * const count = await prisma.aide.count({
     *   where: {
     *     // ... the filter for the Aides we want to count
     *   }
     * })
    **/
    count<T extends aideCountArgs>(
      args?: Subset<T, aideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AideAggregateArgs>(args: Subset<T, AideAggregateArgs>): Prisma.PrismaPromise<GetAideAggregateType<T>>

    /**
     * Group by Aide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aideGroupByArgs['orderBy'] }
        : { orderBy?: aideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aide model
   */
  readonly fields: aideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estimations_aides<T extends aide$estimations_aidesArgs<ExtArgs> = {}>(args?: Subset<T, aide$estimations_aidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aide model
   */
  interface aideFieldRefs {
    readonly id: FieldRef<"aide", 'Int'>
    readonly aideTerritoireId: FieldRef<"aide", 'Int'>
    readonly submission_deadline: FieldRef<"aide", 'DateTime'>
    readonly type: FieldRef<"aide", 'String'>
    readonly name: FieldRef<"aide", 'String'>
    readonly financers: FieldRef<"aide", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * aide findUnique
   */
  export type aideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * Filter, which aide to fetch.
     */
    where: aideWhereUniqueInput
  }

  /**
   * aide findUniqueOrThrow
   */
  export type aideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * Filter, which aide to fetch.
     */
    where: aideWhereUniqueInput
  }

  /**
   * aide findFirst
   */
  export type aideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * Filter, which aide to fetch.
     */
    where?: aideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aides to fetch.
     */
    orderBy?: aideOrderByWithRelationInput | aideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aides.
     */
    cursor?: aideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aides.
     */
    distinct?: AideScalarFieldEnum | AideScalarFieldEnum[]
  }

  /**
   * aide findFirstOrThrow
   */
  export type aideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * Filter, which aide to fetch.
     */
    where?: aideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aides to fetch.
     */
    orderBy?: aideOrderByWithRelationInput | aideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aides.
     */
    cursor?: aideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aides.
     */
    distinct?: AideScalarFieldEnum | AideScalarFieldEnum[]
  }

  /**
   * aide findMany
   */
  export type aideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * Filter, which aides to fetch.
     */
    where?: aideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aides to fetch.
     */
    orderBy?: aideOrderByWithRelationInput | aideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aides.
     */
    cursor?: aideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aides.
     */
    skip?: number
    distinct?: AideScalarFieldEnum | AideScalarFieldEnum[]
  }

  /**
   * aide create
   */
  export type aideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * The data needed to create a aide.
     */
    data: XOR<aideCreateInput, aideUncheckedCreateInput>
  }

  /**
   * aide createMany
   */
  export type aideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aides.
     */
    data: aideCreateManyInput | aideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aide createManyAndReturn
   */
  export type aideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * The data used to create many aides.
     */
    data: aideCreateManyInput | aideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aide update
   */
  export type aideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * The data needed to update a aide.
     */
    data: XOR<aideUpdateInput, aideUncheckedUpdateInput>
    /**
     * Choose, which aide to update.
     */
    where: aideWhereUniqueInput
  }

  /**
   * aide updateMany
   */
  export type aideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aides.
     */
    data: XOR<aideUpdateManyMutationInput, aideUncheckedUpdateManyInput>
    /**
     * Filter which aides to update
     */
    where?: aideWhereInput
    /**
     * Limit how many aides to update.
     */
    limit?: number
  }

  /**
   * aide updateManyAndReturn
   */
  export type aideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * The data used to update aides.
     */
    data: XOR<aideUpdateManyMutationInput, aideUncheckedUpdateManyInput>
    /**
     * Filter which aides to update
     */
    where?: aideWhereInput
    /**
     * Limit how many aides to update.
     */
    limit?: number
  }

  /**
   * aide upsert
   */
  export type aideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * The filter to search for the aide to update in case it exists.
     */
    where: aideWhereUniqueInput
    /**
     * In case the aide found by the `where` argument doesn't exist, create a new aide with this data.
     */
    create: XOR<aideCreateInput, aideUncheckedCreateInput>
    /**
     * In case the aide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aideUpdateInput, aideUncheckedUpdateInput>
  }

  /**
   * aide delete
   */
  export type aideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
    /**
     * Filter which aide to delete.
     */
    where: aideWhereUniqueInput
  }

  /**
   * aide deleteMany
   */
  export type aideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aides to delete
     */
    where?: aideWhereInput
    /**
     * Limit how many aides to delete.
     */
    limit?: number
  }

  /**
   * aide.estimations_aides
   */
  export type aide$estimations_aidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    where?: estimations_aidesWhereInput
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    cursor?: estimations_aidesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Estimations_aidesScalarFieldEnum | Estimations_aidesScalarFieldEnum[]
  }

  /**
   * aide without action
   */
  export type aideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aide
     */
    select?: aideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aide
     */
    omit?: aideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aideInclude<ExtArgs> | null
  }


  /**
   * Model estimations_aides
   */

  export type AggregateEstimations_aides = {
    _count: Estimations_aidesCountAggregateOutputType | null
    _avg: Estimations_aidesAvgAggregateOutputType | null
    _sum: Estimations_aidesSumAggregateOutputType | null
    _min: Estimations_aidesMinAggregateOutputType | null
    _max: Estimations_aidesMaxAggregateOutputType | null
  }

  export type Estimations_aidesAvgAggregateOutputType = {
    id: number | null
    estimationId: number | null
    aideId: number | null
  }

  export type Estimations_aidesSumAggregateOutputType = {
    id: number | null
    estimationId: number | null
    aideId: number | null
  }

  export type Estimations_aidesMinAggregateOutputType = {
    id: number | null
    estimationId: number | null
    aideId: number | null
    created_at: Date | null
    user_id: string | null
  }

  export type Estimations_aidesMaxAggregateOutputType = {
    id: number | null
    estimationId: number | null
    aideId: number | null
    created_at: Date | null
    user_id: string | null
  }

  export type Estimations_aidesCountAggregateOutputType = {
    id: number
    estimationId: number
    aideId: number
    created_at: number
    user_id: number
    _all: number
  }


  export type Estimations_aidesAvgAggregateInputType = {
    id?: true
    estimationId?: true
    aideId?: true
  }

  export type Estimations_aidesSumAggregateInputType = {
    id?: true
    estimationId?: true
    aideId?: true
  }

  export type Estimations_aidesMinAggregateInputType = {
    id?: true
    estimationId?: true
    aideId?: true
    created_at?: true
    user_id?: true
  }

  export type Estimations_aidesMaxAggregateInputType = {
    id?: true
    estimationId?: true
    aideId?: true
    created_at?: true
    user_id?: true
  }

  export type Estimations_aidesCountAggregateInputType = {
    id?: true
    estimationId?: true
    aideId?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type Estimations_aidesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimations_aides to aggregate.
     */
    where?: estimations_aidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations_aides to fetch.
     */
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estimations_aidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations_aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations_aides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estimations_aides
    **/
    _count?: true | Estimations_aidesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estimations_aidesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estimations_aidesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estimations_aidesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estimations_aidesMaxAggregateInputType
  }

  export type GetEstimations_aidesAggregateType<T extends Estimations_aidesAggregateArgs> = {
        [P in keyof T & keyof AggregateEstimations_aides]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstimations_aides[P]>
      : GetScalarType<T[P], AggregateEstimations_aides[P]>
  }




  export type estimations_aidesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimations_aidesWhereInput
    orderBy?: estimations_aidesOrderByWithAggregationInput | estimations_aidesOrderByWithAggregationInput[]
    by: Estimations_aidesScalarFieldEnum[] | Estimations_aidesScalarFieldEnum
    having?: estimations_aidesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estimations_aidesCountAggregateInputType | true
    _avg?: Estimations_aidesAvgAggregateInputType
    _sum?: Estimations_aidesSumAggregateInputType
    _min?: Estimations_aidesMinAggregateInputType
    _max?: Estimations_aidesMaxAggregateInputType
  }

  export type Estimations_aidesGroupByOutputType = {
    id: number
    estimationId: number
    aideId: number
    created_at: Date | null
    user_id: string | null
    _count: Estimations_aidesCountAggregateOutputType | null
    _avg: Estimations_aidesAvgAggregateOutputType | null
    _sum: Estimations_aidesSumAggregateOutputType | null
    _min: Estimations_aidesMinAggregateOutputType | null
    _max: Estimations_aidesMaxAggregateOutputType | null
  }

  type GetEstimations_aidesGroupByPayload<T extends estimations_aidesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estimations_aidesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estimations_aidesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estimations_aidesGroupByOutputType[P]>
            : GetScalarType<T[P], Estimations_aidesGroupByOutputType[P]>
        }
      >
    >


  export type estimations_aidesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimationId?: boolean
    aideId?: boolean
    created_at?: boolean
    user_id?: boolean
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    aide?: boolean | aideDefaultArgs<ExtArgs>
    created_by?: boolean | estimations_aides$created_byArgs<ExtArgs>
  }, ExtArgs["result"]["estimations_aides"]>

  export type estimations_aidesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimationId?: boolean
    aideId?: boolean
    created_at?: boolean
    user_id?: boolean
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    aide?: boolean | aideDefaultArgs<ExtArgs>
    created_by?: boolean | estimations_aides$created_byArgs<ExtArgs>
  }, ExtArgs["result"]["estimations_aides"]>

  export type estimations_aidesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimationId?: boolean
    aideId?: boolean
    created_at?: boolean
    user_id?: boolean
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    aide?: boolean | aideDefaultArgs<ExtArgs>
    created_by?: boolean | estimations_aides$created_byArgs<ExtArgs>
  }, ExtArgs["result"]["estimations_aides"]>

  export type estimations_aidesSelectScalar = {
    id?: boolean
    estimationId?: boolean
    aideId?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type estimations_aidesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estimationId" | "aideId" | "created_at" | "user_id", ExtArgs["result"]["estimations_aides"]>
  export type estimations_aidesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    aide?: boolean | aideDefaultArgs<ExtArgs>
    created_by?: boolean | estimations_aides$created_byArgs<ExtArgs>
  }
  export type estimations_aidesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    aide?: boolean | aideDefaultArgs<ExtArgs>
    created_by?: boolean | estimations_aides$created_byArgs<ExtArgs>
  }
  export type estimations_aidesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    aide?: boolean | aideDefaultArgs<ExtArgs>
    created_by?: boolean | estimations_aides$created_byArgs<ExtArgs>
  }

  export type $estimations_aidesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estimations_aides"
    objects: {
      estimation: Prisma.$estimationPayload<ExtArgs>
      aide: Prisma.$aidePayload<ExtArgs>
      created_by: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estimationId: number
      aideId: number
      created_at: Date | null
      user_id: string | null
    }, ExtArgs["result"]["estimations_aides"]>
    composites: {}
  }

  type estimations_aidesGetPayload<S extends boolean | null | undefined | estimations_aidesDefaultArgs> = $Result.GetResult<Prisma.$estimations_aidesPayload, S>

  type estimations_aidesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estimations_aidesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Estimations_aidesCountAggregateInputType | true
    }

  export interface estimations_aidesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estimations_aides'], meta: { name: 'estimations_aides' } }
    /**
     * Find zero or one Estimations_aides that matches the filter.
     * @param {estimations_aidesFindUniqueArgs} args - Arguments to find a Estimations_aides
     * @example
     * // Get one Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estimations_aidesFindUniqueArgs>(args: SelectSubset<T, estimations_aidesFindUniqueArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estimations_aides that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estimations_aidesFindUniqueOrThrowArgs} args - Arguments to find a Estimations_aides
     * @example
     * // Get one Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estimations_aidesFindUniqueOrThrowArgs>(args: SelectSubset<T, estimations_aidesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimations_aides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimations_aidesFindFirstArgs} args - Arguments to find a Estimations_aides
     * @example
     * // Get one Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estimations_aidesFindFirstArgs>(args?: SelectSubset<T, estimations_aidesFindFirstArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimations_aides that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimations_aidesFindFirstOrThrowArgs} args - Arguments to find a Estimations_aides
     * @example
     * // Get one Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estimations_aidesFindFirstOrThrowArgs>(args?: SelectSubset<T, estimations_aidesFindFirstOrThrowArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estimations_aides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimations_aidesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.findMany()
     * 
     * // Get first 10 Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estimations_aidesWithIdOnly = await prisma.estimations_aides.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estimations_aidesFindManyArgs>(args?: SelectSubset<T, estimations_aidesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estimations_aides.
     * @param {estimations_aidesCreateArgs} args - Arguments to create a Estimations_aides.
     * @example
     * // Create one Estimations_aides
     * const Estimations_aides = await prisma.estimations_aides.create({
     *   data: {
     *     // ... data to create a Estimations_aides
     *   }
     * })
     * 
     */
    create<T extends estimations_aidesCreateArgs>(args: SelectSubset<T, estimations_aidesCreateArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estimations_aides.
     * @param {estimations_aidesCreateManyArgs} args - Arguments to create many Estimations_aides.
     * @example
     * // Create many Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estimations_aidesCreateManyArgs>(args?: SelectSubset<T, estimations_aidesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estimations_aides and returns the data saved in the database.
     * @param {estimations_aidesCreateManyAndReturnArgs} args - Arguments to create many Estimations_aides.
     * @example
     * // Create many Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estimations_aides and only return the `id`
     * const estimations_aidesWithIdOnly = await prisma.estimations_aides.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estimations_aidesCreateManyAndReturnArgs>(args?: SelectSubset<T, estimations_aidesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estimations_aides.
     * @param {estimations_aidesDeleteArgs} args - Arguments to delete one Estimations_aides.
     * @example
     * // Delete one Estimations_aides
     * const Estimations_aides = await prisma.estimations_aides.delete({
     *   where: {
     *     // ... filter to delete one Estimations_aides
     *   }
     * })
     * 
     */
    delete<T extends estimations_aidesDeleteArgs>(args: SelectSubset<T, estimations_aidesDeleteArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estimations_aides.
     * @param {estimations_aidesUpdateArgs} args - Arguments to update one Estimations_aides.
     * @example
     * // Update one Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estimations_aidesUpdateArgs>(args: SelectSubset<T, estimations_aidesUpdateArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estimations_aides.
     * @param {estimations_aidesDeleteManyArgs} args - Arguments to filter Estimations_aides to delete.
     * @example
     * // Delete a few Estimations_aides
     * const { count } = await prisma.estimations_aides.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estimations_aidesDeleteManyArgs>(args?: SelectSubset<T, estimations_aidesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimations_aides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimations_aidesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estimations_aidesUpdateManyArgs>(args: SelectSubset<T, estimations_aidesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimations_aides and returns the data updated in the database.
     * @param {estimations_aidesUpdateManyAndReturnArgs} args - Arguments to update many Estimations_aides.
     * @example
     * // Update many Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estimations_aides and only return the `id`
     * const estimations_aidesWithIdOnly = await prisma.estimations_aides.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estimations_aidesUpdateManyAndReturnArgs>(args: SelectSubset<T, estimations_aidesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estimations_aides.
     * @param {estimations_aidesUpsertArgs} args - Arguments to update or create a Estimations_aides.
     * @example
     * // Update or create a Estimations_aides
     * const estimations_aides = await prisma.estimations_aides.upsert({
     *   create: {
     *     // ... data to create a Estimations_aides
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estimations_aides we want to update
     *   }
     * })
     */
    upsert<T extends estimations_aidesUpsertArgs>(args: SelectSubset<T, estimations_aidesUpsertArgs<ExtArgs>>): Prisma__estimations_aidesClient<$Result.GetResult<Prisma.$estimations_aidesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estimations_aides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimations_aidesCountArgs} args - Arguments to filter Estimations_aides to count.
     * @example
     * // Count the number of Estimations_aides
     * const count = await prisma.estimations_aides.count({
     *   where: {
     *     // ... the filter for the Estimations_aides we want to count
     *   }
     * })
    **/
    count<T extends estimations_aidesCountArgs>(
      args?: Subset<T, estimations_aidesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estimations_aidesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estimations_aides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estimations_aidesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estimations_aidesAggregateArgs>(args: Subset<T, Estimations_aidesAggregateArgs>): Prisma.PrismaPromise<GetEstimations_aidesAggregateType<T>>

    /**
     * Group by Estimations_aides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimations_aidesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estimations_aidesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estimations_aidesGroupByArgs['orderBy'] }
        : { orderBy?: estimations_aidesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estimations_aidesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstimations_aidesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estimations_aides model
   */
  readonly fields: estimations_aidesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estimations_aides.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estimations_aidesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estimation<T extends estimationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estimationDefaultArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aide<T extends aideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, aideDefaultArgs<ExtArgs>>): Prisma__aideClient<$Result.GetResult<Prisma.$aidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    created_by<T extends estimations_aides$created_byArgs<ExtArgs> = {}>(args?: Subset<T, estimations_aides$created_byArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estimations_aides model
   */
  interface estimations_aidesFieldRefs {
    readonly id: FieldRef<"estimations_aides", 'Int'>
    readonly estimationId: FieldRef<"estimations_aides", 'Int'>
    readonly aideId: FieldRef<"estimations_aides", 'Int'>
    readonly created_at: FieldRef<"estimations_aides", 'DateTime'>
    readonly user_id: FieldRef<"estimations_aides", 'String'>
  }
    

  // Custom InputTypes
  /**
   * estimations_aides findUnique
   */
  export type estimations_aidesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * Filter, which estimations_aides to fetch.
     */
    where: estimations_aidesWhereUniqueInput
  }

  /**
   * estimations_aides findUniqueOrThrow
   */
  export type estimations_aidesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * Filter, which estimations_aides to fetch.
     */
    where: estimations_aidesWhereUniqueInput
  }

  /**
   * estimations_aides findFirst
   */
  export type estimations_aidesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * Filter, which estimations_aides to fetch.
     */
    where?: estimations_aidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations_aides to fetch.
     */
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimations_aides.
     */
    cursor?: estimations_aidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations_aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations_aides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimations_aides.
     */
    distinct?: Estimations_aidesScalarFieldEnum | Estimations_aidesScalarFieldEnum[]
  }

  /**
   * estimations_aides findFirstOrThrow
   */
  export type estimations_aidesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * Filter, which estimations_aides to fetch.
     */
    where?: estimations_aidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations_aides to fetch.
     */
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimations_aides.
     */
    cursor?: estimations_aidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations_aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations_aides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimations_aides.
     */
    distinct?: Estimations_aidesScalarFieldEnum | Estimations_aidesScalarFieldEnum[]
  }

  /**
   * estimations_aides findMany
   */
  export type estimations_aidesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * Filter, which estimations_aides to fetch.
     */
    where?: estimations_aidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimations_aides to fetch.
     */
    orderBy?: estimations_aidesOrderByWithRelationInput | estimations_aidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estimations_aides.
     */
    cursor?: estimations_aidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimations_aides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimations_aides.
     */
    skip?: number
    distinct?: Estimations_aidesScalarFieldEnum | Estimations_aidesScalarFieldEnum[]
  }

  /**
   * estimations_aides create
   */
  export type estimations_aidesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * The data needed to create a estimations_aides.
     */
    data: XOR<estimations_aidesCreateInput, estimations_aidesUncheckedCreateInput>
  }

  /**
   * estimations_aides createMany
   */
  export type estimations_aidesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estimations_aides.
     */
    data: estimations_aidesCreateManyInput | estimations_aidesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estimations_aides createManyAndReturn
   */
  export type estimations_aidesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * The data used to create many estimations_aides.
     */
    data: estimations_aidesCreateManyInput | estimations_aidesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimations_aides update
   */
  export type estimations_aidesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * The data needed to update a estimations_aides.
     */
    data: XOR<estimations_aidesUpdateInput, estimations_aidesUncheckedUpdateInput>
    /**
     * Choose, which estimations_aides to update.
     */
    where: estimations_aidesWhereUniqueInput
  }

  /**
   * estimations_aides updateMany
   */
  export type estimations_aidesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estimations_aides.
     */
    data: XOR<estimations_aidesUpdateManyMutationInput, estimations_aidesUncheckedUpdateManyInput>
    /**
     * Filter which estimations_aides to update
     */
    where?: estimations_aidesWhereInput
    /**
     * Limit how many estimations_aides to update.
     */
    limit?: number
  }

  /**
   * estimations_aides updateManyAndReturn
   */
  export type estimations_aidesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * The data used to update estimations_aides.
     */
    data: XOR<estimations_aidesUpdateManyMutationInput, estimations_aidesUncheckedUpdateManyInput>
    /**
     * Filter which estimations_aides to update
     */
    where?: estimations_aidesWhereInput
    /**
     * Limit how many estimations_aides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimations_aides upsert
   */
  export type estimations_aidesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * The filter to search for the estimations_aides to update in case it exists.
     */
    where: estimations_aidesWhereUniqueInput
    /**
     * In case the estimations_aides found by the `where` argument doesn't exist, create a new estimations_aides with this data.
     */
    create: XOR<estimations_aidesCreateInput, estimations_aidesUncheckedCreateInput>
    /**
     * In case the estimations_aides was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estimations_aidesUpdateInput, estimations_aidesUncheckedUpdateInput>
  }

  /**
   * estimations_aides delete
   */
  export type estimations_aidesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
    /**
     * Filter which estimations_aides to delete.
     */
    where: estimations_aidesWhereUniqueInput
  }

  /**
   * estimations_aides deleteMany
   */
  export type estimations_aidesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimations_aides to delete
     */
    where?: estimations_aidesWhereInput
    /**
     * Limit how many estimations_aides to delete.
     */
    limit?: number
  }

  /**
   * estimations_aides.created_by
   */
  export type estimations_aides$created_byArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * estimations_aides without action
   */
  export type estimations_aidesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimations_aides
     */
    select?: estimations_aidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimations_aides
     */
    omit?: estimations_aidesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimations_aidesInclude<ExtArgs> | null
  }


  /**
   * Model estimation_materiaux
   */

  export type AggregateEstimation_materiaux = {
    _count: Estimation_materiauxCountAggregateOutputType | null
    _avg: Estimation_materiauxAvgAggregateOutputType | null
    _sum: Estimation_materiauxSumAggregateOutputType | null
    _min: Estimation_materiauxMinAggregateOutputType | null
    _max: Estimation_materiauxMaxAggregateOutputType | null
  }

  export type Estimation_materiauxAvgAggregateOutputType = {
    materiau_id: number | null
    quantite: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_materiauxSumAggregateOutputType = {
    materiau_id: number | null
    quantite: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_materiauxMinAggregateOutputType = {
    id: string | null
    estimation_fiche_solution_id: string | null
    materiau_id: number | null
    quantite: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_materiauxMaxAggregateOutputType = {
    id: string | null
    estimation_fiche_solution_id: string | null
    materiau_id: number | null
    quantite: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_materiauxCountAggregateOutputType = {
    id: number
    estimation_fiche_solution_id: number
    materiau_id: number
    quantite: number
    cout_investissement_override: number
    cout_entretien_override: number
    _all: number
  }


  export type Estimation_materiauxAvgAggregateInputType = {
    materiau_id?: true
    quantite?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_materiauxSumAggregateInputType = {
    materiau_id?: true
    quantite?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_materiauxMinAggregateInputType = {
    id?: true
    estimation_fiche_solution_id?: true
    materiau_id?: true
    quantite?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_materiauxMaxAggregateInputType = {
    id?: true
    estimation_fiche_solution_id?: true
    materiau_id?: true
    quantite?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_materiauxCountAggregateInputType = {
    id?: true
    estimation_fiche_solution_id?: true
    materiau_id?: true
    quantite?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
    _all?: true
  }

  export type Estimation_materiauxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimation_materiaux to aggregate.
     */
    where?: estimation_materiauxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_materiauxes to fetch.
     */
    orderBy?: estimation_materiauxOrderByWithRelationInput | estimation_materiauxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estimation_materiauxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_materiauxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_materiauxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estimation_materiauxes
    **/
    _count?: true | Estimation_materiauxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estimation_materiauxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estimation_materiauxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estimation_materiauxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estimation_materiauxMaxAggregateInputType
  }

  export type GetEstimation_materiauxAggregateType<T extends Estimation_materiauxAggregateArgs> = {
        [P in keyof T & keyof AggregateEstimation_materiaux]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstimation_materiaux[P]>
      : GetScalarType<T[P], AggregateEstimation_materiaux[P]>
  }




  export type estimation_materiauxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimation_materiauxWhereInput
    orderBy?: estimation_materiauxOrderByWithAggregationInput | estimation_materiauxOrderByWithAggregationInput[]
    by: Estimation_materiauxScalarFieldEnum[] | Estimation_materiauxScalarFieldEnum
    having?: estimation_materiauxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estimation_materiauxCountAggregateInputType | true
    _avg?: Estimation_materiauxAvgAggregateInputType
    _sum?: Estimation_materiauxSumAggregateInputType
    _min?: Estimation_materiauxMinAggregateInputType
    _max?: Estimation_materiauxMaxAggregateInputType
  }

  export type Estimation_materiauxGroupByOutputType = {
    id: string
    estimation_fiche_solution_id: string
    materiau_id: number
    quantite: number
    cout_investissement_override: number | null
    cout_entretien_override: number | null
    _count: Estimation_materiauxCountAggregateOutputType | null
    _avg: Estimation_materiauxAvgAggregateOutputType | null
    _sum: Estimation_materiauxSumAggregateOutputType | null
    _min: Estimation_materiauxMinAggregateOutputType | null
    _max: Estimation_materiauxMaxAggregateOutputType | null
  }

  type GetEstimation_materiauxGroupByPayload<T extends estimation_materiauxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estimation_materiauxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estimation_materiauxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estimation_materiauxGroupByOutputType[P]>
            : GetScalarType<T[P], Estimation_materiauxGroupByOutputType[P]>
        }
      >
    >


  export type estimation_materiauxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimation_fiche_solution_id?: boolean
    materiau_id?: boolean
    quantite?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
    estimation_fiche_solution?: boolean | estimation_fiche_solutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation_materiaux"]>

  export type estimation_materiauxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimation_fiche_solution_id?: boolean
    materiau_id?: boolean
    quantite?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
    estimation_fiche_solution?: boolean | estimation_fiche_solutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation_materiaux"]>

  export type estimation_materiauxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimation_fiche_solution_id?: boolean
    materiau_id?: boolean
    quantite?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
    estimation_fiche_solution?: boolean | estimation_fiche_solutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation_materiaux"]>

  export type estimation_materiauxSelectScalar = {
    id?: boolean
    estimation_fiche_solution_id?: boolean
    materiau_id?: boolean
    quantite?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
  }

  export type estimation_materiauxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estimation_fiche_solution_id" | "materiau_id" | "quantite" | "cout_investissement_override" | "cout_entretien_override", ExtArgs["result"]["estimation_materiaux"]>
  export type estimation_materiauxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation_fiche_solution?: boolean | estimation_fiche_solutionDefaultArgs<ExtArgs>
  }
  export type estimation_materiauxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation_fiche_solution?: boolean | estimation_fiche_solutionDefaultArgs<ExtArgs>
  }
  export type estimation_materiauxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation_fiche_solution?: boolean | estimation_fiche_solutionDefaultArgs<ExtArgs>
  }

  export type $estimation_materiauxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estimation_materiaux"
    objects: {
      estimation_fiche_solution: Prisma.$estimation_fiche_solutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estimation_fiche_solution_id: string
      materiau_id: number
      quantite: number
      cout_investissement_override: number | null
      cout_entretien_override: number | null
    }, ExtArgs["result"]["estimation_materiaux"]>
    composites: {}
  }

  type estimation_materiauxGetPayload<S extends boolean | null | undefined | estimation_materiauxDefaultArgs> = $Result.GetResult<Prisma.$estimation_materiauxPayload, S>

  type estimation_materiauxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estimation_materiauxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Estimation_materiauxCountAggregateInputType | true
    }

  export interface estimation_materiauxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estimation_materiaux'], meta: { name: 'estimation_materiaux' } }
    /**
     * Find zero or one Estimation_materiaux that matches the filter.
     * @param {estimation_materiauxFindUniqueArgs} args - Arguments to find a Estimation_materiaux
     * @example
     * // Get one Estimation_materiaux
     * const estimation_materiaux = await prisma.estimation_materiaux.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estimation_materiauxFindUniqueArgs>(args: SelectSubset<T, estimation_materiauxFindUniqueArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estimation_materiaux that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estimation_materiauxFindUniqueOrThrowArgs} args - Arguments to find a Estimation_materiaux
     * @example
     * // Get one Estimation_materiaux
     * const estimation_materiaux = await prisma.estimation_materiaux.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estimation_materiauxFindUniqueOrThrowArgs>(args: SelectSubset<T, estimation_materiauxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimation_materiaux that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_materiauxFindFirstArgs} args - Arguments to find a Estimation_materiaux
     * @example
     * // Get one Estimation_materiaux
     * const estimation_materiaux = await prisma.estimation_materiaux.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estimation_materiauxFindFirstArgs>(args?: SelectSubset<T, estimation_materiauxFindFirstArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimation_materiaux that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_materiauxFindFirstOrThrowArgs} args - Arguments to find a Estimation_materiaux
     * @example
     * // Get one Estimation_materiaux
     * const estimation_materiaux = await prisma.estimation_materiaux.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estimation_materiauxFindFirstOrThrowArgs>(args?: SelectSubset<T, estimation_materiauxFindFirstOrThrowArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estimation_materiauxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_materiauxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estimation_materiauxes
     * const estimation_materiauxes = await prisma.estimation_materiaux.findMany()
     * 
     * // Get first 10 Estimation_materiauxes
     * const estimation_materiauxes = await prisma.estimation_materiaux.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estimation_materiauxWithIdOnly = await prisma.estimation_materiaux.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estimation_materiauxFindManyArgs>(args?: SelectSubset<T, estimation_materiauxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estimation_materiaux.
     * @param {estimation_materiauxCreateArgs} args - Arguments to create a Estimation_materiaux.
     * @example
     * // Create one Estimation_materiaux
     * const Estimation_materiaux = await prisma.estimation_materiaux.create({
     *   data: {
     *     // ... data to create a Estimation_materiaux
     *   }
     * })
     * 
     */
    create<T extends estimation_materiauxCreateArgs>(args: SelectSubset<T, estimation_materiauxCreateArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estimation_materiauxes.
     * @param {estimation_materiauxCreateManyArgs} args - Arguments to create many Estimation_materiauxes.
     * @example
     * // Create many Estimation_materiauxes
     * const estimation_materiaux = await prisma.estimation_materiaux.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estimation_materiauxCreateManyArgs>(args?: SelectSubset<T, estimation_materiauxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estimation_materiauxes and returns the data saved in the database.
     * @param {estimation_materiauxCreateManyAndReturnArgs} args - Arguments to create many Estimation_materiauxes.
     * @example
     * // Create many Estimation_materiauxes
     * const estimation_materiaux = await prisma.estimation_materiaux.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estimation_materiauxes and only return the `id`
     * const estimation_materiauxWithIdOnly = await prisma.estimation_materiaux.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estimation_materiauxCreateManyAndReturnArgs>(args?: SelectSubset<T, estimation_materiauxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estimation_materiaux.
     * @param {estimation_materiauxDeleteArgs} args - Arguments to delete one Estimation_materiaux.
     * @example
     * // Delete one Estimation_materiaux
     * const Estimation_materiaux = await prisma.estimation_materiaux.delete({
     *   where: {
     *     // ... filter to delete one Estimation_materiaux
     *   }
     * })
     * 
     */
    delete<T extends estimation_materiauxDeleteArgs>(args: SelectSubset<T, estimation_materiauxDeleteArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estimation_materiaux.
     * @param {estimation_materiauxUpdateArgs} args - Arguments to update one Estimation_materiaux.
     * @example
     * // Update one Estimation_materiaux
     * const estimation_materiaux = await prisma.estimation_materiaux.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estimation_materiauxUpdateArgs>(args: SelectSubset<T, estimation_materiauxUpdateArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estimation_materiauxes.
     * @param {estimation_materiauxDeleteManyArgs} args - Arguments to filter Estimation_materiauxes to delete.
     * @example
     * // Delete a few Estimation_materiauxes
     * const { count } = await prisma.estimation_materiaux.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estimation_materiauxDeleteManyArgs>(args?: SelectSubset<T, estimation_materiauxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimation_materiauxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_materiauxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estimation_materiauxes
     * const estimation_materiaux = await prisma.estimation_materiaux.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estimation_materiauxUpdateManyArgs>(args: SelectSubset<T, estimation_materiauxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimation_materiauxes and returns the data updated in the database.
     * @param {estimation_materiauxUpdateManyAndReturnArgs} args - Arguments to update many Estimation_materiauxes.
     * @example
     * // Update many Estimation_materiauxes
     * const estimation_materiaux = await prisma.estimation_materiaux.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estimation_materiauxes and only return the `id`
     * const estimation_materiauxWithIdOnly = await prisma.estimation_materiaux.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estimation_materiauxUpdateManyAndReturnArgs>(args: SelectSubset<T, estimation_materiauxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estimation_materiaux.
     * @param {estimation_materiauxUpsertArgs} args - Arguments to update or create a Estimation_materiaux.
     * @example
     * // Update or create a Estimation_materiaux
     * const estimation_materiaux = await prisma.estimation_materiaux.upsert({
     *   create: {
     *     // ... data to create a Estimation_materiaux
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estimation_materiaux we want to update
     *   }
     * })
     */
    upsert<T extends estimation_materiauxUpsertArgs>(args: SelectSubset<T, estimation_materiauxUpsertArgs<ExtArgs>>): Prisma__estimation_materiauxClient<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estimation_materiauxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_materiauxCountArgs} args - Arguments to filter Estimation_materiauxes to count.
     * @example
     * // Count the number of Estimation_materiauxes
     * const count = await prisma.estimation_materiaux.count({
     *   where: {
     *     // ... the filter for the Estimation_materiauxes we want to count
     *   }
     * })
    **/
    count<T extends estimation_materiauxCountArgs>(
      args?: Subset<T, estimation_materiauxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estimation_materiauxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estimation_materiaux.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estimation_materiauxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estimation_materiauxAggregateArgs>(args: Subset<T, Estimation_materiauxAggregateArgs>): Prisma.PrismaPromise<GetEstimation_materiauxAggregateType<T>>

    /**
     * Group by Estimation_materiaux.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_materiauxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estimation_materiauxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estimation_materiauxGroupByArgs['orderBy'] }
        : { orderBy?: estimation_materiauxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estimation_materiauxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstimation_materiauxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estimation_materiaux model
   */
  readonly fields: estimation_materiauxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estimation_materiaux.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estimation_materiauxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estimation_fiche_solution<T extends estimation_fiche_solutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estimation_fiche_solutionDefaultArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estimation_materiaux model
   */
  interface estimation_materiauxFieldRefs {
    readonly id: FieldRef<"estimation_materiaux", 'String'>
    readonly estimation_fiche_solution_id: FieldRef<"estimation_materiaux", 'String'>
    readonly materiau_id: FieldRef<"estimation_materiaux", 'Int'>
    readonly quantite: FieldRef<"estimation_materiaux", 'Int'>
    readonly cout_investissement_override: FieldRef<"estimation_materiaux", 'Int'>
    readonly cout_entretien_override: FieldRef<"estimation_materiaux", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * estimation_materiaux findUnique
   */
  export type estimation_materiauxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * Filter, which estimation_materiaux to fetch.
     */
    where: estimation_materiauxWhereUniqueInput
  }

  /**
   * estimation_materiaux findUniqueOrThrow
   */
  export type estimation_materiauxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * Filter, which estimation_materiaux to fetch.
     */
    where: estimation_materiauxWhereUniqueInput
  }

  /**
   * estimation_materiaux findFirst
   */
  export type estimation_materiauxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * Filter, which estimation_materiaux to fetch.
     */
    where?: estimation_materiauxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_materiauxes to fetch.
     */
    orderBy?: estimation_materiauxOrderByWithRelationInput | estimation_materiauxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimation_materiauxes.
     */
    cursor?: estimation_materiauxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_materiauxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_materiauxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimation_materiauxes.
     */
    distinct?: Estimation_materiauxScalarFieldEnum | Estimation_materiauxScalarFieldEnum[]
  }

  /**
   * estimation_materiaux findFirstOrThrow
   */
  export type estimation_materiauxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * Filter, which estimation_materiaux to fetch.
     */
    where?: estimation_materiauxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_materiauxes to fetch.
     */
    orderBy?: estimation_materiauxOrderByWithRelationInput | estimation_materiauxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimation_materiauxes.
     */
    cursor?: estimation_materiauxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_materiauxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_materiauxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimation_materiauxes.
     */
    distinct?: Estimation_materiauxScalarFieldEnum | Estimation_materiauxScalarFieldEnum[]
  }

  /**
   * estimation_materiaux findMany
   */
  export type estimation_materiauxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * Filter, which estimation_materiauxes to fetch.
     */
    where?: estimation_materiauxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_materiauxes to fetch.
     */
    orderBy?: estimation_materiauxOrderByWithRelationInput | estimation_materiauxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estimation_materiauxes.
     */
    cursor?: estimation_materiauxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_materiauxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_materiauxes.
     */
    skip?: number
    distinct?: Estimation_materiauxScalarFieldEnum | Estimation_materiauxScalarFieldEnum[]
  }

  /**
   * estimation_materiaux create
   */
  export type estimation_materiauxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * The data needed to create a estimation_materiaux.
     */
    data: XOR<estimation_materiauxCreateInput, estimation_materiauxUncheckedCreateInput>
  }

  /**
   * estimation_materiaux createMany
   */
  export type estimation_materiauxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estimation_materiauxes.
     */
    data: estimation_materiauxCreateManyInput | estimation_materiauxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estimation_materiaux createManyAndReturn
   */
  export type estimation_materiauxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * The data used to create many estimation_materiauxes.
     */
    data: estimation_materiauxCreateManyInput | estimation_materiauxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimation_materiaux update
   */
  export type estimation_materiauxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * The data needed to update a estimation_materiaux.
     */
    data: XOR<estimation_materiauxUpdateInput, estimation_materiauxUncheckedUpdateInput>
    /**
     * Choose, which estimation_materiaux to update.
     */
    where: estimation_materiauxWhereUniqueInput
  }

  /**
   * estimation_materiaux updateMany
   */
  export type estimation_materiauxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estimation_materiauxes.
     */
    data: XOR<estimation_materiauxUpdateManyMutationInput, estimation_materiauxUncheckedUpdateManyInput>
    /**
     * Filter which estimation_materiauxes to update
     */
    where?: estimation_materiauxWhereInput
    /**
     * Limit how many estimation_materiauxes to update.
     */
    limit?: number
  }

  /**
   * estimation_materiaux updateManyAndReturn
   */
  export type estimation_materiauxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * The data used to update estimation_materiauxes.
     */
    data: XOR<estimation_materiauxUpdateManyMutationInput, estimation_materiauxUncheckedUpdateManyInput>
    /**
     * Filter which estimation_materiauxes to update
     */
    where?: estimation_materiauxWhereInput
    /**
     * Limit how many estimation_materiauxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimation_materiaux upsert
   */
  export type estimation_materiauxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * The filter to search for the estimation_materiaux to update in case it exists.
     */
    where: estimation_materiauxWhereUniqueInput
    /**
     * In case the estimation_materiaux found by the `where` argument doesn't exist, create a new estimation_materiaux with this data.
     */
    create: XOR<estimation_materiauxCreateInput, estimation_materiauxUncheckedCreateInput>
    /**
     * In case the estimation_materiaux was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estimation_materiauxUpdateInput, estimation_materiauxUncheckedUpdateInput>
  }

  /**
   * estimation_materiaux delete
   */
  export type estimation_materiauxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    /**
     * Filter which estimation_materiaux to delete.
     */
    where: estimation_materiauxWhereUniqueInput
  }

  /**
   * estimation_materiaux deleteMany
   */
  export type estimation_materiauxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimation_materiauxes to delete
     */
    where?: estimation_materiauxWhereInput
    /**
     * Limit how many estimation_materiauxes to delete.
     */
    limit?: number
  }

  /**
   * estimation_materiaux without action
   */
  export type estimation_materiauxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
  }


  /**
   * Model estimation_fiche_solution
   */

  export type AggregateEstimation_fiche_solution = {
    _count: Estimation_fiche_solutionCountAggregateOutputType | null
    _avg: Estimation_fiche_solutionAvgAggregateOutputType | null
    _sum: Estimation_fiche_solutionSumAggregateOutputType | null
    _min: Estimation_fiche_solutionMinAggregateOutputType | null
    _max: Estimation_fiche_solutionMaxAggregateOutputType | null
  }

  export type Estimation_fiche_solutionAvgAggregateOutputType = {
    estimation_id: number | null
    fiche_solution_id: number | null
    quantite: number | null
    cout_min_investissement: number | null
    cout_max_investissement: number | null
    cout_min_entretien: number | null
    cout_max_entretien: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_fiche_solutionSumAggregateOutputType = {
    estimation_id: number | null
    fiche_solution_id: number | null
    quantite: number | null
    cout_min_investissement: number | null
    cout_max_investissement: number | null
    cout_min_entretien: number | null
    cout_max_entretien: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_fiche_solutionMinAggregateOutputType = {
    id: string | null
    estimation_id: number | null
    fiche_solution_id: number | null
    quantite: number | null
    cout_min_investissement: number | null
    cout_max_investissement: number | null
    cout_min_entretien: number | null
    cout_max_entretien: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_fiche_solutionMaxAggregateOutputType = {
    id: string | null
    estimation_id: number | null
    fiche_solution_id: number | null
    quantite: number | null
    cout_min_investissement: number | null
    cout_max_investissement: number | null
    cout_min_entretien: number | null
    cout_max_entretien: number | null
    cout_investissement_override: number | null
    cout_entretien_override: number | null
  }

  export type Estimation_fiche_solutionCountAggregateOutputType = {
    id: number
    estimation_id: number
    fiche_solution_id: number
    quantite: number
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override: number
    cout_entretien_override: number
    _all: number
  }


  export type Estimation_fiche_solutionAvgAggregateInputType = {
    estimation_id?: true
    fiche_solution_id?: true
    quantite?: true
    cout_min_investissement?: true
    cout_max_investissement?: true
    cout_min_entretien?: true
    cout_max_entretien?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_fiche_solutionSumAggregateInputType = {
    estimation_id?: true
    fiche_solution_id?: true
    quantite?: true
    cout_min_investissement?: true
    cout_max_investissement?: true
    cout_min_entretien?: true
    cout_max_entretien?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_fiche_solutionMinAggregateInputType = {
    id?: true
    estimation_id?: true
    fiche_solution_id?: true
    quantite?: true
    cout_min_investissement?: true
    cout_max_investissement?: true
    cout_min_entretien?: true
    cout_max_entretien?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_fiche_solutionMaxAggregateInputType = {
    id?: true
    estimation_id?: true
    fiche_solution_id?: true
    quantite?: true
    cout_min_investissement?: true
    cout_max_investissement?: true
    cout_min_entretien?: true
    cout_max_entretien?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
  }

  export type Estimation_fiche_solutionCountAggregateInputType = {
    id?: true
    estimation_id?: true
    fiche_solution_id?: true
    quantite?: true
    cout_min_investissement?: true
    cout_max_investissement?: true
    cout_min_entretien?: true
    cout_max_entretien?: true
    cout_investissement_override?: true
    cout_entretien_override?: true
    _all?: true
  }

  export type Estimation_fiche_solutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimation_fiche_solution to aggregate.
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_fiche_solutions to fetch.
     */
    orderBy?: estimation_fiche_solutionOrderByWithRelationInput | estimation_fiche_solutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estimation_fiche_solutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_fiche_solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_fiche_solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estimation_fiche_solutions
    **/
    _count?: true | Estimation_fiche_solutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estimation_fiche_solutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estimation_fiche_solutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estimation_fiche_solutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estimation_fiche_solutionMaxAggregateInputType
  }

  export type GetEstimation_fiche_solutionAggregateType<T extends Estimation_fiche_solutionAggregateArgs> = {
        [P in keyof T & keyof AggregateEstimation_fiche_solution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstimation_fiche_solution[P]>
      : GetScalarType<T[P], AggregateEstimation_fiche_solution[P]>
  }




  export type estimation_fiche_solutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimation_fiche_solutionWhereInput
    orderBy?: estimation_fiche_solutionOrderByWithAggregationInput | estimation_fiche_solutionOrderByWithAggregationInput[]
    by: Estimation_fiche_solutionScalarFieldEnum[] | Estimation_fiche_solutionScalarFieldEnum
    having?: estimation_fiche_solutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estimation_fiche_solutionCountAggregateInputType | true
    _avg?: Estimation_fiche_solutionAvgAggregateInputType
    _sum?: Estimation_fiche_solutionSumAggregateInputType
    _min?: Estimation_fiche_solutionMinAggregateInputType
    _max?: Estimation_fiche_solutionMaxAggregateInputType
  }

  export type Estimation_fiche_solutionGroupByOutputType = {
    id: string
    estimation_id: number
    fiche_solution_id: number
    quantite: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override: number | null
    cout_entretien_override: number | null
    _count: Estimation_fiche_solutionCountAggregateOutputType | null
    _avg: Estimation_fiche_solutionAvgAggregateOutputType | null
    _sum: Estimation_fiche_solutionSumAggregateOutputType | null
    _min: Estimation_fiche_solutionMinAggregateOutputType | null
    _max: Estimation_fiche_solutionMaxAggregateOutputType | null
  }

  type GetEstimation_fiche_solutionGroupByPayload<T extends estimation_fiche_solutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estimation_fiche_solutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estimation_fiche_solutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estimation_fiche_solutionGroupByOutputType[P]>
            : GetScalarType<T[P], Estimation_fiche_solutionGroupByOutputType[P]>
        }
      >
    >


  export type estimation_fiche_solutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimation_id?: boolean
    fiche_solution_id?: boolean
    quantite?: boolean
    cout_min_investissement?: boolean
    cout_max_investissement?: boolean
    cout_min_entretien?: boolean
    cout_max_entretien?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    estimation_materiaux?: boolean | estimation_fiche_solution$estimation_materiauxArgs<ExtArgs>
    _count?: boolean | Estimation_fiche_solutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation_fiche_solution"]>

  export type estimation_fiche_solutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimation_id?: boolean
    fiche_solution_id?: boolean
    quantite?: boolean
    cout_min_investissement?: boolean
    cout_max_investissement?: boolean
    cout_min_entretien?: boolean
    cout_max_entretien?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation_fiche_solution"]>

  export type estimation_fiche_solutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estimation_id?: boolean
    fiche_solution_id?: boolean
    quantite?: boolean
    cout_min_investissement?: boolean
    cout_max_investissement?: boolean
    cout_min_entretien?: boolean
    cout_max_entretien?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estimation_fiche_solution"]>

  export type estimation_fiche_solutionSelectScalar = {
    id?: boolean
    estimation_id?: boolean
    fiche_solution_id?: boolean
    quantite?: boolean
    cout_min_investissement?: boolean
    cout_max_investissement?: boolean
    cout_min_entretien?: boolean
    cout_max_entretien?: boolean
    cout_investissement_override?: boolean
    cout_entretien_override?: boolean
  }

  export type estimation_fiche_solutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estimation_id" | "fiche_solution_id" | "quantite" | "cout_min_investissement" | "cout_max_investissement" | "cout_min_entretien" | "cout_max_entretien" | "cout_investissement_override" | "cout_entretien_override", ExtArgs["result"]["estimation_fiche_solution"]>
  export type estimation_fiche_solutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
    estimation_materiaux?: boolean | estimation_fiche_solution$estimation_materiauxArgs<ExtArgs>
    _count?: boolean | Estimation_fiche_solutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estimation_fiche_solutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
  }
  export type estimation_fiche_solutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estimation?: boolean | estimationDefaultArgs<ExtArgs>
  }

  export type $estimation_fiche_solutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estimation_fiche_solution"
    objects: {
      estimation: Prisma.$estimationPayload<ExtArgs>
      estimation_materiaux: Prisma.$estimation_materiauxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estimation_id: number
      fiche_solution_id: number
      quantite: number | null
      cout_min_investissement: number
      cout_max_investissement: number
      cout_min_entretien: number
      cout_max_entretien: number
      cout_investissement_override: number | null
      cout_entretien_override: number | null
    }, ExtArgs["result"]["estimation_fiche_solution"]>
    composites: {}
  }

  type estimation_fiche_solutionGetPayload<S extends boolean | null | undefined | estimation_fiche_solutionDefaultArgs> = $Result.GetResult<Prisma.$estimation_fiche_solutionPayload, S>

  type estimation_fiche_solutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estimation_fiche_solutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Estimation_fiche_solutionCountAggregateInputType | true
    }

  export interface estimation_fiche_solutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estimation_fiche_solution'], meta: { name: 'estimation_fiche_solution' } }
    /**
     * Find zero or one Estimation_fiche_solution that matches the filter.
     * @param {estimation_fiche_solutionFindUniqueArgs} args - Arguments to find a Estimation_fiche_solution
     * @example
     * // Get one Estimation_fiche_solution
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estimation_fiche_solutionFindUniqueArgs>(args: SelectSubset<T, estimation_fiche_solutionFindUniqueArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estimation_fiche_solution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estimation_fiche_solutionFindUniqueOrThrowArgs} args - Arguments to find a Estimation_fiche_solution
     * @example
     * // Get one Estimation_fiche_solution
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estimation_fiche_solutionFindUniqueOrThrowArgs>(args: SelectSubset<T, estimation_fiche_solutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimation_fiche_solution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_fiche_solutionFindFirstArgs} args - Arguments to find a Estimation_fiche_solution
     * @example
     * // Get one Estimation_fiche_solution
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estimation_fiche_solutionFindFirstArgs>(args?: SelectSubset<T, estimation_fiche_solutionFindFirstArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estimation_fiche_solution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_fiche_solutionFindFirstOrThrowArgs} args - Arguments to find a Estimation_fiche_solution
     * @example
     * // Get one Estimation_fiche_solution
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estimation_fiche_solutionFindFirstOrThrowArgs>(args?: SelectSubset<T, estimation_fiche_solutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estimation_fiche_solutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_fiche_solutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estimation_fiche_solutions
     * const estimation_fiche_solutions = await prisma.estimation_fiche_solution.findMany()
     * 
     * // Get first 10 Estimation_fiche_solutions
     * const estimation_fiche_solutions = await prisma.estimation_fiche_solution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estimation_fiche_solutionWithIdOnly = await prisma.estimation_fiche_solution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estimation_fiche_solutionFindManyArgs>(args?: SelectSubset<T, estimation_fiche_solutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estimation_fiche_solution.
     * @param {estimation_fiche_solutionCreateArgs} args - Arguments to create a Estimation_fiche_solution.
     * @example
     * // Create one Estimation_fiche_solution
     * const Estimation_fiche_solution = await prisma.estimation_fiche_solution.create({
     *   data: {
     *     // ... data to create a Estimation_fiche_solution
     *   }
     * })
     * 
     */
    create<T extends estimation_fiche_solutionCreateArgs>(args: SelectSubset<T, estimation_fiche_solutionCreateArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estimation_fiche_solutions.
     * @param {estimation_fiche_solutionCreateManyArgs} args - Arguments to create many Estimation_fiche_solutions.
     * @example
     * // Create many Estimation_fiche_solutions
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estimation_fiche_solutionCreateManyArgs>(args?: SelectSubset<T, estimation_fiche_solutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estimation_fiche_solutions and returns the data saved in the database.
     * @param {estimation_fiche_solutionCreateManyAndReturnArgs} args - Arguments to create many Estimation_fiche_solutions.
     * @example
     * // Create many Estimation_fiche_solutions
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estimation_fiche_solutions and only return the `id`
     * const estimation_fiche_solutionWithIdOnly = await prisma.estimation_fiche_solution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estimation_fiche_solutionCreateManyAndReturnArgs>(args?: SelectSubset<T, estimation_fiche_solutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estimation_fiche_solution.
     * @param {estimation_fiche_solutionDeleteArgs} args - Arguments to delete one Estimation_fiche_solution.
     * @example
     * // Delete one Estimation_fiche_solution
     * const Estimation_fiche_solution = await prisma.estimation_fiche_solution.delete({
     *   where: {
     *     // ... filter to delete one Estimation_fiche_solution
     *   }
     * })
     * 
     */
    delete<T extends estimation_fiche_solutionDeleteArgs>(args: SelectSubset<T, estimation_fiche_solutionDeleteArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estimation_fiche_solution.
     * @param {estimation_fiche_solutionUpdateArgs} args - Arguments to update one Estimation_fiche_solution.
     * @example
     * // Update one Estimation_fiche_solution
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estimation_fiche_solutionUpdateArgs>(args: SelectSubset<T, estimation_fiche_solutionUpdateArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estimation_fiche_solutions.
     * @param {estimation_fiche_solutionDeleteManyArgs} args - Arguments to filter Estimation_fiche_solutions to delete.
     * @example
     * // Delete a few Estimation_fiche_solutions
     * const { count } = await prisma.estimation_fiche_solution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estimation_fiche_solutionDeleteManyArgs>(args?: SelectSubset<T, estimation_fiche_solutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimation_fiche_solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_fiche_solutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estimation_fiche_solutions
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estimation_fiche_solutionUpdateManyArgs>(args: SelectSubset<T, estimation_fiche_solutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimation_fiche_solutions and returns the data updated in the database.
     * @param {estimation_fiche_solutionUpdateManyAndReturnArgs} args - Arguments to update many Estimation_fiche_solutions.
     * @example
     * // Update many Estimation_fiche_solutions
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estimation_fiche_solutions and only return the `id`
     * const estimation_fiche_solutionWithIdOnly = await prisma.estimation_fiche_solution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estimation_fiche_solutionUpdateManyAndReturnArgs>(args: SelectSubset<T, estimation_fiche_solutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estimation_fiche_solution.
     * @param {estimation_fiche_solutionUpsertArgs} args - Arguments to update or create a Estimation_fiche_solution.
     * @example
     * // Update or create a Estimation_fiche_solution
     * const estimation_fiche_solution = await prisma.estimation_fiche_solution.upsert({
     *   create: {
     *     // ... data to create a Estimation_fiche_solution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estimation_fiche_solution we want to update
     *   }
     * })
     */
    upsert<T extends estimation_fiche_solutionUpsertArgs>(args: SelectSubset<T, estimation_fiche_solutionUpsertArgs<ExtArgs>>): Prisma__estimation_fiche_solutionClient<$Result.GetResult<Prisma.$estimation_fiche_solutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estimation_fiche_solutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_fiche_solutionCountArgs} args - Arguments to filter Estimation_fiche_solutions to count.
     * @example
     * // Count the number of Estimation_fiche_solutions
     * const count = await prisma.estimation_fiche_solution.count({
     *   where: {
     *     // ... the filter for the Estimation_fiche_solutions we want to count
     *   }
     * })
    **/
    count<T extends estimation_fiche_solutionCountArgs>(
      args?: Subset<T, estimation_fiche_solutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estimation_fiche_solutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estimation_fiche_solution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estimation_fiche_solutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estimation_fiche_solutionAggregateArgs>(args: Subset<T, Estimation_fiche_solutionAggregateArgs>): Prisma.PrismaPromise<GetEstimation_fiche_solutionAggregateType<T>>

    /**
     * Group by Estimation_fiche_solution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimation_fiche_solutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estimation_fiche_solutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estimation_fiche_solutionGroupByArgs['orderBy'] }
        : { orderBy?: estimation_fiche_solutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estimation_fiche_solutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstimation_fiche_solutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estimation_fiche_solution model
   */
  readonly fields: estimation_fiche_solutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estimation_fiche_solution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estimation_fiche_solutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estimation<T extends estimationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estimationDefaultArgs<ExtArgs>>): Prisma__estimationClient<$Result.GetResult<Prisma.$estimationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estimation_materiaux<T extends estimation_fiche_solution$estimation_materiauxArgs<ExtArgs> = {}>(args?: Subset<T, estimation_fiche_solution$estimation_materiauxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimation_materiauxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estimation_fiche_solution model
   */
  interface estimation_fiche_solutionFieldRefs {
    readonly id: FieldRef<"estimation_fiche_solution", 'String'>
    readonly estimation_id: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly fiche_solution_id: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly quantite: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly cout_min_investissement: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly cout_max_investissement: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly cout_min_entretien: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly cout_max_entretien: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly cout_investissement_override: FieldRef<"estimation_fiche_solution", 'Int'>
    readonly cout_entretien_override: FieldRef<"estimation_fiche_solution", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * estimation_fiche_solution findUnique
   */
  export type estimation_fiche_solutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * Filter, which estimation_fiche_solution to fetch.
     */
    where: estimation_fiche_solutionWhereUniqueInput
  }

  /**
   * estimation_fiche_solution findUniqueOrThrow
   */
  export type estimation_fiche_solutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * Filter, which estimation_fiche_solution to fetch.
     */
    where: estimation_fiche_solutionWhereUniqueInput
  }

  /**
   * estimation_fiche_solution findFirst
   */
  export type estimation_fiche_solutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * Filter, which estimation_fiche_solution to fetch.
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_fiche_solutions to fetch.
     */
    orderBy?: estimation_fiche_solutionOrderByWithRelationInput | estimation_fiche_solutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimation_fiche_solutions.
     */
    cursor?: estimation_fiche_solutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_fiche_solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_fiche_solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimation_fiche_solutions.
     */
    distinct?: Estimation_fiche_solutionScalarFieldEnum | Estimation_fiche_solutionScalarFieldEnum[]
  }

  /**
   * estimation_fiche_solution findFirstOrThrow
   */
  export type estimation_fiche_solutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * Filter, which estimation_fiche_solution to fetch.
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_fiche_solutions to fetch.
     */
    orderBy?: estimation_fiche_solutionOrderByWithRelationInput | estimation_fiche_solutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimation_fiche_solutions.
     */
    cursor?: estimation_fiche_solutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_fiche_solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_fiche_solutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimation_fiche_solutions.
     */
    distinct?: Estimation_fiche_solutionScalarFieldEnum | Estimation_fiche_solutionScalarFieldEnum[]
  }

  /**
   * estimation_fiche_solution findMany
   */
  export type estimation_fiche_solutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * Filter, which estimation_fiche_solutions to fetch.
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimation_fiche_solutions to fetch.
     */
    orderBy?: estimation_fiche_solutionOrderByWithRelationInput | estimation_fiche_solutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estimation_fiche_solutions.
     */
    cursor?: estimation_fiche_solutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimation_fiche_solutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimation_fiche_solutions.
     */
    skip?: number
    distinct?: Estimation_fiche_solutionScalarFieldEnum | Estimation_fiche_solutionScalarFieldEnum[]
  }

  /**
   * estimation_fiche_solution create
   */
  export type estimation_fiche_solutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * The data needed to create a estimation_fiche_solution.
     */
    data: XOR<estimation_fiche_solutionCreateInput, estimation_fiche_solutionUncheckedCreateInput>
  }

  /**
   * estimation_fiche_solution createMany
   */
  export type estimation_fiche_solutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estimation_fiche_solutions.
     */
    data: estimation_fiche_solutionCreateManyInput | estimation_fiche_solutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estimation_fiche_solution createManyAndReturn
   */
  export type estimation_fiche_solutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * The data used to create many estimation_fiche_solutions.
     */
    data: estimation_fiche_solutionCreateManyInput | estimation_fiche_solutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimation_fiche_solution update
   */
  export type estimation_fiche_solutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * The data needed to update a estimation_fiche_solution.
     */
    data: XOR<estimation_fiche_solutionUpdateInput, estimation_fiche_solutionUncheckedUpdateInput>
    /**
     * Choose, which estimation_fiche_solution to update.
     */
    where: estimation_fiche_solutionWhereUniqueInput
  }

  /**
   * estimation_fiche_solution updateMany
   */
  export type estimation_fiche_solutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estimation_fiche_solutions.
     */
    data: XOR<estimation_fiche_solutionUpdateManyMutationInput, estimation_fiche_solutionUncheckedUpdateManyInput>
    /**
     * Filter which estimation_fiche_solutions to update
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * Limit how many estimation_fiche_solutions to update.
     */
    limit?: number
  }

  /**
   * estimation_fiche_solution updateManyAndReturn
   */
  export type estimation_fiche_solutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * The data used to update estimation_fiche_solutions.
     */
    data: XOR<estimation_fiche_solutionUpdateManyMutationInput, estimation_fiche_solutionUncheckedUpdateManyInput>
    /**
     * Filter which estimation_fiche_solutions to update
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * Limit how many estimation_fiche_solutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * estimation_fiche_solution upsert
   */
  export type estimation_fiche_solutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * The filter to search for the estimation_fiche_solution to update in case it exists.
     */
    where: estimation_fiche_solutionWhereUniqueInput
    /**
     * In case the estimation_fiche_solution found by the `where` argument doesn't exist, create a new estimation_fiche_solution with this data.
     */
    create: XOR<estimation_fiche_solutionCreateInput, estimation_fiche_solutionUncheckedCreateInput>
    /**
     * In case the estimation_fiche_solution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estimation_fiche_solutionUpdateInput, estimation_fiche_solutionUncheckedUpdateInput>
  }

  /**
   * estimation_fiche_solution delete
   */
  export type estimation_fiche_solutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
    /**
     * Filter which estimation_fiche_solution to delete.
     */
    where: estimation_fiche_solutionWhereUniqueInput
  }

  /**
   * estimation_fiche_solution deleteMany
   */
  export type estimation_fiche_solutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimation_fiche_solutions to delete
     */
    where?: estimation_fiche_solutionWhereInput
    /**
     * Limit how many estimation_fiche_solutions to delete.
     */
    limit?: number
  }

  /**
   * estimation_fiche_solution.estimation_materiaux
   */
  export type estimation_fiche_solution$estimation_materiauxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_materiaux
     */
    select?: estimation_materiauxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_materiaux
     */
    omit?: estimation_materiauxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_materiauxInclude<ExtArgs> | null
    where?: estimation_materiauxWhereInput
    orderBy?: estimation_materiauxOrderByWithRelationInput | estimation_materiauxOrderByWithRelationInput[]
    cursor?: estimation_materiauxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Estimation_materiauxScalarFieldEnum | Estimation_materiauxScalarFieldEnum[]
  }

  /**
   * estimation_fiche_solution without action
   */
  export type estimation_fiche_solutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimation_fiche_solution
     */
    select?: estimation_fiche_solutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estimation_fiche_solution
     */
    omit?: estimation_fiche_solutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estimation_fiche_solutionInclude<ExtArgs> | null
  }


  /**
   * Model conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ragtimeId: string | null
    created_at: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ragtimeId: string | null
    created_at: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    ragtimeId: number
    created_at: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    ragtimeId?: true
    created_at?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    ragtimeId?: true
    created_at?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    ragtimeId?: true
    created_at?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversation to aggregate.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type conversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationWhereInput
    orderBy?: conversationOrderByWithAggregationInput | conversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: conversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: string | null
    ragtimeId: string
    created_at: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends conversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type conversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ragtimeId?: boolean
    created_at?: boolean
    user?: boolean | conversation$userArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ragtimeId?: boolean
    created_at?: boolean
    user?: boolean | conversation$userArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ragtimeId?: boolean
    created_at?: boolean
    user?: boolean | conversation$userArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type conversationSelectScalar = {
    id?: boolean
    userId?: boolean
    ragtimeId?: boolean
    created_at?: boolean
  }

  export type conversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "ragtimeId" | "created_at", ExtArgs["result"]["conversation"]>
  export type conversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | conversation$userArgs<ExtArgs>
  }
  export type conversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | conversation$userArgs<ExtArgs>
  }
  export type conversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | conversation$userArgs<ExtArgs>
  }

  export type $conversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      ragtimeId: string
      created_at: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type conversationGetPayload<S extends boolean | null | undefined | conversationDefaultArgs> = $Result.GetResult<Prisma.$conversationPayload, S>

  type conversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface conversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversation'], meta: { name: 'conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {conversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationFindUniqueArgs>(args: SelectSubset<T, conversationFindUniqueArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationFindFirstArgs>(args?: SelectSubset<T, conversationFindFirstArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationFindManyArgs>(args?: SelectSubset<T, conversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {conversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends conversationCreateArgs>(args: SelectSubset<T, conversationCreateArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {conversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationCreateManyArgs>(args?: SelectSubset<T, conversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {conversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {conversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends conversationDeleteArgs>(args: SelectSubset<T, conversationDeleteArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {conversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationUpdateArgs>(args: SelectSubset<T, conversationUpdateArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {conversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationDeleteManyArgs>(args?: SelectSubset<T, conversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationUpdateManyArgs>(args: SelectSubset<T, conversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {conversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conversationUpdateManyAndReturnArgs>(args: SelectSubset<T, conversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {conversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends conversationUpsertArgs>(args: SelectSubset<T, conversationUpsertArgs<ExtArgs>>): Prisma__conversationClient<$Result.GetResult<Prisma.$conversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationCountArgs>(
      args?: Subset<T, conversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationGroupByArgs['orderBy'] }
        : { orderBy?: conversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversation model
   */
  readonly fields: conversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends conversation$userArgs<ExtArgs> = {}>(args?: Subset<T, conversation$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversation model
   */
  interface conversationFieldRefs {
    readonly id: FieldRef<"conversation", 'String'>
    readonly userId: FieldRef<"conversation", 'String'>
    readonly ragtimeId: FieldRef<"conversation", 'String'>
    readonly created_at: FieldRef<"conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversation findUnique
   */
  export type conversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation findUniqueOrThrow
   */
  export type conversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation findFirst
   */
  export type conversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation findFirstOrThrow
   */
  export type conversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversation to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation findMany
   */
  export type conversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationOrderByWithRelationInput | conversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * conversation create
   */
  export type conversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The data needed to create a conversation.
     */
    data: XOR<conversationCreateInput, conversationUncheckedCreateInput>
  }

  /**
   * conversation createMany
   */
  export type conversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationCreateManyInput | conversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversation createManyAndReturn
   */
  export type conversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * The data used to create many conversations.
     */
    data: conversationCreateManyInput | conversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversation update
   */
  export type conversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The data needed to update a conversation.
     */
    data: XOR<conversationUpdateInput, conversationUncheckedUpdateInput>
    /**
     * Choose, which conversation to update.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation updateMany
   */
  export type conversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to update.
     */
    limit?: number
  }

  /**
   * conversation updateManyAndReturn
   */
  export type conversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * conversation upsert
   */
  export type conversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * The filter to search for the conversation to update in case it exists.
     */
    where: conversationWhereUniqueInput
    /**
     * In case the conversation found by the `where` argument doesn't exist, create a new conversation with this data.
     */
    create: XOR<conversationCreateInput, conversationUncheckedCreateInput>
    /**
     * In case the conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationUpdateInput, conversationUncheckedUpdateInput>
  }

  /**
   * conversation delete
   */
  export type conversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
    /**
     * Filter which conversation to delete.
     */
    where: conversationWhereUniqueInput
  }

  /**
   * conversation deleteMany
   */
  export type conversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationWhereInput
    /**
     * Limit how many conversations to delete.
     */
    limit?: number
  }

  /**
   * conversation.user
   */
  export type conversation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * conversation without action
   */
  export type conversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversation
     */
    select?: conversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversation
     */
    omit?: conversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conversationInclude<ExtArgs> | null
  }


  /**
   * Model diagnostic_simulation
   */

  export type AggregateDiagnostic_simulation = {
    _count: Diagnostic_simulationCountAggregateOutputType | null
    _avg: Diagnostic_simulationAvgAggregateOutputType | null
    _sum: Diagnostic_simulationSumAggregateOutputType | null
    _min: Diagnostic_simulationMinAggregateOutputType | null
    _max: Diagnostic_simulationMaxAggregateOutputType | null
  }

  export type Diagnostic_simulationAvgAggregateOutputType = {
    projet_id: number | null
  }

  export type Diagnostic_simulationSumAggregateOutputType = {
    projet_id: number | null
  }

  export type Diagnostic_simulationMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    projet_id: number | null
    validated: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Diagnostic_simulationMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    projet_id: number | null
    validated: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Diagnostic_simulationCountAggregateOutputType = {
    id: number
    user_id: number
    projet_id: number
    initial_values: number
    validated: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Diagnostic_simulationAvgAggregateInputType = {
    projet_id?: true
  }

  export type Diagnostic_simulationSumAggregateInputType = {
    projet_id?: true
  }

  export type Diagnostic_simulationMinAggregateInputType = {
    id?: true
    user_id?: true
    projet_id?: true
    validated?: true
    created_at?: true
    updated_at?: true
  }

  export type Diagnostic_simulationMaxAggregateInputType = {
    id?: true
    user_id?: true
    projet_id?: true
    validated?: true
    created_at?: true
    updated_at?: true
  }

  export type Diagnostic_simulationCountAggregateInputType = {
    id?: true
    user_id?: true
    projet_id?: true
    initial_values?: true
    validated?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Diagnostic_simulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnostic_simulation to aggregate.
     */
    where?: diagnostic_simulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnostic_simulations to fetch.
     */
    orderBy?: diagnostic_simulationOrderByWithRelationInput | diagnostic_simulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diagnostic_simulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnostic_simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnostic_simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diagnostic_simulations
    **/
    _count?: true | Diagnostic_simulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Diagnostic_simulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Diagnostic_simulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Diagnostic_simulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Diagnostic_simulationMaxAggregateInputType
  }

  export type GetDiagnostic_simulationAggregateType<T extends Diagnostic_simulationAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnostic_simulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnostic_simulation[P]>
      : GetScalarType<T[P], AggregateDiagnostic_simulation[P]>
  }




  export type diagnostic_simulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: diagnostic_simulationWhereInput
    orderBy?: diagnostic_simulationOrderByWithAggregationInput | diagnostic_simulationOrderByWithAggregationInput[]
    by: Diagnostic_simulationScalarFieldEnum[] | Diagnostic_simulationScalarFieldEnum
    having?: diagnostic_simulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Diagnostic_simulationCountAggregateInputType | true
    _avg?: Diagnostic_simulationAvgAggregateInputType
    _sum?: Diagnostic_simulationSumAggregateInputType
    _min?: Diagnostic_simulationMinAggregateInputType
    _max?: Diagnostic_simulationMaxAggregateInputType
  }

  export type Diagnostic_simulationGroupByOutputType = {
    id: string
    user_id: string | null
    projet_id: number
    initial_values: JsonValue | null
    validated: boolean
    created_at: Date
    updated_at: Date
    _count: Diagnostic_simulationCountAggregateOutputType | null
    _avg: Diagnostic_simulationAvgAggregateOutputType | null
    _sum: Diagnostic_simulationSumAggregateOutputType | null
    _min: Diagnostic_simulationMinAggregateOutputType | null
    _max: Diagnostic_simulationMaxAggregateOutputType | null
  }

  type GetDiagnostic_simulationGroupByPayload<T extends diagnostic_simulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Diagnostic_simulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Diagnostic_simulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Diagnostic_simulationGroupByOutputType[P]>
            : GetScalarType<T[P], Diagnostic_simulationGroupByOutputType[P]>
        }
      >
    >


  export type diagnostic_simulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    projet_id?: boolean
    initial_values?: boolean
    validated?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | diagnostic_simulation$userArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostic_simulation"]>

  export type diagnostic_simulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    projet_id?: boolean
    initial_values?: boolean
    validated?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | diagnostic_simulation$userArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostic_simulation"]>

  export type diagnostic_simulationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    projet_id?: boolean
    initial_values?: boolean
    validated?: boolean
    created_at?: boolean
    updated_at?: boolean
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | diagnostic_simulation$userArgs<ExtArgs>
  }, ExtArgs["result"]["diagnostic_simulation"]>

  export type diagnostic_simulationSelectScalar = {
    id?: boolean
    user_id?: boolean
    projet_id?: boolean
    initial_values?: boolean
    validated?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type diagnostic_simulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "projet_id" | "initial_values" | "validated" | "created_at" | "updated_at", ExtArgs["result"]["diagnostic_simulation"]>
  export type diagnostic_simulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | diagnostic_simulation$userArgs<ExtArgs>
  }
  export type diagnostic_simulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | diagnostic_simulation$userArgs<ExtArgs>
  }
  export type diagnostic_simulationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projet?: boolean | projetDefaultArgs<ExtArgs>
    user?: boolean | diagnostic_simulation$userArgs<ExtArgs>
  }

  export type $diagnostic_simulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diagnostic_simulation"
    objects: {
      projet: Prisma.$projetPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      projet_id: number
      initial_values: Prisma.JsonValue | null
      validated: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["diagnostic_simulation"]>
    composites: {}
  }

  type diagnostic_simulationGetPayload<S extends boolean | null | undefined | diagnostic_simulationDefaultArgs> = $Result.GetResult<Prisma.$diagnostic_simulationPayload, S>

  type diagnostic_simulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<diagnostic_simulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Diagnostic_simulationCountAggregateInputType | true
    }

  export interface diagnostic_simulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diagnostic_simulation'], meta: { name: 'diagnostic_simulation' } }
    /**
     * Find zero or one Diagnostic_simulation that matches the filter.
     * @param {diagnostic_simulationFindUniqueArgs} args - Arguments to find a Diagnostic_simulation
     * @example
     * // Get one Diagnostic_simulation
     * const diagnostic_simulation = await prisma.diagnostic_simulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends diagnostic_simulationFindUniqueArgs>(args: SelectSubset<T, diagnostic_simulationFindUniqueArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diagnostic_simulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {diagnostic_simulationFindUniqueOrThrowArgs} args - Arguments to find a Diagnostic_simulation
     * @example
     * // Get one Diagnostic_simulation
     * const diagnostic_simulation = await prisma.diagnostic_simulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends diagnostic_simulationFindUniqueOrThrowArgs>(args: SelectSubset<T, diagnostic_simulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnostic_simulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnostic_simulationFindFirstArgs} args - Arguments to find a Diagnostic_simulation
     * @example
     * // Get one Diagnostic_simulation
     * const diagnostic_simulation = await prisma.diagnostic_simulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends diagnostic_simulationFindFirstArgs>(args?: SelectSubset<T, diagnostic_simulationFindFirstArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diagnostic_simulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnostic_simulationFindFirstOrThrowArgs} args - Arguments to find a Diagnostic_simulation
     * @example
     * // Get one Diagnostic_simulation
     * const diagnostic_simulation = await prisma.diagnostic_simulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends diagnostic_simulationFindFirstOrThrowArgs>(args?: SelectSubset<T, diagnostic_simulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diagnostic_simulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnostic_simulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnostic_simulations
     * const diagnostic_simulations = await prisma.diagnostic_simulation.findMany()
     * 
     * // Get first 10 Diagnostic_simulations
     * const diagnostic_simulations = await prisma.diagnostic_simulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnostic_simulationWithIdOnly = await prisma.diagnostic_simulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends diagnostic_simulationFindManyArgs>(args?: SelectSubset<T, diagnostic_simulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diagnostic_simulation.
     * @param {diagnostic_simulationCreateArgs} args - Arguments to create a Diagnostic_simulation.
     * @example
     * // Create one Diagnostic_simulation
     * const Diagnostic_simulation = await prisma.diagnostic_simulation.create({
     *   data: {
     *     // ... data to create a Diagnostic_simulation
     *   }
     * })
     * 
     */
    create<T extends diagnostic_simulationCreateArgs>(args: SelectSubset<T, diagnostic_simulationCreateArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diagnostic_simulations.
     * @param {diagnostic_simulationCreateManyArgs} args - Arguments to create many Diagnostic_simulations.
     * @example
     * // Create many Diagnostic_simulations
     * const diagnostic_simulation = await prisma.diagnostic_simulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends diagnostic_simulationCreateManyArgs>(args?: SelectSubset<T, diagnostic_simulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnostic_simulations and returns the data saved in the database.
     * @param {diagnostic_simulationCreateManyAndReturnArgs} args - Arguments to create many Diagnostic_simulations.
     * @example
     * // Create many Diagnostic_simulations
     * const diagnostic_simulation = await prisma.diagnostic_simulation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnostic_simulations and only return the `id`
     * const diagnostic_simulationWithIdOnly = await prisma.diagnostic_simulation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends diagnostic_simulationCreateManyAndReturnArgs>(args?: SelectSubset<T, diagnostic_simulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Diagnostic_simulation.
     * @param {diagnostic_simulationDeleteArgs} args - Arguments to delete one Diagnostic_simulation.
     * @example
     * // Delete one Diagnostic_simulation
     * const Diagnostic_simulation = await prisma.diagnostic_simulation.delete({
     *   where: {
     *     // ... filter to delete one Diagnostic_simulation
     *   }
     * })
     * 
     */
    delete<T extends diagnostic_simulationDeleteArgs>(args: SelectSubset<T, diagnostic_simulationDeleteArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diagnostic_simulation.
     * @param {diagnostic_simulationUpdateArgs} args - Arguments to update one Diagnostic_simulation.
     * @example
     * // Update one Diagnostic_simulation
     * const diagnostic_simulation = await prisma.diagnostic_simulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends diagnostic_simulationUpdateArgs>(args: SelectSubset<T, diagnostic_simulationUpdateArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diagnostic_simulations.
     * @param {diagnostic_simulationDeleteManyArgs} args - Arguments to filter Diagnostic_simulations to delete.
     * @example
     * // Delete a few Diagnostic_simulations
     * const { count } = await prisma.diagnostic_simulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends diagnostic_simulationDeleteManyArgs>(args?: SelectSubset<T, diagnostic_simulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnostic_simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnostic_simulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnostic_simulations
     * const diagnostic_simulation = await prisma.diagnostic_simulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends diagnostic_simulationUpdateManyArgs>(args: SelectSubset<T, diagnostic_simulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnostic_simulations and returns the data updated in the database.
     * @param {diagnostic_simulationUpdateManyAndReturnArgs} args - Arguments to update many Diagnostic_simulations.
     * @example
     * // Update many Diagnostic_simulations
     * const diagnostic_simulation = await prisma.diagnostic_simulation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diagnostic_simulations and only return the `id`
     * const diagnostic_simulationWithIdOnly = await prisma.diagnostic_simulation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends diagnostic_simulationUpdateManyAndReturnArgs>(args: SelectSubset<T, diagnostic_simulationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Diagnostic_simulation.
     * @param {diagnostic_simulationUpsertArgs} args - Arguments to update or create a Diagnostic_simulation.
     * @example
     * // Update or create a Diagnostic_simulation
     * const diagnostic_simulation = await prisma.diagnostic_simulation.upsert({
     *   create: {
     *     // ... data to create a Diagnostic_simulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnostic_simulation we want to update
     *   }
     * })
     */
    upsert<T extends diagnostic_simulationUpsertArgs>(args: SelectSubset<T, diagnostic_simulationUpsertArgs<ExtArgs>>): Prisma__diagnostic_simulationClient<$Result.GetResult<Prisma.$diagnostic_simulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diagnostic_simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnostic_simulationCountArgs} args - Arguments to filter Diagnostic_simulations to count.
     * @example
     * // Count the number of Diagnostic_simulations
     * const count = await prisma.diagnostic_simulation.count({
     *   where: {
     *     // ... the filter for the Diagnostic_simulations we want to count
     *   }
     * })
    **/
    count<T extends diagnostic_simulationCountArgs>(
      args?: Subset<T, diagnostic_simulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Diagnostic_simulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnostic_simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Diagnostic_simulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Diagnostic_simulationAggregateArgs>(args: Subset<T, Diagnostic_simulationAggregateArgs>): Prisma.PrismaPromise<GetDiagnostic_simulationAggregateType<T>>

    /**
     * Group by Diagnostic_simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diagnostic_simulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends diagnostic_simulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: diagnostic_simulationGroupByArgs['orderBy'] }
        : { orderBy?: diagnostic_simulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, diagnostic_simulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnostic_simulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diagnostic_simulation model
   */
  readonly fields: diagnostic_simulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diagnostic_simulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__diagnostic_simulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projet<T extends projetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetDefaultArgs<ExtArgs>>): Prisma__projetClient<$Result.GetResult<Prisma.$projetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends diagnostic_simulation$userArgs<ExtArgs> = {}>(args?: Subset<T, diagnostic_simulation$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the diagnostic_simulation model
   */
  interface diagnostic_simulationFieldRefs {
    readonly id: FieldRef<"diagnostic_simulation", 'String'>
    readonly user_id: FieldRef<"diagnostic_simulation", 'String'>
    readonly projet_id: FieldRef<"diagnostic_simulation", 'Int'>
    readonly initial_values: FieldRef<"diagnostic_simulation", 'Json'>
    readonly validated: FieldRef<"diagnostic_simulation", 'Boolean'>
    readonly created_at: FieldRef<"diagnostic_simulation", 'DateTime'>
    readonly updated_at: FieldRef<"diagnostic_simulation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * diagnostic_simulation findUnique
   */
  export type diagnostic_simulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * Filter, which diagnostic_simulation to fetch.
     */
    where: diagnostic_simulationWhereUniqueInput
  }

  /**
   * diagnostic_simulation findUniqueOrThrow
   */
  export type diagnostic_simulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * Filter, which diagnostic_simulation to fetch.
     */
    where: diagnostic_simulationWhereUniqueInput
  }

  /**
   * diagnostic_simulation findFirst
   */
  export type diagnostic_simulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * Filter, which diagnostic_simulation to fetch.
     */
    where?: diagnostic_simulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnostic_simulations to fetch.
     */
    orderBy?: diagnostic_simulationOrderByWithRelationInput | diagnostic_simulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnostic_simulations.
     */
    cursor?: diagnostic_simulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnostic_simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnostic_simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnostic_simulations.
     */
    distinct?: Diagnostic_simulationScalarFieldEnum | Diagnostic_simulationScalarFieldEnum[]
  }

  /**
   * diagnostic_simulation findFirstOrThrow
   */
  export type diagnostic_simulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * Filter, which diagnostic_simulation to fetch.
     */
    where?: diagnostic_simulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnostic_simulations to fetch.
     */
    orderBy?: diagnostic_simulationOrderByWithRelationInput | diagnostic_simulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diagnostic_simulations.
     */
    cursor?: diagnostic_simulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnostic_simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnostic_simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diagnostic_simulations.
     */
    distinct?: Diagnostic_simulationScalarFieldEnum | Diagnostic_simulationScalarFieldEnum[]
  }

  /**
   * diagnostic_simulation findMany
   */
  export type diagnostic_simulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * Filter, which diagnostic_simulations to fetch.
     */
    where?: diagnostic_simulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diagnostic_simulations to fetch.
     */
    orderBy?: diagnostic_simulationOrderByWithRelationInput | diagnostic_simulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diagnostic_simulations.
     */
    cursor?: diagnostic_simulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diagnostic_simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diagnostic_simulations.
     */
    skip?: number
    distinct?: Diagnostic_simulationScalarFieldEnum | Diagnostic_simulationScalarFieldEnum[]
  }

  /**
   * diagnostic_simulation create
   */
  export type diagnostic_simulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * The data needed to create a diagnostic_simulation.
     */
    data: XOR<diagnostic_simulationCreateInput, diagnostic_simulationUncheckedCreateInput>
  }

  /**
   * diagnostic_simulation createMany
   */
  export type diagnostic_simulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diagnostic_simulations.
     */
    data: diagnostic_simulationCreateManyInput | diagnostic_simulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diagnostic_simulation createManyAndReturn
   */
  export type diagnostic_simulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * The data used to create many diagnostic_simulations.
     */
    data: diagnostic_simulationCreateManyInput | diagnostic_simulationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnostic_simulation update
   */
  export type diagnostic_simulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * The data needed to update a diagnostic_simulation.
     */
    data: XOR<diagnostic_simulationUpdateInput, diagnostic_simulationUncheckedUpdateInput>
    /**
     * Choose, which diagnostic_simulation to update.
     */
    where: diagnostic_simulationWhereUniqueInput
  }

  /**
   * diagnostic_simulation updateMany
   */
  export type diagnostic_simulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diagnostic_simulations.
     */
    data: XOR<diagnostic_simulationUpdateManyMutationInput, diagnostic_simulationUncheckedUpdateManyInput>
    /**
     * Filter which diagnostic_simulations to update
     */
    where?: diagnostic_simulationWhereInput
    /**
     * Limit how many diagnostic_simulations to update.
     */
    limit?: number
  }

  /**
   * diagnostic_simulation updateManyAndReturn
   */
  export type diagnostic_simulationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * The data used to update diagnostic_simulations.
     */
    data: XOR<diagnostic_simulationUpdateManyMutationInput, diagnostic_simulationUncheckedUpdateManyInput>
    /**
     * Filter which diagnostic_simulations to update
     */
    where?: diagnostic_simulationWhereInput
    /**
     * Limit how many diagnostic_simulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * diagnostic_simulation upsert
   */
  export type diagnostic_simulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * The filter to search for the diagnostic_simulation to update in case it exists.
     */
    where: diagnostic_simulationWhereUniqueInput
    /**
     * In case the diagnostic_simulation found by the `where` argument doesn't exist, create a new diagnostic_simulation with this data.
     */
    create: XOR<diagnostic_simulationCreateInput, diagnostic_simulationUncheckedCreateInput>
    /**
     * In case the diagnostic_simulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diagnostic_simulationUpdateInput, diagnostic_simulationUncheckedUpdateInput>
  }

  /**
   * diagnostic_simulation delete
   */
  export type diagnostic_simulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
    /**
     * Filter which diagnostic_simulation to delete.
     */
    where: diagnostic_simulationWhereUniqueInput
  }

  /**
   * diagnostic_simulation deleteMany
   */
  export type diagnostic_simulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diagnostic_simulations to delete
     */
    where?: diagnostic_simulationWhereInput
    /**
     * Limit how many diagnostic_simulations to delete.
     */
    limit?: number
  }

  /**
   * diagnostic_simulation.user
   */
  export type diagnostic_simulation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * diagnostic_simulation without action
   */
  export type diagnostic_simulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diagnostic_simulation
     */
    select?: diagnostic_simulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diagnostic_simulation
     */
    omit?: diagnostic_simulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: diagnostic_simulationInclude<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    reference_id: string | null
    reference_type: $Enums.ReferenceType | null
    event_type: $Enums.EventType | null
    user_id: string | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    reference_id: string | null
    reference_type: $Enums.ReferenceType | null
    event_type: $Enums.EventType | null
    user_id: string | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    created_at: number
    reference_id: number
    reference_type: number
    event_type: number
    context: number
    user_id: number
    _all: number
  }


  export type AnalyticsMinAggregateInputType = {
    id?: true
    created_at?: true
    reference_id?: true
    reference_type?: true
    event_type?: true
    user_id?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    created_at?: true
    reference_id?: true
    reference_type?: true
    event_type?: true
    user_id?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    created_at?: true
    reference_id?: true
    reference_type?: true
    event_type?: true
    context?: true
    user_id?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    created_at: Date
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context: JsonValue | null
    user_id: string
    _count: AnalyticsCountAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    reference_id?: boolean
    reference_type?: boolean
    event_type?: boolean
    context?: boolean
    user_id?: boolean
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    reference_id?: boolean
    reference_type?: boolean
    event_type?: boolean
    context?: boolean
    user_id?: boolean
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    reference_id?: boolean
    reference_type?: boolean
    event_type?: boolean
    context?: boolean
    user_id?: boolean
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    created_at?: boolean
    reference_id?: boolean
    reference_type?: boolean
    event_type?: boolean
    context?: boolean
    user_id?: boolean
  }

  export type AnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "reference_id" | "reference_type" | "event_type" | "context" | "user_id", ExtArgs["result"]["analytics"]>
  export type AnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    created_by?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {
      created_by: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      reference_id: string
      reference_type: $Enums.ReferenceType
      event_type: $Enums.EventType
      context: Prisma.JsonValue | null
      user_id: string
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics and returns the data updated in the database.
     * @param {AnalyticsUpdateManyAndReturnArgs} args - Arguments to update many Analytics.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    created_by<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly created_at: FieldRef<"Analytics", 'DateTime'>
    readonly reference_id: FieldRef<"Analytics", 'String'>
    readonly reference_type: FieldRef<"Analytics", 'ReferenceType'>
    readonly event_type: FieldRef<"Analytics", 'EventType'>
    readonly context: FieldRef<"Analytics", 'Json'>
    readonly user_id: FieldRef<"Analytics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics updateManyAndReturn
   */
  export type AnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to delete.
     */
    limit?: number
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model cron_jobs
   */

  export type AggregateCron_jobs = {
    _count: Cron_jobsCountAggregateOutputType | null
    _min: Cron_jobsMinAggregateOutputType | null
    _max: Cron_jobsMaxAggregateOutputType | null
  }

  export type Cron_jobsMinAggregateOutputType = {
    id: string | null
    execution_start_time: Date | null
    execution_end_time: Date | null
    job_type: $Enums.JobType | null
  }

  export type Cron_jobsMaxAggregateOutputType = {
    id: string | null
    execution_start_time: Date | null
    execution_end_time: Date | null
    job_type: $Enums.JobType | null
  }

  export type Cron_jobsCountAggregateOutputType = {
    id: number
    execution_start_time: number
    execution_end_time: number
    job_type: number
    _all: number
  }


  export type Cron_jobsMinAggregateInputType = {
    id?: true
    execution_start_time?: true
    execution_end_time?: true
    job_type?: true
  }

  export type Cron_jobsMaxAggregateInputType = {
    id?: true
    execution_start_time?: true
    execution_end_time?: true
    job_type?: true
  }

  export type Cron_jobsCountAggregateInputType = {
    id?: true
    execution_start_time?: true
    execution_end_time?: true
    job_type?: true
    _all?: true
  }

  export type Cron_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cron_jobs to aggregate.
     */
    where?: cron_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cron_jobs to fetch.
     */
    orderBy?: cron_jobsOrderByWithRelationInput | cron_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cron_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cron_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cron_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cron_jobs
    **/
    _count?: true | Cron_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cron_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cron_jobsMaxAggregateInputType
  }

  export type GetCron_jobsAggregateType<T extends Cron_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateCron_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCron_jobs[P]>
      : GetScalarType<T[P], AggregateCron_jobs[P]>
  }




  export type cron_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cron_jobsWhereInput
    orderBy?: cron_jobsOrderByWithAggregationInput | cron_jobsOrderByWithAggregationInput[]
    by: Cron_jobsScalarFieldEnum[] | Cron_jobsScalarFieldEnum
    having?: cron_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cron_jobsCountAggregateInputType | true
    _min?: Cron_jobsMinAggregateInputType
    _max?: Cron_jobsMaxAggregateInputType
  }

  export type Cron_jobsGroupByOutputType = {
    id: string
    execution_start_time: Date
    execution_end_time: Date
    job_type: $Enums.JobType
    _count: Cron_jobsCountAggregateOutputType | null
    _min: Cron_jobsMinAggregateOutputType | null
    _max: Cron_jobsMaxAggregateOutputType | null
  }

  type GetCron_jobsGroupByPayload<T extends cron_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cron_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cron_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cron_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], Cron_jobsGroupByOutputType[P]>
        }
      >
    >


  export type cron_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    execution_start_time?: boolean
    execution_end_time?: boolean
    job_type?: boolean
  }, ExtArgs["result"]["cron_jobs"]>

  export type cron_jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    execution_start_time?: boolean
    execution_end_time?: boolean
    job_type?: boolean
  }, ExtArgs["result"]["cron_jobs"]>

  export type cron_jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    execution_start_time?: boolean
    execution_end_time?: boolean
    job_type?: boolean
  }, ExtArgs["result"]["cron_jobs"]>

  export type cron_jobsSelectScalar = {
    id?: boolean
    execution_start_time?: boolean
    execution_end_time?: boolean
    job_type?: boolean
  }

  export type cron_jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "execution_start_time" | "execution_end_time" | "job_type", ExtArgs["result"]["cron_jobs"]>

  export type $cron_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cron_jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      execution_start_time: Date
      execution_end_time: Date
      job_type: $Enums.JobType
    }, ExtArgs["result"]["cron_jobs"]>
    composites: {}
  }

  type cron_jobsGetPayload<S extends boolean | null | undefined | cron_jobsDefaultArgs> = $Result.GetResult<Prisma.$cron_jobsPayload, S>

  type cron_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cron_jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cron_jobsCountAggregateInputType | true
    }

  export interface cron_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cron_jobs'], meta: { name: 'cron_jobs' } }
    /**
     * Find zero or one Cron_jobs that matches the filter.
     * @param {cron_jobsFindUniqueArgs} args - Arguments to find a Cron_jobs
     * @example
     * // Get one Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cron_jobsFindUniqueArgs>(args: SelectSubset<T, cron_jobsFindUniqueArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cron_jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cron_jobsFindUniqueOrThrowArgs} args - Arguments to find a Cron_jobs
     * @example
     * // Get one Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cron_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, cron_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cron_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cron_jobsFindFirstArgs} args - Arguments to find a Cron_jobs
     * @example
     * // Get one Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cron_jobsFindFirstArgs>(args?: SelectSubset<T, cron_jobsFindFirstArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cron_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cron_jobsFindFirstOrThrowArgs} args - Arguments to find a Cron_jobs
     * @example
     * // Get one Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cron_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, cron_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cron_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cron_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.findMany()
     * 
     * // Get first 10 Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cron_jobsWithIdOnly = await prisma.cron_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cron_jobsFindManyArgs>(args?: SelectSubset<T, cron_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cron_jobs.
     * @param {cron_jobsCreateArgs} args - Arguments to create a Cron_jobs.
     * @example
     * // Create one Cron_jobs
     * const Cron_jobs = await prisma.cron_jobs.create({
     *   data: {
     *     // ... data to create a Cron_jobs
     *   }
     * })
     * 
     */
    create<T extends cron_jobsCreateArgs>(args: SelectSubset<T, cron_jobsCreateArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cron_jobs.
     * @param {cron_jobsCreateManyArgs} args - Arguments to create many Cron_jobs.
     * @example
     * // Create many Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cron_jobsCreateManyArgs>(args?: SelectSubset<T, cron_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cron_jobs and returns the data saved in the database.
     * @param {cron_jobsCreateManyAndReturnArgs} args - Arguments to create many Cron_jobs.
     * @example
     * // Create many Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cron_jobs and only return the `id`
     * const cron_jobsWithIdOnly = await prisma.cron_jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cron_jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, cron_jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cron_jobs.
     * @param {cron_jobsDeleteArgs} args - Arguments to delete one Cron_jobs.
     * @example
     * // Delete one Cron_jobs
     * const Cron_jobs = await prisma.cron_jobs.delete({
     *   where: {
     *     // ... filter to delete one Cron_jobs
     *   }
     * })
     * 
     */
    delete<T extends cron_jobsDeleteArgs>(args: SelectSubset<T, cron_jobsDeleteArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cron_jobs.
     * @param {cron_jobsUpdateArgs} args - Arguments to update one Cron_jobs.
     * @example
     * // Update one Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cron_jobsUpdateArgs>(args: SelectSubset<T, cron_jobsUpdateArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cron_jobs.
     * @param {cron_jobsDeleteManyArgs} args - Arguments to filter Cron_jobs to delete.
     * @example
     * // Delete a few Cron_jobs
     * const { count } = await prisma.cron_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cron_jobsDeleteManyArgs>(args?: SelectSubset<T, cron_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cron_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cron_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cron_jobsUpdateManyArgs>(args: SelectSubset<T, cron_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cron_jobs and returns the data updated in the database.
     * @param {cron_jobsUpdateManyAndReturnArgs} args - Arguments to update many Cron_jobs.
     * @example
     * // Update many Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cron_jobs and only return the `id`
     * const cron_jobsWithIdOnly = await prisma.cron_jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cron_jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, cron_jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cron_jobs.
     * @param {cron_jobsUpsertArgs} args - Arguments to update or create a Cron_jobs.
     * @example
     * // Update or create a Cron_jobs
     * const cron_jobs = await prisma.cron_jobs.upsert({
     *   create: {
     *     // ... data to create a Cron_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cron_jobs we want to update
     *   }
     * })
     */
    upsert<T extends cron_jobsUpsertArgs>(args: SelectSubset<T, cron_jobsUpsertArgs<ExtArgs>>): Prisma__cron_jobsClient<$Result.GetResult<Prisma.$cron_jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cron_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cron_jobsCountArgs} args - Arguments to filter Cron_jobs to count.
     * @example
     * // Count the number of Cron_jobs
     * const count = await prisma.cron_jobs.count({
     *   where: {
     *     // ... the filter for the Cron_jobs we want to count
     *   }
     * })
    **/
    count<T extends cron_jobsCountArgs>(
      args?: Subset<T, cron_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cron_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cron_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cron_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cron_jobsAggregateArgs>(args: Subset<T, Cron_jobsAggregateArgs>): Prisma.PrismaPromise<GetCron_jobsAggregateType<T>>

    /**
     * Group by Cron_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cron_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cron_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cron_jobsGroupByArgs['orderBy'] }
        : { orderBy?: cron_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cron_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCron_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cron_jobs model
   */
  readonly fields: cron_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cron_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cron_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cron_jobs model
   */
  interface cron_jobsFieldRefs {
    readonly id: FieldRef<"cron_jobs", 'String'>
    readonly execution_start_time: FieldRef<"cron_jobs", 'DateTime'>
    readonly execution_end_time: FieldRef<"cron_jobs", 'DateTime'>
    readonly job_type: FieldRef<"cron_jobs", 'JobType'>
  }
    

  // Custom InputTypes
  /**
   * cron_jobs findUnique
   */
  export type cron_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * Filter, which cron_jobs to fetch.
     */
    where: cron_jobsWhereUniqueInput
  }

  /**
   * cron_jobs findUniqueOrThrow
   */
  export type cron_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * Filter, which cron_jobs to fetch.
     */
    where: cron_jobsWhereUniqueInput
  }

  /**
   * cron_jobs findFirst
   */
  export type cron_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * Filter, which cron_jobs to fetch.
     */
    where?: cron_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cron_jobs to fetch.
     */
    orderBy?: cron_jobsOrderByWithRelationInput | cron_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cron_jobs.
     */
    cursor?: cron_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cron_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cron_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cron_jobs.
     */
    distinct?: Cron_jobsScalarFieldEnum | Cron_jobsScalarFieldEnum[]
  }

  /**
   * cron_jobs findFirstOrThrow
   */
  export type cron_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * Filter, which cron_jobs to fetch.
     */
    where?: cron_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cron_jobs to fetch.
     */
    orderBy?: cron_jobsOrderByWithRelationInput | cron_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cron_jobs.
     */
    cursor?: cron_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cron_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cron_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cron_jobs.
     */
    distinct?: Cron_jobsScalarFieldEnum | Cron_jobsScalarFieldEnum[]
  }

  /**
   * cron_jobs findMany
   */
  export type cron_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * Filter, which cron_jobs to fetch.
     */
    where?: cron_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cron_jobs to fetch.
     */
    orderBy?: cron_jobsOrderByWithRelationInput | cron_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cron_jobs.
     */
    cursor?: cron_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cron_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cron_jobs.
     */
    skip?: number
    distinct?: Cron_jobsScalarFieldEnum | Cron_jobsScalarFieldEnum[]
  }

  /**
   * cron_jobs create
   */
  export type cron_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * The data needed to create a cron_jobs.
     */
    data: XOR<cron_jobsCreateInput, cron_jobsUncheckedCreateInput>
  }

  /**
   * cron_jobs createMany
   */
  export type cron_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cron_jobs.
     */
    data: cron_jobsCreateManyInput | cron_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cron_jobs createManyAndReturn
   */
  export type cron_jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * The data used to create many cron_jobs.
     */
    data: cron_jobsCreateManyInput | cron_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cron_jobs update
   */
  export type cron_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * The data needed to update a cron_jobs.
     */
    data: XOR<cron_jobsUpdateInput, cron_jobsUncheckedUpdateInput>
    /**
     * Choose, which cron_jobs to update.
     */
    where: cron_jobsWhereUniqueInput
  }

  /**
   * cron_jobs updateMany
   */
  export type cron_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cron_jobs.
     */
    data: XOR<cron_jobsUpdateManyMutationInput, cron_jobsUncheckedUpdateManyInput>
    /**
     * Filter which cron_jobs to update
     */
    where?: cron_jobsWhereInput
    /**
     * Limit how many cron_jobs to update.
     */
    limit?: number
  }

  /**
   * cron_jobs updateManyAndReturn
   */
  export type cron_jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * The data used to update cron_jobs.
     */
    data: XOR<cron_jobsUpdateManyMutationInput, cron_jobsUncheckedUpdateManyInput>
    /**
     * Filter which cron_jobs to update
     */
    where?: cron_jobsWhereInput
    /**
     * Limit how many cron_jobs to update.
     */
    limit?: number
  }

  /**
   * cron_jobs upsert
   */
  export type cron_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * The filter to search for the cron_jobs to update in case it exists.
     */
    where: cron_jobsWhereUniqueInput
    /**
     * In case the cron_jobs found by the `where` argument doesn't exist, create a new cron_jobs with this data.
     */
    create: XOR<cron_jobsCreateInput, cron_jobsUncheckedCreateInput>
    /**
     * In case the cron_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cron_jobsUpdateInput, cron_jobsUncheckedUpdateInput>
  }

  /**
   * cron_jobs delete
   */
  export type cron_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
    /**
     * Filter which cron_jobs to delete.
     */
    where: cron_jobsWhereUniqueInput
  }

  /**
   * cron_jobs deleteMany
   */
  export type cron_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cron_jobs to delete
     */
    where?: cron_jobsWhereInput
    /**
     * Limit how many cron_jobs to delete.
     */
    limit?: number
  }

  /**
   * cron_jobs without action
   */
  export type cron_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cron_jobs
     */
    select?: cron_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cron_jobs
     */
    omit?: cron_jobsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    agentconnect_info: 'agentconnect_info',
    nom: 'nom',
    prenom: 'prenom',
    poste: 'poste',
    nom_etablissement: 'nom_etablissement',
    siren_info: 'siren_info',
    created_at: 'created_at',
    updated_at: 'updated_at',
    canal_acquisition: 'canal_acquisition',
    discardedInformation: 'discardedInformation',
    accept_communication_produit: 'accept_communication_produit',
    accept_communication_suivi_projet: 'accept_communication_suivi_projet',
    statut: 'statut',
    statut_updated_at: 'statut_updated_at',
    last_browsing_date: 'last_browsing_date'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const CollectiviteScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code_insee: 'code_insee',
    code_postal: 'code_postal',
    adresse_info: 'adresse_info',
    adresse_all_infos: 'adresse_all_infos',
    ban_id: 'ban_id',
    latitude: 'latitude',
    longitude: 'longitude',
    created_by: 'created_by',
    created_at: 'created_at',
    aides_territoires_perimeter_id: 'aides_territoires_perimeter_id'
  };

  export type CollectiviteScalarFieldEnum = (typeof CollectiviteScalarFieldEnum)[keyof typeof CollectiviteScalarFieldEnum]


  export const User_projetScalarFieldEnum: {
    id: 'id',
    email_address: 'email_address',
    role: 'role',
    projet_id: 'projet_id',
    user_id: 'user_id',
    created_at: 'created_at',
    invitation_token: 'invitation_token',
    invitation_status: 'invitation_status',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    nb_views: 'nb_views',
    last_viewed_at: 'last_viewed_at'
  };

  export type User_projetScalarFieldEnum = (typeof User_projetScalarFieldEnum)[keyof typeof User_projetScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    destination_address: 'destination_address',
    type: 'type',
    sending_time: 'sending_time',
    brevo_id: 'brevo_id',
    email_status: 'email_status',
    user_projet_id: 'user_projet_id',
    user_id: 'user_id',
    extra: 'extra'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const User_collectiviteScalarFieldEnum: {
    user_id: 'user_id',
    collectivite_id: 'collectivite_id',
    verified: 'verified',
    created_at: 'created_at'
  };

  export type User_collectiviteScalarFieldEnum = (typeof User_collectiviteScalarFieldEnum)[keyof typeof User_collectiviteScalarFieldEnum]


  export const ProjetScalarFieldEnum: {
    id: 'id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    nom: 'nom',
    type_espace: 'type_espace',
    adresse: 'adresse',
    niveau_maturite: 'niveau_maturite',
    adresse_info: 'adresse_info',
    adresse_all_infos: 'adresse_all_infos',
    date_echeance: 'date_echeance',
    fiches_solutions_id: 'fiches_solutions_id',
    fiches_diagnostic_id: 'fiches_diagnostic_id',
    collectiviteId: 'collectiviteId',
    recommandations_viewed_by: 'recommandations_viewed_by',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_public: 'is_public',
    budget: 'budget',
    sourcing_rex: 'sourcing_rex',
    statut: 'statut',
    statut_updated_at: 'statut_updated_at'
  };

  export type ProjetScalarFieldEnum = (typeof ProjetScalarFieldEnum)[keyof typeof ProjetScalarFieldEnum]


  export const Projet_ficheScalarFieldEnum: {
    id: 'id',
    projet_id: 'projet_id',
    fiche_id: 'fiche_id',
    type: 'type',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type Projet_ficheScalarFieldEnum = (typeof Projet_ficheScalarFieldEnum)[keyof typeof Projet_ficheScalarFieldEnum]


  export const Projet_sourcing_contactScalarFieldEnum: {
    id: 'id',
    projet_id: 'projet_id',
    sourced_user_projet_id: 'sourced_user_projet_id',
    created_at: 'created_at',
    created_by: 'created_by'
  };

  export type Projet_sourcing_contactScalarFieldEnum = (typeof Projet_sourcing_contactScalarFieldEnum)[keyof typeof Projet_sourcing_contactScalarFieldEnum]


  export const EstimationScalarFieldEnum: {
    id: 'id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    projet_id: 'projet_id',
    fiches_solutions_id: 'fiches_solutions_id',
    materiaux: 'materiaux',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by'
  };

  export type EstimationScalarFieldEnum = (typeof EstimationScalarFieldEnum)[keyof typeof EstimationScalarFieldEnum]


  export const ClimadiagScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    type_lieu: 'type_lieu',
    code_insee: 'code_insee',
    code_postal: 'code_postal',
    epci_parent_id: 'epci_parent_id',
    jours_tres_chauds_ref: 'jours_tres_chauds_ref',
    jours_tres_chauds_prevision: 'jours_tres_chauds_prevision',
    nuits_chaudes_ref: 'nuits_chaudes_ref',
    nuits_chaudes_prevision: 'nuits_chaudes_prevision',
    jours_vdc_ref: 'jours_vdc_ref',
    jours_vdc_prevision: 'jours_vdc_prevision',
    population: 'population',
    superficie: 'superficie',
    couverture_lcz: 'couverture_lcz',
    adresse_all_infos: 'adresse_all_infos',
    searchable_field: 'searchable_field'
  };

  export type ClimadiagScalarFieldEnum = (typeof ClimadiagScalarFieldEnum)[keyof typeof ClimadiagScalarFieldEnum]


  export const AideScalarFieldEnum: {
    id: 'id',
    aideTerritoireId: 'aideTerritoireId',
    submission_deadline: 'submission_deadline',
    type: 'type',
    name: 'name',
    financers: 'financers'
  };

  export type AideScalarFieldEnum = (typeof AideScalarFieldEnum)[keyof typeof AideScalarFieldEnum]


  export const Estimations_aidesScalarFieldEnum: {
    id: 'id',
    estimationId: 'estimationId',
    aideId: 'aideId',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type Estimations_aidesScalarFieldEnum = (typeof Estimations_aidesScalarFieldEnum)[keyof typeof Estimations_aidesScalarFieldEnum]


  export const Estimation_materiauxScalarFieldEnum: {
    id: 'id',
    estimation_fiche_solution_id: 'estimation_fiche_solution_id',
    materiau_id: 'materiau_id',
    quantite: 'quantite',
    cout_investissement_override: 'cout_investissement_override',
    cout_entretien_override: 'cout_entretien_override'
  };

  export type Estimation_materiauxScalarFieldEnum = (typeof Estimation_materiauxScalarFieldEnum)[keyof typeof Estimation_materiauxScalarFieldEnum]


  export const Estimation_fiche_solutionScalarFieldEnum: {
    id: 'id',
    estimation_id: 'estimation_id',
    fiche_solution_id: 'fiche_solution_id',
    quantite: 'quantite',
    cout_min_investissement: 'cout_min_investissement',
    cout_max_investissement: 'cout_max_investissement',
    cout_min_entretien: 'cout_min_entretien',
    cout_max_entretien: 'cout_max_entretien',
    cout_investissement_override: 'cout_investissement_override',
    cout_entretien_override: 'cout_entretien_override'
  };

  export type Estimation_fiche_solutionScalarFieldEnum = (typeof Estimation_fiche_solutionScalarFieldEnum)[keyof typeof Estimation_fiche_solutionScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ragtimeId: 'ragtimeId',
    created_at: 'created_at'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const Diagnostic_simulationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    projet_id: 'projet_id',
    initial_values: 'initial_values',
    validated: 'validated',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Diagnostic_simulationScalarFieldEnum = (typeof Diagnostic_simulationScalarFieldEnum)[keyof typeof Diagnostic_simulationScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    reference_id: 'reference_id',
    reference_type: 'reference_type',
    event_type: 'event_type',
    context: 'context',
    user_id: 'user_id'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const Cron_jobsScalarFieldEnum: {
    id: 'id',
    execution_start_time: 'execution_start_time',
    execution_end_time: 'execution_end_time',
    job_type: 'job_type'
  };

  export type Cron_jobsScalarFieldEnum = (typeof Cron_jobsScalarFieldEnum)[keyof typeof Cron_jobsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    image: 'image',
    nom: 'nom',
    prenom: 'prenom',
    poste: 'poste',
    nom_etablissement: 'nom_etablissement',
    canal_acquisition: 'canal_acquisition',
    discardedInformation: 'discardedInformation'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  export const collectiviteOrderByRelevanceFieldEnum: {
    nom: 'nom',
    code_insee: 'code_insee',
    code_postal: 'code_postal',
    ban_id: 'ban_id',
    created_by: 'created_by',
    aides_territoires_perimeter_id: 'aides_territoires_perimeter_id'
  };

  export type collectiviteOrderByRelevanceFieldEnum = (typeof collectiviteOrderByRelevanceFieldEnum)[keyof typeof collectiviteOrderByRelevanceFieldEnum]


  export const user_projetOrderByRelevanceFieldEnum: {
    email_address: 'email_address',
    user_id: 'user_id',
    invitation_token: 'invitation_token',
    deleted_by: 'deleted_by'
  };

  export type user_projetOrderByRelevanceFieldEnum = (typeof user_projetOrderByRelevanceFieldEnum)[keyof typeof user_projetOrderByRelevanceFieldEnum]


  export const emailOrderByRelevanceFieldEnum: {
    id: 'id',
    destination_address: 'destination_address',
    brevo_id: 'brevo_id',
    user_id: 'user_id'
  };

  export type emailOrderByRelevanceFieldEnum = (typeof emailOrderByRelevanceFieldEnum)[keyof typeof emailOrderByRelevanceFieldEnum]


  export const user_collectiviteOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type user_collectiviteOrderByRelevanceFieldEnum = (typeof user_collectiviteOrderByRelevanceFieldEnum)[keyof typeof user_collectiviteOrderByRelevanceFieldEnum]


  export const projetOrderByRelevanceFieldEnum: {
    created_by: 'created_by',
    nom: 'nom',
    type_espace: 'type_espace',
    adresse: 'adresse',
    niveau_maturite: 'niveau_maturite',
    recommandations_viewed_by: 'recommandations_viewed_by',
    deleted_by: 'deleted_by'
  };

  export type projetOrderByRelevanceFieldEnum = (typeof projetOrderByRelevanceFieldEnum)[keyof typeof projetOrderByRelevanceFieldEnum]


  export const projet_ficheOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type projet_ficheOrderByRelevanceFieldEnum = (typeof projet_ficheOrderByRelevanceFieldEnum)[keyof typeof projet_ficheOrderByRelevanceFieldEnum]


  export const projet_sourcing_contactOrderByRelevanceFieldEnum: {
    created_by: 'created_by'
  };

  export type projet_sourcing_contactOrderByRelevanceFieldEnum = (typeof projet_sourcing_contactOrderByRelevanceFieldEnum)[keyof typeof projet_sourcing_contactOrderByRelevanceFieldEnum]


  export const estimationOrderByRelevanceFieldEnum: {
    created_by: 'created_by',
    deleted_by: 'deleted_by'
  };

  export type estimationOrderByRelevanceFieldEnum = (typeof estimationOrderByRelevanceFieldEnum)[keyof typeof estimationOrderByRelevanceFieldEnum]


  export const climadiagOrderByRelevanceFieldEnum: {
    nom: 'nom',
    code_insee: 'code_insee',
    code_postal: 'code_postal',
    searchable_field: 'searchable_field'
  };

  export type climadiagOrderByRelevanceFieldEnum = (typeof climadiagOrderByRelevanceFieldEnum)[keyof typeof climadiagOrderByRelevanceFieldEnum]


  export const aideOrderByRelevanceFieldEnum: {
    type: 'type',
    name: 'name',
    financers: 'financers'
  };

  export type aideOrderByRelevanceFieldEnum = (typeof aideOrderByRelevanceFieldEnum)[keyof typeof aideOrderByRelevanceFieldEnum]


  export const estimations_aidesOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type estimations_aidesOrderByRelevanceFieldEnum = (typeof estimations_aidesOrderByRelevanceFieldEnum)[keyof typeof estimations_aidesOrderByRelevanceFieldEnum]


  export const estimation_materiauxOrderByRelevanceFieldEnum: {
    id: 'id',
    estimation_fiche_solution_id: 'estimation_fiche_solution_id'
  };

  export type estimation_materiauxOrderByRelevanceFieldEnum = (typeof estimation_materiauxOrderByRelevanceFieldEnum)[keyof typeof estimation_materiauxOrderByRelevanceFieldEnum]


  export const estimation_fiche_solutionOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type estimation_fiche_solutionOrderByRelevanceFieldEnum = (typeof estimation_fiche_solutionOrderByRelevanceFieldEnum)[keyof typeof estimation_fiche_solutionOrderByRelevanceFieldEnum]


  export const conversationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    ragtimeId: 'ragtimeId'
  };

  export type conversationOrderByRelevanceFieldEnum = (typeof conversationOrderByRelevanceFieldEnum)[keyof typeof conversationOrderByRelevanceFieldEnum]


  export const diagnostic_simulationOrderByRelevanceFieldEnum: {
    id: 'id',
    user_id: 'user_id'
  };

  export type diagnostic_simulationOrderByRelevanceFieldEnum = (typeof diagnostic_simulationOrderByRelevanceFieldEnum)[keyof typeof diagnostic_simulationOrderByRelevanceFieldEnum]


  export const AnalyticsOrderByRelevanceFieldEnum: {
    id: 'id',
    reference_id: 'reference_id',
    user_id: 'user_id'
  };

  export type AnalyticsOrderByRelevanceFieldEnum = (typeof AnalyticsOrderByRelevanceFieldEnum)[keyof typeof AnalyticsOrderByRelevanceFieldEnum]


  export const cron_jobsOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type cron_jobsOrderByRelevanceFieldEnum = (typeof cron_jobsOrderByRelevanceFieldEnum)[keyof typeof cron_jobsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StatutUser'
   */
  export type EnumStatutUserFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutUser'>
    


  /**
   * Reference to a field of type 'StatutUser[]'
   */
  export type ListEnumStatutUserFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutUser[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RoleProjet'
   */
  export type EnumRoleProjetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleProjet'>
    


  /**
   * Reference to a field of type 'RoleProjet[]'
   */
  export type ListEnumRoleProjetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleProjet[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'emailType'
   */
  export type EnumemailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'emailType'>
    


  /**
   * Reference to a field of type 'emailType[]'
   */
  export type ListEnumemailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'emailType[]'>
    


  /**
   * Reference to a field of type 'emailStatus'
   */
  export type EnumemailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'emailStatus'>
    


  /**
   * Reference to a field of type 'emailStatus[]'
   */
  export type ListEnumemailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'emailStatus[]'>
    


  /**
   * Reference to a field of type 'StatutProjet'
   */
  export type EnumStatutProjetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutProjet'>
    


  /**
   * Reference to a field of type 'StatutProjet[]'
   */
  export type ListEnumStatutProjetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutProjet[]'>
    


  /**
   * Reference to a field of type 'FicheType'
   */
  export type EnumFicheTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FicheType'>
    


  /**
   * Reference to a field of type 'FicheType[]'
   */
  export type ListEnumFicheTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FicheType[]'>
    


  /**
   * Reference to a field of type 'TypeLieuClimadiag'
   */
  export type EnumTypeLieuClimadiagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeLieuClimadiag'>
    


  /**
   * Reference to a field of type 'TypeLieuClimadiag[]'
   */
  export type ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeLieuClimadiag[]'>
    


  /**
   * Reference to a field of type 'ReferenceType'
   */
  export type EnumReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferenceType'>
    


  /**
   * Reference to a field of type 'ReferenceType[]'
   */
  export type ListEnumReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferenceType[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'JobType[]'
   */
  export type ListEnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    agentconnect_info?: JsonNullableFilter<"User">
    nom?: StringNullableFilter<"User"> | string | null
    prenom?: StringNullableFilter<"User"> | string | null
    poste?: StringNullableFilter<"User"> | string | null
    nom_etablissement?: StringNullableFilter<"User"> | string | null
    siren_info?: JsonNullableFilter<"User">
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    canal_acquisition?: StringNullableFilter<"User"> | string | null
    discardedInformation?: StringNullableListFilter<"User">
    accept_communication_produit?: BoolFilter<"User"> | boolean
    accept_communication_suivi_projet?: BoolFilter<"User"> | boolean
    statut?: EnumStatutUserNullableFilter<"User"> | $Enums.StatutUser | null
    statut_updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_browsing_date?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    collectivites_created?: CollectiviteListRelationFilter
    projets_created?: ProjetListRelationFilter
    estimations_created?: EstimationListRelationFilter
    estimations_deleted?: EstimationListRelationFilter
    projets_deleted?: ProjetListRelationFilter
    collectivites?: User_collectiviteListRelationFilter
    projets?: User_projetListRelationFilter
    user_projet_deleted?: User_projetListRelationFilter
    conversations?: ConversationListRelationFilter
    Analytics?: AnalyticsListRelationFilter
    sourcing_contacts_created?: Projet_sourcing_contactListRelationFilter
    emails?: EmailListRelationFilter
    estimations_aides?: Estimations_aidesListRelationFilter
    fiches?: Projet_ficheListRelationFilter
    diagnostic_simulation?: Diagnostic_simulationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    agentconnect_info?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    prenom?: SortOrderInput | SortOrder
    poste?: SortOrderInput | SortOrder
    nom_etablissement?: SortOrderInput | SortOrder
    siren_info?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    canal_acquisition?: SortOrderInput | SortOrder
    discardedInformation?: SortOrder
    accept_communication_produit?: SortOrder
    accept_communication_suivi_projet?: SortOrder
    statut?: SortOrderInput | SortOrder
    statut_updated_at?: SortOrderInput | SortOrder
    last_browsing_date?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    collectivites_created?: collectiviteOrderByRelationAggregateInput
    projets_created?: projetOrderByRelationAggregateInput
    estimations_created?: estimationOrderByRelationAggregateInput
    estimations_deleted?: estimationOrderByRelationAggregateInput
    projets_deleted?: projetOrderByRelationAggregateInput
    collectivites?: user_collectiviteOrderByRelationAggregateInput
    projets?: user_projetOrderByRelationAggregateInput
    user_projet_deleted?: user_projetOrderByRelationAggregateInput
    conversations?: conversationOrderByRelationAggregateInput
    Analytics?: AnalyticsOrderByRelationAggregateInput
    sourcing_contacts_created?: projet_sourcing_contactOrderByRelationAggregateInput
    emails?: emailOrderByRelationAggregateInput
    estimations_aides?: estimations_aidesOrderByRelationAggregateInput
    fiches?: projet_ficheOrderByRelationAggregateInput
    diagnostic_simulation?: diagnostic_simulationOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    agentconnect_info?: JsonNullableFilter<"User">
    nom?: StringNullableFilter<"User"> | string | null
    prenom?: StringNullableFilter<"User"> | string | null
    poste?: StringNullableFilter<"User"> | string | null
    nom_etablissement?: StringNullableFilter<"User"> | string | null
    siren_info?: JsonNullableFilter<"User">
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    canal_acquisition?: StringNullableFilter<"User"> | string | null
    discardedInformation?: StringNullableListFilter<"User">
    accept_communication_produit?: BoolFilter<"User"> | boolean
    accept_communication_suivi_projet?: BoolFilter<"User"> | boolean
    statut?: EnumStatutUserNullableFilter<"User"> | $Enums.StatutUser | null
    statut_updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    last_browsing_date?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    collectivites_created?: CollectiviteListRelationFilter
    projets_created?: ProjetListRelationFilter
    estimations_created?: EstimationListRelationFilter
    estimations_deleted?: EstimationListRelationFilter
    projets_deleted?: ProjetListRelationFilter
    collectivites?: User_collectiviteListRelationFilter
    projets?: User_projetListRelationFilter
    user_projet_deleted?: User_projetListRelationFilter
    conversations?: ConversationListRelationFilter
    Analytics?: AnalyticsListRelationFilter
    sourcing_contacts_created?: Projet_sourcing_contactListRelationFilter
    emails?: EmailListRelationFilter
    estimations_aides?: Estimations_aidesListRelationFilter
    fiches?: Projet_ficheListRelationFilter
    diagnostic_simulation?: Diagnostic_simulationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    agentconnect_info?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    prenom?: SortOrderInput | SortOrder
    poste?: SortOrderInput | SortOrder
    nom_etablissement?: SortOrderInput | SortOrder
    siren_info?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    canal_acquisition?: SortOrderInput | SortOrder
    discardedInformation?: SortOrder
    accept_communication_produit?: SortOrder
    accept_communication_suivi_projet?: SortOrder
    statut?: SortOrderInput | SortOrder
    statut_updated_at?: SortOrderInput | SortOrder
    last_browsing_date?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    agentconnect_info?: JsonNullableWithAggregatesFilter<"User">
    nom?: StringNullableWithAggregatesFilter<"User"> | string | null
    prenom?: StringNullableWithAggregatesFilter<"User"> | string | null
    poste?: StringNullableWithAggregatesFilter<"User"> | string | null
    nom_etablissement?: StringNullableWithAggregatesFilter<"User"> | string | null
    siren_info?: JsonNullableWithAggregatesFilter<"User">
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    canal_acquisition?: StringNullableWithAggregatesFilter<"User"> | string | null
    discardedInformation?: StringNullableListFilter<"User">
    accept_communication_produit?: BoolWithAggregatesFilter<"User"> | boolean
    accept_communication_suivi_projet?: BoolWithAggregatesFilter<"User"> | boolean
    statut?: EnumStatutUserNullableWithAggregatesFilter<"User"> | $Enums.StatutUser | null
    statut_updated_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    last_browsing_date?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type collectiviteWhereInput = {
    AND?: collectiviteWhereInput | collectiviteWhereInput[]
    OR?: collectiviteWhereInput[]
    NOT?: collectiviteWhereInput | collectiviteWhereInput[]
    id?: IntFilter<"collectivite"> | number
    nom?: StringFilter<"collectivite"> | string
    code_insee?: StringNullableFilter<"collectivite"> | string | null
    code_postal?: StringNullableFilter<"collectivite"> | string | null
    adresse_info?: JsonNullableFilter<"collectivite">
    adresse_all_infos?: JsonNullableFilter<"collectivite">
    ban_id?: StringNullableFilter<"collectivite"> | string | null
    latitude?: FloatNullableFilter<"collectivite"> | number | null
    longitude?: FloatNullableFilter<"collectivite"> | number | null
    created_by?: StringFilter<"collectivite"> | string
    created_at?: DateTimeFilter<"collectivite"> | Date | string
    aides_territoires_perimeter_id?: StringNullableFilter<"collectivite"> | string | null
    users?: User_collectiviteListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    projet?: ProjetListRelationFilter
  }

  export type collectiviteOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code_insee?: SortOrderInput | SortOrder
    code_postal?: SortOrderInput | SortOrder
    adresse_info?: SortOrderInput | SortOrder
    adresse_all_infos?: SortOrderInput | SortOrder
    ban_id?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    aides_territoires_perimeter_id?: SortOrderInput | SortOrder
    users?: user_collectiviteOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    projet?: projetOrderByRelationAggregateInput
    _relevance?: collectiviteOrderByRelevanceInput
  }

  export type collectiviteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code_insee?: string
    ban_id?: string
    AND?: collectiviteWhereInput | collectiviteWhereInput[]
    OR?: collectiviteWhereInput[]
    NOT?: collectiviteWhereInput | collectiviteWhereInput[]
    nom?: StringFilter<"collectivite"> | string
    code_postal?: StringNullableFilter<"collectivite"> | string | null
    adresse_info?: JsonNullableFilter<"collectivite">
    adresse_all_infos?: JsonNullableFilter<"collectivite">
    latitude?: FloatNullableFilter<"collectivite"> | number | null
    longitude?: FloatNullableFilter<"collectivite"> | number | null
    created_by?: StringFilter<"collectivite"> | string
    created_at?: DateTimeFilter<"collectivite"> | Date | string
    aides_territoires_perimeter_id?: StringNullableFilter<"collectivite"> | string | null
    users?: User_collectiviteListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    projet?: ProjetListRelationFilter
  }, "id" | "code_insee" | "ban_id">

  export type collectiviteOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code_insee?: SortOrderInput | SortOrder
    code_postal?: SortOrderInput | SortOrder
    adresse_info?: SortOrderInput | SortOrder
    adresse_all_infos?: SortOrderInput | SortOrder
    ban_id?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    aides_territoires_perimeter_id?: SortOrderInput | SortOrder
    _count?: collectiviteCountOrderByAggregateInput
    _avg?: collectiviteAvgOrderByAggregateInput
    _max?: collectiviteMaxOrderByAggregateInput
    _min?: collectiviteMinOrderByAggregateInput
    _sum?: collectiviteSumOrderByAggregateInput
  }

  export type collectiviteScalarWhereWithAggregatesInput = {
    AND?: collectiviteScalarWhereWithAggregatesInput | collectiviteScalarWhereWithAggregatesInput[]
    OR?: collectiviteScalarWhereWithAggregatesInput[]
    NOT?: collectiviteScalarWhereWithAggregatesInput | collectiviteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"collectivite"> | number
    nom?: StringWithAggregatesFilter<"collectivite"> | string
    code_insee?: StringNullableWithAggregatesFilter<"collectivite"> | string | null
    code_postal?: StringNullableWithAggregatesFilter<"collectivite"> | string | null
    adresse_info?: JsonNullableWithAggregatesFilter<"collectivite">
    adresse_all_infos?: JsonNullableWithAggregatesFilter<"collectivite">
    ban_id?: StringNullableWithAggregatesFilter<"collectivite"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"collectivite"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"collectivite"> | number | null
    created_by?: StringWithAggregatesFilter<"collectivite"> | string
    created_at?: DateTimeWithAggregatesFilter<"collectivite"> | Date | string
    aides_territoires_perimeter_id?: StringNullableWithAggregatesFilter<"collectivite"> | string | null
  }

  export type user_projetWhereInput = {
    AND?: user_projetWhereInput | user_projetWhereInput[]
    OR?: user_projetWhereInput[]
    NOT?: user_projetWhereInput | user_projetWhereInput[]
    id?: IntFilter<"user_projet"> | number
    email_address?: StringNullableFilter<"user_projet"> | string | null
    role?: EnumRoleProjetFilter<"user_projet"> | $Enums.RoleProjet
    projet_id?: IntFilter<"user_projet"> | number
    user_id?: StringNullableFilter<"user_projet"> | string | null
    created_at?: DateTimeFilter<"user_projet"> | Date | string
    invitation_token?: StringNullableFilter<"user_projet"> | string | null
    invitation_status?: EnumInvitationStatusFilter<"user_projet"> | $Enums.InvitationStatus
    deleted_at?: DateTimeNullableFilter<"user_projet"> | Date | string | null
    deleted_by?: StringNullableFilter<"user_projet"> | string | null
    nb_views?: IntNullableFilter<"user_projet"> | number | null
    last_viewed_at?: DateTimeNullableFilter<"user_projet"> | Date | string | null
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    email?: EmailListRelationFilter
    sourced_by_projets?: Projet_sourcing_contactListRelationFilter
  }

  export type user_projetOrderByWithRelationInput = {
    id?: SortOrder
    email_address?: SortOrderInput | SortOrder
    role?: SortOrder
    projet_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    invitation_token?: SortOrderInput | SortOrder
    invitation_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    nb_views?: SortOrderInput | SortOrder
    last_viewed_at?: SortOrderInput | SortOrder
    projet?: projetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    deleter?: UserOrderByWithRelationInput
    email?: emailOrderByRelationAggregateInput
    sourced_by_projets?: projet_sourcing_contactOrderByRelationAggregateInput
    _relevance?: user_projetOrderByRelevanceInput
  }

  export type user_projetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_projet_id?: user_projetUser_idProjet_idCompoundUniqueInput
    AND?: user_projetWhereInput | user_projetWhereInput[]
    OR?: user_projetWhereInput[]
    NOT?: user_projetWhereInput | user_projetWhereInput[]
    email_address?: StringNullableFilter<"user_projet"> | string | null
    role?: EnumRoleProjetFilter<"user_projet"> | $Enums.RoleProjet
    projet_id?: IntFilter<"user_projet"> | number
    user_id?: StringNullableFilter<"user_projet"> | string | null
    created_at?: DateTimeFilter<"user_projet"> | Date | string
    invitation_token?: StringNullableFilter<"user_projet"> | string | null
    invitation_status?: EnumInvitationStatusFilter<"user_projet"> | $Enums.InvitationStatus
    deleted_at?: DateTimeNullableFilter<"user_projet"> | Date | string | null
    deleted_by?: StringNullableFilter<"user_projet"> | string | null
    nb_views?: IntNullableFilter<"user_projet"> | number | null
    last_viewed_at?: DateTimeNullableFilter<"user_projet"> | Date | string | null
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    email?: EmailListRelationFilter
    sourced_by_projets?: Projet_sourcing_contactListRelationFilter
  }, "id" | "user_id_projet_id">

  export type user_projetOrderByWithAggregationInput = {
    id?: SortOrder
    email_address?: SortOrderInput | SortOrder
    role?: SortOrder
    projet_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    invitation_token?: SortOrderInput | SortOrder
    invitation_status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    nb_views?: SortOrderInput | SortOrder
    last_viewed_at?: SortOrderInput | SortOrder
    _count?: user_projetCountOrderByAggregateInput
    _avg?: user_projetAvgOrderByAggregateInput
    _max?: user_projetMaxOrderByAggregateInput
    _min?: user_projetMinOrderByAggregateInput
    _sum?: user_projetSumOrderByAggregateInput
  }

  export type user_projetScalarWhereWithAggregatesInput = {
    AND?: user_projetScalarWhereWithAggregatesInput | user_projetScalarWhereWithAggregatesInput[]
    OR?: user_projetScalarWhereWithAggregatesInput[]
    NOT?: user_projetScalarWhereWithAggregatesInput | user_projetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_projet"> | number
    email_address?: StringNullableWithAggregatesFilter<"user_projet"> | string | null
    role?: EnumRoleProjetWithAggregatesFilter<"user_projet"> | $Enums.RoleProjet
    projet_id?: IntWithAggregatesFilter<"user_projet"> | number
    user_id?: StringNullableWithAggregatesFilter<"user_projet"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"user_projet"> | Date | string
    invitation_token?: StringNullableWithAggregatesFilter<"user_projet"> | string | null
    invitation_status?: EnumInvitationStatusWithAggregatesFilter<"user_projet"> | $Enums.InvitationStatus
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user_projet"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"user_projet"> | string | null
    nb_views?: IntNullableWithAggregatesFilter<"user_projet"> | number | null
    last_viewed_at?: DateTimeNullableWithAggregatesFilter<"user_projet"> | Date | string | null
  }

  export type emailWhereInput = {
    AND?: emailWhereInput | emailWhereInput[]
    OR?: emailWhereInput[]
    NOT?: emailWhereInput | emailWhereInput[]
    id?: StringFilter<"email"> | string
    destination_address?: StringFilter<"email"> | string
    type?: EnumemailTypeFilter<"email"> | $Enums.emailType
    sending_time?: DateTimeFilter<"email"> | Date | string
    brevo_id?: StringNullableFilter<"email"> | string | null
    email_status?: EnumemailStatusFilter<"email"> | $Enums.emailStatus
    user_projet_id?: IntNullableFilter<"email"> | number | null
    user_id?: StringNullableFilter<"email"> | string | null
    extra?: JsonNullableFilter<"email">
    user_projet?: XOR<User_projetNullableScalarRelationFilter, user_projetWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type emailOrderByWithRelationInput = {
    id?: SortOrder
    destination_address?: SortOrder
    type?: SortOrder
    sending_time?: SortOrder
    brevo_id?: SortOrderInput | SortOrder
    email_status?: SortOrder
    user_projet_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    user_projet?: user_projetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: emailOrderByRelevanceInput
  }

  export type emailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: emailWhereInput | emailWhereInput[]
    OR?: emailWhereInput[]
    NOT?: emailWhereInput | emailWhereInput[]
    destination_address?: StringFilter<"email"> | string
    type?: EnumemailTypeFilter<"email"> | $Enums.emailType
    sending_time?: DateTimeFilter<"email"> | Date | string
    brevo_id?: StringNullableFilter<"email"> | string | null
    email_status?: EnumemailStatusFilter<"email"> | $Enums.emailStatus
    user_projet_id?: IntNullableFilter<"email"> | number | null
    user_id?: StringNullableFilter<"email"> | string | null
    extra?: JsonNullableFilter<"email">
    user_projet?: XOR<User_projetNullableScalarRelationFilter, user_projetWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type emailOrderByWithAggregationInput = {
    id?: SortOrder
    destination_address?: SortOrder
    type?: SortOrder
    sending_time?: SortOrder
    brevo_id?: SortOrderInput | SortOrder
    email_status?: SortOrder
    user_projet_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    _count?: emailCountOrderByAggregateInput
    _avg?: emailAvgOrderByAggregateInput
    _max?: emailMaxOrderByAggregateInput
    _min?: emailMinOrderByAggregateInput
    _sum?: emailSumOrderByAggregateInput
  }

  export type emailScalarWhereWithAggregatesInput = {
    AND?: emailScalarWhereWithAggregatesInput | emailScalarWhereWithAggregatesInput[]
    OR?: emailScalarWhereWithAggregatesInput[]
    NOT?: emailScalarWhereWithAggregatesInput | emailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"email"> | string
    destination_address?: StringWithAggregatesFilter<"email"> | string
    type?: EnumemailTypeWithAggregatesFilter<"email"> | $Enums.emailType
    sending_time?: DateTimeWithAggregatesFilter<"email"> | Date | string
    brevo_id?: StringNullableWithAggregatesFilter<"email"> | string | null
    email_status?: EnumemailStatusWithAggregatesFilter<"email"> | $Enums.emailStatus
    user_projet_id?: IntNullableWithAggregatesFilter<"email"> | number | null
    user_id?: StringNullableWithAggregatesFilter<"email"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"email">
  }

  export type user_collectiviteWhereInput = {
    AND?: user_collectiviteWhereInput | user_collectiviteWhereInput[]
    OR?: user_collectiviteWhereInput[]
    NOT?: user_collectiviteWhereInput | user_collectiviteWhereInput[]
    user_id?: StringFilter<"user_collectivite"> | string
    collectivite_id?: IntFilter<"user_collectivite"> | number
    verified?: BoolFilter<"user_collectivite"> | boolean
    created_at?: DateTimeFilter<"user_collectivite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    collectivite?: XOR<CollectiviteScalarRelationFilter, collectiviteWhereInput>
  }

  export type user_collectiviteOrderByWithRelationInput = {
    user_id?: SortOrder
    collectivite_id?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    collectivite?: collectiviteOrderByWithRelationInput
    _relevance?: user_collectiviteOrderByRelevanceInput
  }

  export type user_collectiviteWhereUniqueInput = Prisma.AtLeast<{
    userCollectiviteId?: user_collectiviteUserCollectiviteIdCompoundUniqueInput
    AND?: user_collectiviteWhereInput | user_collectiviteWhereInput[]
    OR?: user_collectiviteWhereInput[]
    NOT?: user_collectiviteWhereInput | user_collectiviteWhereInput[]
    user_id?: StringFilter<"user_collectivite"> | string
    collectivite_id?: IntFilter<"user_collectivite"> | number
    verified?: BoolFilter<"user_collectivite"> | boolean
    created_at?: DateTimeFilter<"user_collectivite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    collectivite?: XOR<CollectiviteScalarRelationFilter, collectiviteWhereInput>
  }, "userCollectiviteId">

  export type user_collectiviteOrderByWithAggregationInput = {
    user_id?: SortOrder
    collectivite_id?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
    _count?: user_collectiviteCountOrderByAggregateInput
    _avg?: user_collectiviteAvgOrderByAggregateInput
    _max?: user_collectiviteMaxOrderByAggregateInput
    _min?: user_collectiviteMinOrderByAggregateInput
    _sum?: user_collectiviteSumOrderByAggregateInput
  }

  export type user_collectiviteScalarWhereWithAggregatesInput = {
    AND?: user_collectiviteScalarWhereWithAggregatesInput | user_collectiviteScalarWhereWithAggregatesInput[]
    OR?: user_collectiviteScalarWhereWithAggregatesInput[]
    NOT?: user_collectiviteScalarWhereWithAggregatesInput | user_collectiviteScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"user_collectivite"> | string
    collectivite_id?: IntWithAggregatesFilter<"user_collectivite"> | number
    verified?: BoolWithAggregatesFilter<"user_collectivite"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"user_collectivite"> | Date | string
  }

  export type projetWhereInput = {
    AND?: projetWhereInput | projetWhereInput[]
    OR?: projetWhereInput[]
    NOT?: projetWhereInput | projetWhereInput[]
    id?: IntFilter<"projet"> | number
    created_by?: StringFilter<"projet"> | string
    created_at?: DateTimeFilter<"projet"> | Date | string
    updated_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    nom?: StringFilter<"projet"> | string
    type_espace?: StringNullableFilter<"projet"> | string | null
    adresse?: StringNullableFilter<"projet"> | string | null
    niveau_maturite?: StringNullableFilter<"projet"> | string | null
    adresse_info?: JsonNullableFilter<"projet">
    adresse_all_infos?: JsonNullableFilter<"projet">
    date_echeance?: DateTimeNullableFilter<"projet"> | Date | string | null
    fiches_solutions_id?: IntNullableListFilter<"projet">
    fiches_diagnostic_id?: IntNullableListFilter<"projet">
    collectiviteId?: IntFilter<"projet"> | number
    recommandations_viewed_by?: StringNullableListFilter<"projet">
    deleted_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    deleted_by?: StringNullableFilter<"projet"> | string | null
    is_public?: BoolNullableFilter<"projet"> | boolean | null
    budget?: IntNullableFilter<"projet"> | number | null
    sourcing_rex?: JsonNullableFilter<"projet">
    statut?: EnumStatutProjetNullableFilter<"projet"> | $Enums.StatutProjet | null
    statut_updated_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    estimations?: EstimationListRelationFilter
    collectivite?: XOR<CollectiviteScalarRelationFilter, collectiviteWhereInput>
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: User_projetListRelationFilter
    sourcing_user_projets?: Projet_sourcing_contactListRelationFilter
    fiches?: Projet_ficheListRelationFilter
    diagnostic_simulations?: Diagnostic_simulationListRelationFilter
  }

  export type projetOrderByWithRelationInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    nom?: SortOrder
    type_espace?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    niveau_maturite?: SortOrderInput | SortOrder
    adresse_info?: SortOrderInput | SortOrder
    adresse_all_infos?: SortOrderInput | SortOrder
    date_echeance?: SortOrderInput | SortOrder
    fiches_solutions_id?: SortOrder
    fiches_diagnostic_id?: SortOrder
    collectiviteId?: SortOrder
    recommandations_viewed_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    sourcing_rex?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    statut_updated_at?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    estimations?: estimationOrderByRelationAggregateInput
    collectivite?: collectiviteOrderByWithRelationInput
    deleter?: UserOrderByWithRelationInput
    users?: user_projetOrderByRelationAggregateInput
    sourcing_user_projets?: projet_sourcing_contactOrderByRelationAggregateInput
    fiches?: projet_ficheOrderByRelationAggregateInput
    diagnostic_simulations?: diagnostic_simulationOrderByRelationAggregateInput
    _relevance?: projetOrderByRelevanceInput
  }

  export type projetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: projetWhereInput | projetWhereInput[]
    OR?: projetWhereInput[]
    NOT?: projetWhereInput | projetWhereInput[]
    created_by?: StringFilter<"projet"> | string
    created_at?: DateTimeFilter<"projet"> | Date | string
    updated_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    nom?: StringFilter<"projet"> | string
    type_espace?: StringNullableFilter<"projet"> | string | null
    adresse?: StringNullableFilter<"projet"> | string | null
    niveau_maturite?: StringNullableFilter<"projet"> | string | null
    adresse_info?: JsonNullableFilter<"projet">
    adresse_all_infos?: JsonNullableFilter<"projet">
    date_echeance?: DateTimeNullableFilter<"projet"> | Date | string | null
    fiches_solutions_id?: IntNullableListFilter<"projet">
    fiches_diagnostic_id?: IntNullableListFilter<"projet">
    collectiviteId?: IntFilter<"projet"> | number
    recommandations_viewed_by?: StringNullableListFilter<"projet">
    deleted_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    deleted_by?: StringNullableFilter<"projet"> | string | null
    is_public?: BoolNullableFilter<"projet"> | boolean | null
    budget?: IntNullableFilter<"projet"> | number | null
    sourcing_rex?: JsonNullableFilter<"projet">
    statut?: EnumStatutProjetNullableFilter<"projet"> | $Enums.StatutProjet | null
    statut_updated_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    estimations?: EstimationListRelationFilter
    collectivite?: XOR<CollectiviteScalarRelationFilter, collectiviteWhereInput>
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: User_projetListRelationFilter
    sourcing_user_projets?: Projet_sourcing_contactListRelationFilter
    fiches?: Projet_ficheListRelationFilter
    diagnostic_simulations?: Diagnostic_simulationListRelationFilter
  }, "id">

  export type projetOrderByWithAggregationInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    nom?: SortOrder
    type_espace?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    niveau_maturite?: SortOrderInput | SortOrder
    adresse_info?: SortOrderInput | SortOrder
    adresse_all_infos?: SortOrderInput | SortOrder
    date_echeance?: SortOrderInput | SortOrder
    fiches_solutions_id?: SortOrder
    fiches_diagnostic_id?: SortOrder
    collectiviteId?: SortOrder
    recommandations_viewed_by?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_public?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    sourcing_rex?: SortOrderInput | SortOrder
    statut?: SortOrderInput | SortOrder
    statut_updated_at?: SortOrderInput | SortOrder
    _count?: projetCountOrderByAggregateInput
    _avg?: projetAvgOrderByAggregateInput
    _max?: projetMaxOrderByAggregateInput
    _min?: projetMinOrderByAggregateInput
    _sum?: projetSumOrderByAggregateInput
  }

  export type projetScalarWhereWithAggregatesInput = {
    AND?: projetScalarWhereWithAggregatesInput | projetScalarWhereWithAggregatesInput[]
    OR?: projetScalarWhereWithAggregatesInput[]
    NOT?: projetScalarWhereWithAggregatesInput | projetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projet"> | number
    created_by?: StringWithAggregatesFilter<"projet"> | string
    created_at?: DateTimeWithAggregatesFilter<"projet"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"projet"> | Date | string | null
    nom?: StringWithAggregatesFilter<"projet"> | string
    type_espace?: StringNullableWithAggregatesFilter<"projet"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"projet"> | string | null
    niveau_maturite?: StringNullableWithAggregatesFilter<"projet"> | string | null
    adresse_info?: JsonNullableWithAggregatesFilter<"projet">
    adresse_all_infos?: JsonNullableWithAggregatesFilter<"projet">
    date_echeance?: DateTimeNullableWithAggregatesFilter<"projet"> | Date | string | null
    fiches_solutions_id?: IntNullableListFilter<"projet">
    fiches_diagnostic_id?: IntNullableListFilter<"projet">
    collectiviteId?: IntWithAggregatesFilter<"projet"> | number
    recommandations_viewed_by?: StringNullableListFilter<"projet">
    deleted_at?: DateTimeNullableWithAggregatesFilter<"projet"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"projet"> | string | null
    is_public?: BoolNullableWithAggregatesFilter<"projet"> | boolean | null
    budget?: IntNullableWithAggregatesFilter<"projet"> | number | null
    sourcing_rex?: JsonNullableWithAggregatesFilter<"projet">
    statut?: EnumStatutProjetNullableWithAggregatesFilter<"projet"> | $Enums.StatutProjet | null
    statut_updated_at?: DateTimeNullableWithAggregatesFilter<"projet"> | Date | string | null
  }

  export type projet_ficheWhereInput = {
    AND?: projet_ficheWhereInput | projet_ficheWhereInput[]
    OR?: projet_ficheWhereInput[]
    NOT?: projet_ficheWhereInput | projet_ficheWhereInput[]
    id?: IntFilter<"projet_fiche"> | number
    projet_id?: IntFilter<"projet_fiche"> | number
    fiche_id?: IntFilter<"projet_fiche"> | number
    type?: EnumFicheTypeFilter<"projet_fiche"> | $Enums.FicheType
    created_at?: DateTimeFilter<"projet_fiche"> | Date | string
    user_id?: StringFilter<"projet_fiche"> | string
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type projet_ficheOrderByWithRelationInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    projet?: projetOrderByWithRelationInput
    created_by?: UserOrderByWithRelationInput
    _relevance?: projet_ficheOrderByRelevanceInput
  }

  export type projet_ficheWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projet_id_fiche_id_type?: projet_ficheProjet_idFiche_idTypeCompoundUniqueInput
    AND?: projet_ficheWhereInput | projet_ficheWhereInput[]
    OR?: projet_ficheWhereInput[]
    NOT?: projet_ficheWhereInput | projet_ficheWhereInput[]
    projet_id?: IntFilter<"projet_fiche"> | number
    fiche_id?: IntFilter<"projet_fiche"> | number
    type?: EnumFicheTypeFilter<"projet_fiche"> | $Enums.FicheType
    created_at?: DateTimeFilter<"projet_fiche"> | Date | string
    user_id?: StringFilter<"projet_fiche"> | string
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projet_id_fiche_id_type">

  export type projet_ficheOrderByWithAggregationInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    _count?: projet_ficheCountOrderByAggregateInput
    _avg?: projet_ficheAvgOrderByAggregateInput
    _max?: projet_ficheMaxOrderByAggregateInput
    _min?: projet_ficheMinOrderByAggregateInput
    _sum?: projet_ficheSumOrderByAggregateInput
  }

  export type projet_ficheScalarWhereWithAggregatesInput = {
    AND?: projet_ficheScalarWhereWithAggregatesInput | projet_ficheScalarWhereWithAggregatesInput[]
    OR?: projet_ficheScalarWhereWithAggregatesInput[]
    NOT?: projet_ficheScalarWhereWithAggregatesInput | projet_ficheScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projet_fiche"> | number
    projet_id?: IntWithAggregatesFilter<"projet_fiche"> | number
    fiche_id?: IntWithAggregatesFilter<"projet_fiche"> | number
    type?: EnumFicheTypeWithAggregatesFilter<"projet_fiche"> | $Enums.FicheType
    created_at?: DateTimeWithAggregatesFilter<"projet_fiche"> | Date | string
    user_id?: StringWithAggregatesFilter<"projet_fiche"> | string
  }

  export type projet_sourcing_contactWhereInput = {
    AND?: projet_sourcing_contactWhereInput | projet_sourcing_contactWhereInput[]
    OR?: projet_sourcing_contactWhereInput[]
    NOT?: projet_sourcing_contactWhereInput | projet_sourcing_contactWhereInput[]
    id?: IntFilter<"projet_sourcing_contact"> | number
    projet_id?: IntFilter<"projet_sourcing_contact"> | number
    sourced_user_projet_id?: IntFilter<"projet_sourcing_contact"> | number
    created_at?: DateTimeFilter<"projet_sourcing_contact"> | Date | string
    created_by?: StringFilter<"projet_sourcing_contact"> | string
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    sourced_user_projet?: XOR<User_projetScalarRelationFilter, user_projetWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type projet_sourcing_contactOrderByWithRelationInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    projet?: projetOrderByWithRelationInput
    sourced_user_projet?: user_projetOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    _relevance?: projet_sourcing_contactOrderByRelevanceInput
  }

  export type projet_sourcing_contactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projet_id_sourced_user_projet_id?: projet_sourcing_contactProjet_idSourced_user_projet_idCompoundUniqueInput
    AND?: projet_sourcing_contactWhereInput | projet_sourcing_contactWhereInput[]
    OR?: projet_sourcing_contactWhereInput[]
    NOT?: projet_sourcing_contactWhereInput | projet_sourcing_contactWhereInput[]
    projet_id?: IntFilter<"projet_sourcing_contact"> | number
    sourced_user_projet_id?: IntFilter<"projet_sourcing_contact"> | number
    created_at?: DateTimeFilter<"projet_sourcing_contact"> | Date | string
    created_by?: StringFilter<"projet_sourcing_contact"> | string
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    sourced_user_projet?: XOR<User_projetScalarRelationFilter, user_projetWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projet_id_sourced_user_projet_id">

  export type projet_sourcing_contactOrderByWithAggregationInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    _count?: projet_sourcing_contactCountOrderByAggregateInput
    _avg?: projet_sourcing_contactAvgOrderByAggregateInput
    _max?: projet_sourcing_contactMaxOrderByAggregateInput
    _min?: projet_sourcing_contactMinOrderByAggregateInput
    _sum?: projet_sourcing_contactSumOrderByAggregateInput
  }

  export type projet_sourcing_contactScalarWhereWithAggregatesInput = {
    AND?: projet_sourcing_contactScalarWhereWithAggregatesInput | projet_sourcing_contactScalarWhereWithAggregatesInput[]
    OR?: projet_sourcing_contactScalarWhereWithAggregatesInput[]
    NOT?: projet_sourcing_contactScalarWhereWithAggregatesInput | projet_sourcing_contactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projet_sourcing_contact"> | number
    projet_id?: IntWithAggregatesFilter<"projet_sourcing_contact"> | number
    sourced_user_projet_id?: IntWithAggregatesFilter<"projet_sourcing_contact"> | number
    created_at?: DateTimeWithAggregatesFilter<"projet_sourcing_contact"> | Date | string
    created_by?: StringWithAggregatesFilter<"projet_sourcing_contact"> | string
  }

  export type estimationWhereInput = {
    AND?: estimationWhereInput | estimationWhereInput[]
    OR?: estimationWhereInput[]
    NOT?: estimationWhereInput | estimationWhereInput[]
    id?: IntFilter<"estimation"> | number
    created_by?: StringFilter<"estimation"> | string
    created_at?: DateTimeFilter<"estimation"> | Date | string
    updated_at?: DateTimeFilter<"estimation"> | Date | string
    projet_id?: IntFilter<"estimation"> | number
    fiches_solutions_id?: IntNullableListFilter<"estimation">
    materiaux?: JsonNullableFilter<"estimation">
    deleted_at?: DateTimeNullableFilter<"estimation"> | Date | string | null
    deleted_by?: StringNullableFilter<"estimation"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    estimations_aides?: Estimations_aidesListRelationFilter
    estimations_fiches_solutions?: Estimation_fiche_solutionListRelationFilter
  }

  export type estimationOrderByWithRelationInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projet_id?: SortOrder
    fiches_solutions_id?: SortOrder
    materiaux?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    projet?: projetOrderByWithRelationInput
    deleter?: UserOrderByWithRelationInput
    estimations_aides?: estimations_aidesOrderByRelationAggregateInput
    estimations_fiches_solutions?: estimation_fiche_solutionOrderByRelationAggregateInput
    _relevance?: estimationOrderByRelevanceInput
  }

  export type estimationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: estimationWhereInput | estimationWhereInput[]
    OR?: estimationWhereInput[]
    NOT?: estimationWhereInput | estimationWhereInput[]
    created_by?: StringFilter<"estimation"> | string
    created_at?: DateTimeFilter<"estimation"> | Date | string
    updated_at?: DateTimeFilter<"estimation"> | Date | string
    projet_id?: IntFilter<"estimation"> | number
    fiches_solutions_id?: IntNullableListFilter<"estimation">
    materiaux?: JsonNullableFilter<"estimation">
    deleted_at?: DateTimeNullableFilter<"estimation"> | Date | string | null
    deleted_by?: StringNullableFilter<"estimation"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    deleter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    estimations_aides?: Estimations_aidesListRelationFilter
    estimations_fiches_solutions?: Estimation_fiche_solutionListRelationFilter
  }, "id">

  export type estimationOrderByWithAggregationInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projet_id?: SortOrder
    fiches_solutions_id?: SortOrder
    materiaux?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    _count?: estimationCountOrderByAggregateInput
    _avg?: estimationAvgOrderByAggregateInput
    _max?: estimationMaxOrderByAggregateInput
    _min?: estimationMinOrderByAggregateInput
    _sum?: estimationSumOrderByAggregateInput
  }

  export type estimationScalarWhereWithAggregatesInput = {
    AND?: estimationScalarWhereWithAggregatesInput | estimationScalarWhereWithAggregatesInput[]
    OR?: estimationScalarWhereWithAggregatesInput[]
    NOT?: estimationScalarWhereWithAggregatesInput | estimationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estimation"> | number
    created_by?: StringWithAggregatesFilter<"estimation"> | string
    created_at?: DateTimeWithAggregatesFilter<"estimation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"estimation"> | Date | string
    projet_id?: IntWithAggregatesFilter<"estimation"> | number
    fiches_solutions_id?: IntNullableListFilter<"estimation">
    materiaux?: JsonNullableWithAggregatesFilter<"estimation">
    deleted_at?: DateTimeNullableWithAggregatesFilter<"estimation"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"estimation"> | string | null
  }

  export type climadiagWhereInput = {
    AND?: climadiagWhereInput | climadiagWhereInput[]
    OR?: climadiagWhereInput[]
    NOT?: climadiagWhereInput | climadiagWhereInput[]
    id?: IntFilter<"climadiag"> | number
    nom?: StringFilter<"climadiag"> | string
    type_lieu?: EnumTypeLieuClimadiagFilter<"climadiag"> | $Enums.TypeLieuClimadiag
    code_insee?: StringFilter<"climadiag"> | string
    code_postal?: StringFilter<"climadiag"> | string
    epci_parent_id?: IntNullableFilter<"climadiag"> | number | null
    jours_tres_chauds_ref?: FloatNullableFilter<"climadiag"> | number | null
    jours_tres_chauds_prevision?: JsonFilter<"climadiag">
    nuits_chaudes_ref?: FloatNullableFilter<"climadiag"> | number | null
    nuits_chaudes_prevision?: JsonFilter<"climadiag">
    jours_vdc_ref?: FloatNullableFilter<"climadiag"> | number | null
    jours_vdc_prevision?: JsonFilter<"climadiag">
    population?: IntFilter<"climadiag"> | number
    superficie?: IntFilter<"climadiag"> | number
    couverture_lcz?: FloatFilter<"climadiag"> | number
    adresse_all_infos?: JsonNullableFilter<"climadiag">
    searchable_field?: StringFilter<"climadiag"> | string
  }

  export type climadiagOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    type_lieu?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    epci_parent_id?: SortOrderInput | SortOrder
    jours_tres_chauds_ref?: SortOrderInput | SortOrder
    jours_tres_chauds_prevision?: SortOrder
    nuits_chaudes_ref?: SortOrderInput | SortOrder
    nuits_chaudes_prevision?: SortOrder
    jours_vdc_ref?: SortOrderInput | SortOrder
    jours_vdc_prevision?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
    adresse_all_infos?: SortOrderInput | SortOrder
    searchable_field?: SortOrder
    _relevance?: climadiagOrderByRelevanceInput
  }

  export type climadiagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code_insee?: string
    AND?: climadiagWhereInput | climadiagWhereInput[]
    OR?: climadiagWhereInput[]
    NOT?: climadiagWhereInput | climadiagWhereInput[]
    nom?: StringFilter<"climadiag"> | string
    type_lieu?: EnumTypeLieuClimadiagFilter<"climadiag"> | $Enums.TypeLieuClimadiag
    code_postal?: StringFilter<"climadiag"> | string
    epci_parent_id?: IntNullableFilter<"climadiag"> | number | null
    jours_tres_chauds_ref?: FloatNullableFilter<"climadiag"> | number | null
    jours_tres_chauds_prevision?: JsonFilter<"climadiag">
    nuits_chaudes_ref?: FloatNullableFilter<"climadiag"> | number | null
    nuits_chaudes_prevision?: JsonFilter<"climadiag">
    jours_vdc_ref?: FloatNullableFilter<"climadiag"> | number | null
    jours_vdc_prevision?: JsonFilter<"climadiag">
    population?: IntFilter<"climadiag"> | number
    superficie?: IntFilter<"climadiag"> | number
    couverture_lcz?: FloatFilter<"climadiag"> | number
    adresse_all_infos?: JsonNullableFilter<"climadiag">
    searchable_field?: StringFilter<"climadiag"> | string
  }, "id" | "code_insee">

  export type climadiagOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    type_lieu?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    epci_parent_id?: SortOrderInput | SortOrder
    jours_tres_chauds_ref?: SortOrderInput | SortOrder
    jours_tres_chauds_prevision?: SortOrder
    nuits_chaudes_ref?: SortOrderInput | SortOrder
    nuits_chaudes_prevision?: SortOrder
    jours_vdc_ref?: SortOrderInput | SortOrder
    jours_vdc_prevision?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
    adresse_all_infos?: SortOrderInput | SortOrder
    searchable_field?: SortOrder
    _count?: climadiagCountOrderByAggregateInput
    _avg?: climadiagAvgOrderByAggregateInput
    _max?: climadiagMaxOrderByAggregateInput
    _min?: climadiagMinOrderByAggregateInput
    _sum?: climadiagSumOrderByAggregateInput
  }

  export type climadiagScalarWhereWithAggregatesInput = {
    AND?: climadiagScalarWhereWithAggregatesInput | climadiagScalarWhereWithAggregatesInput[]
    OR?: climadiagScalarWhereWithAggregatesInput[]
    NOT?: climadiagScalarWhereWithAggregatesInput | climadiagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"climadiag"> | number
    nom?: StringWithAggregatesFilter<"climadiag"> | string
    type_lieu?: EnumTypeLieuClimadiagWithAggregatesFilter<"climadiag"> | $Enums.TypeLieuClimadiag
    code_insee?: StringWithAggregatesFilter<"climadiag"> | string
    code_postal?: StringWithAggregatesFilter<"climadiag"> | string
    epci_parent_id?: IntNullableWithAggregatesFilter<"climadiag"> | number | null
    jours_tres_chauds_ref?: FloatNullableWithAggregatesFilter<"climadiag"> | number | null
    jours_tres_chauds_prevision?: JsonWithAggregatesFilter<"climadiag">
    nuits_chaudes_ref?: FloatNullableWithAggregatesFilter<"climadiag"> | number | null
    nuits_chaudes_prevision?: JsonWithAggregatesFilter<"climadiag">
    jours_vdc_ref?: FloatNullableWithAggregatesFilter<"climadiag"> | number | null
    jours_vdc_prevision?: JsonWithAggregatesFilter<"climadiag">
    population?: IntWithAggregatesFilter<"climadiag"> | number
    superficie?: IntWithAggregatesFilter<"climadiag"> | number
    couverture_lcz?: FloatWithAggregatesFilter<"climadiag"> | number
    adresse_all_infos?: JsonNullableWithAggregatesFilter<"climadiag">
    searchable_field?: StringWithAggregatesFilter<"climadiag"> | string
  }

  export type aideWhereInput = {
    AND?: aideWhereInput | aideWhereInput[]
    OR?: aideWhereInput[]
    NOT?: aideWhereInput | aideWhereInput[]
    id?: IntFilter<"aide"> | number
    aideTerritoireId?: IntFilter<"aide"> | number
    submission_deadline?: DateTimeNullableFilter<"aide"> | Date | string | null
    type?: StringFilter<"aide"> | string
    name?: StringNullableFilter<"aide"> | string | null
    financers?: StringNullableListFilter<"aide">
    estimations_aides?: Estimations_aidesListRelationFilter
  }

  export type aideOrderByWithRelationInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
    submission_deadline?: SortOrderInput | SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    financers?: SortOrder
    estimations_aides?: estimations_aidesOrderByRelationAggregateInput
    _relevance?: aideOrderByRelevanceInput
  }

  export type aideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    aideTerritoireId?: number
    AND?: aideWhereInput | aideWhereInput[]
    OR?: aideWhereInput[]
    NOT?: aideWhereInput | aideWhereInput[]
    submission_deadline?: DateTimeNullableFilter<"aide"> | Date | string | null
    type?: StringFilter<"aide"> | string
    name?: StringNullableFilter<"aide"> | string | null
    financers?: StringNullableListFilter<"aide">
    estimations_aides?: Estimations_aidesListRelationFilter
  }, "id" | "aideTerritoireId">

  export type aideOrderByWithAggregationInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
    submission_deadline?: SortOrderInput | SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    financers?: SortOrder
    _count?: aideCountOrderByAggregateInput
    _avg?: aideAvgOrderByAggregateInput
    _max?: aideMaxOrderByAggregateInput
    _min?: aideMinOrderByAggregateInput
    _sum?: aideSumOrderByAggregateInput
  }

  export type aideScalarWhereWithAggregatesInput = {
    AND?: aideScalarWhereWithAggregatesInput | aideScalarWhereWithAggregatesInput[]
    OR?: aideScalarWhereWithAggregatesInput[]
    NOT?: aideScalarWhereWithAggregatesInput | aideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"aide"> | number
    aideTerritoireId?: IntWithAggregatesFilter<"aide"> | number
    submission_deadline?: DateTimeNullableWithAggregatesFilter<"aide"> | Date | string | null
    type?: StringWithAggregatesFilter<"aide"> | string
    name?: StringNullableWithAggregatesFilter<"aide"> | string | null
    financers?: StringNullableListFilter<"aide">
  }

  export type estimations_aidesWhereInput = {
    AND?: estimations_aidesWhereInput | estimations_aidesWhereInput[]
    OR?: estimations_aidesWhereInput[]
    NOT?: estimations_aidesWhereInput | estimations_aidesWhereInput[]
    id?: IntFilter<"estimations_aides"> | number
    estimationId?: IntFilter<"estimations_aides"> | number
    aideId?: IntFilter<"estimations_aides"> | number
    created_at?: DateTimeNullableFilter<"estimations_aides"> | Date | string | null
    user_id?: StringNullableFilter<"estimations_aides"> | string | null
    estimation?: XOR<EstimationScalarRelationFilter, estimationWhereInput>
    aide?: XOR<AideScalarRelationFilter, aideWhereInput>
    created_by?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type estimations_aidesOrderByWithRelationInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    estimation?: estimationOrderByWithRelationInput
    aide?: aideOrderByWithRelationInput
    created_by?: UserOrderByWithRelationInput
    _relevance?: estimations_aidesOrderByRelevanceInput
  }

  export type estimations_aidesWhereUniqueInput = Prisma.AtLeast<{
    estimationId_aideId?: estimations_aidesEstimationIdAideIdCompoundUniqueInput
    AND?: estimations_aidesWhereInput | estimations_aidesWhereInput[]
    OR?: estimations_aidesWhereInput[]
    NOT?: estimations_aidesWhereInput | estimations_aidesWhereInput[]
    id?: IntFilter<"estimations_aides"> | number
    estimationId?: IntFilter<"estimations_aides"> | number
    aideId?: IntFilter<"estimations_aides"> | number
    created_at?: DateTimeNullableFilter<"estimations_aides"> | Date | string | null
    user_id?: StringNullableFilter<"estimations_aides"> | string | null
    estimation?: XOR<EstimationScalarRelationFilter, estimationWhereInput>
    aide?: XOR<AideScalarRelationFilter, aideWhereInput>
    created_by?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "estimationId_aideId">

  export type estimations_aidesOrderByWithAggregationInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: estimations_aidesCountOrderByAggregateInput
    _avg?: estimations_aidesAvgOrderByAggregateInput
    _max?: estimations_aidesMaxOrderByAggregateInput
    _min?: estimations_aidesMinOrderByAggregateInput
    _sum?: estimations_aidesSumOrderByAggregateInput
  }

  export type estimations_aidesScalarWhereWithAggregatesInput = {
    AND?: estimations_aidesScalarWhereWithAggregatesInput | estimations_aidesScalarWhereWithAggregatesInput[]
    OR?: estimations_aidesScalarWhereWithAggregatesInput[]
    NOT?: estimations_aidesScalarWhereWithAggregatesInput | estimations_aidesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estimations_aides"> | number
    estimationId?: IntWithAggregatesFilter<"estimations_aides"> | number
    aideId?: IntWithAggregatesFilter<"estimations_aides"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"estimations_aides"> | Date | string | null
    user_id?: StringNullableWithAggregatesFilter<"estimations_aides"> | string | null
  }

  export type estimation_materiauxWhereInput = {
    AND?: estimation_materiauxWhereInput | estimation_materiauxWhereInput[]
    OR?: estimation_materiauxWhereInput[]
    NOT?: estimation_materiauxWhereInput | estimation_materiauxWhereInput[]
    id?: StringFilter<"estimation_materiaux"> | string
    estimation_fiche_solution_id?: StringFilter<"estimation_materiaux"> | string
    materiau_id?: IntFilter<"estimation_materiaux"> | number
    quantite?: IntFilter<"estimation_materiaux"> | number
    cout_investissement_override?: IntNullableFilter<"estimation_materiaux"> | number | null
    cout_entretien_override?: IntNullableFilter<"estimation_materiaux"> | number | null
    estimation_fiche_solution?: XOR<Estimation_fiche_solutionScalarRelationFilter, estimation_fiche_solutionWhereInput>
  }

  export type estimation_materiauxOrderByWithRelationInput = {
    id?: SortOrder
    estimation_fiche_solution_id?: SortOrder
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrderInput | SortOrder
    cout_entretien_override?: SortOrderInput | SortOrder
    estimation_fiche_solution?: estimation_fiche_solutionOrderByWithRelationInput
    _relevance?: estimation_materiauxOrderByRelevanceInput
  }

  export type estimation_materiauxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: estimation_materiauxWhereInput | estimation_materiauxWhereInput[]
    OR?: estimation_materiauxWhereInput[]
    NOT?: estimation_materiauxWhereInput | estimation_materiauxWhereInput[]
    estimation_fiche_solution_id?: StringFilter<"estimation_materiaux"> | string
    materiau_id?: IntFilter<"estimation_materiaux"> | number
    quantite?: IntFilter<"estimation_materiaux"> | number
    cout_investissement_override?: IntNullableFilter<"estimation_materiaux"> | number | null
    cout_entretien_override?: IntNullableFilter<"estimation_materiaux"> | number | null
    estimation_fiche_solution?: XOR<Estimation_fiche_solutionScalarRelationFilter, estimation_fiche_solutionWhereInput>
  }, "id">

  export type estimation_materiauxOrderByWithAggregationInput = {
    id?: SortOrder
    estimation_fiche_solution_id?: SortOrder
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrderInput | SortOrder
    cout_entretien_override?: SortOrderInput | SortOrder
    _count?: estimation_materiauxCountOrderByAggregateInput
    _avg?: estimation_materiauxAvgOrderByAggregateInput
    _max?: estimation_materiauxMaxOrderByAggregateInput
    _min?: estimation_materiauxMinOrderByAggregateInput
    _sum?: estimation_materiauxSumOrderByAggregateInput
  }

  export type estimation_materiauxScalarWhereWithAggregatesInput = {
    AND?: estimation_materiauxScalarWhereWithAggregatesInput | estimation_materiauxScalarWhereWithAggregatesInput[]
    OR?: estimation_materiauxScalarWhereWithAggregatesInput[]
    NOT?: estimation_materiauxScalarWhereWithAggregatesInput | estimation_materiauxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"estimation_materiaux"> | string
    estimation_fiche_solution_id?: StringWithAggregatesFilter<"estimation_materiaux"> | string
    materiau_id?: IntWithAggregatesFilter<"estimation_materiaux"> | number
    quantite?: IntWithAggregatesFilter<"estimation_materiaux"> | number
    cout_investissement_override?: IntNullableWithAggregatesFilter<"estimation_materiaux"> | number | null
    cout_entretien_override?: IntNullableWithAggregatesFilter<"estimation_materiaux"> | number | null
  }

  export type estimation_fiche_solutionWhereInput = {
    AND?: estimation_fiche_solutionWhereInput | estimation_fiche_solutionWhereInput[]
    OR?: estimation_fiche_solutionWhereInput[]
    NOT?: estimation_fiche_solutionWhereInput | estimation_fiche_solutionWhereInput[]
    id?: StringFilter<"estimation_fiche_solution"> | string
    estimation_id?: IntFilter<"estimation_fiche_solution"> | number
    fiche_solution_id?: IntFilter<"estimation_fiche_solution"> | number
    quantite?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    cout_min_investissement?: IntFilter<"estimation_fiche_solution"> | number
    cout_max_investissement?: IntFilter<"estimation_fiche_solution"> | number
    cout_min_entretien?: IntFilter<"estimation_fiche_solution"> | number
    cout_max_entretien?: IntFilter<"estimation_fiche_solution"> | number
    cout_investissement_override?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    cout_entretien_override?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    estimation?: XOR<EstimationScalarRelationFilter, estimationWhereInput>
    estimation_materiaux?: Estimation_materiauxListRelationFilter
  }

  export type estimation_fiche_solutionOrderByWithRelationInput = {
    id?: SortOrder
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrderInput | SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrderInput | SortOrder
    cout_entretien_override?: SortOrderInput | SortOrder
    estimation?: estimationOrderByWithRelationInput
    estimation_materiaux?: estimation_materiauxOrderByRelationAggregateInput
    _relevance?: estimation_fiche_solutionOrderByRelevanceInput
  }

  export type estimation_fiche_solutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    estimation_id_fiche_solution_id?: estimation_fiche_solutionEstimation_idFiche_solution_idCompoundUniqueInput
    AND?: estimation_fiche_solutionWhereInput | estimation_fiche_solutionWhereInput[]
    OR?: estimation_fiche_solutionWhereInput[]
    NOT?: estimation_fiche_solutionWhereInput | estimation_fiche_solutionWhereInput[]
    estimation_id?: IntFilter<"estimation_fiche_solution"> | number
    fiche_solution_id?: IntFilter<"estimation_fiche_solution"> | number
    quantite?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    cout_min_investissement?: IntFilter<"estimation_fiche_solution"> | number
    cout_max_investissement?: IntFilter<"estimation_fiche_solution"> | number
    cout_min_entretien?: IntFilter<"estimation_fiche_solution"> | number
    cout_max_entretien?: IntFilter<"estimation_fiche_solution"> | number
    cout_investissement_override?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    cout_entretien_override?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    estimation?: XOR<EstimationScalarRelationFilter, estimationWhereInput>
    estimation_materiaux?: Estimation_materiauxListRelationFilter
  }, "id" | "estimation_id_fiche_solution_id">

  export type estimation_fiche_solutionOrderByWithAggregationInput = {
    id?: SortOrder
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrderInput | SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrderInput | SortOrder
    cout_entretien_override?: SortOrderInput | SortOrder
    _count?: estimation_fiche_solutionCountOrderByAggregateInput
    _avg?: estimation_fiche_solutionAvgOrderByAggregateInput
    _max?: estimation_fiche_solutionMaxOrderByAggregateInput
    _min?: estimation_fiche_solutionMinOrderByAggregateInput
    _sum?: estimation_fiche_solutionSumOrderByAggregateInput
  }

  export type estimation_fiche_solutionScalarWhereWithAggregatesInput = {
    AND?: estimation_fiche_solutionScalarWhereWithAggregatesInput | estimation_fiche_solutionScalarWhereWithAggregatesInput[]
    OR?: estimation_fiche_solutionScalarWhereWithAggregatesInput[]
    NOT?: estimation_fiche_solutionScalarWhereWithAggregatesInput | estimation_fiche_solutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"estimation_fiche_solution"> | string
    estimation_id?: IntWithAggregatesFilter<"estimation_fiche_solution"> | number
    fiche_solution_id?: IntWithAggregatesFilter<"estimation_fiche_solution"> | number
    quantite?: IntNullableWithAggregatesFilter<"estimation_fiche_solution"> | number | null
    cout_min_investissement?: IntWithAggregatesFilter<"estimation_fiche_solution"> | number
    cout_max_investissement?: IntWithAggregatesFilter<"estimation_fiche_solution"> | number
    cout_min_entretien?: IntWithAggregatesFilter<"estimation_fiche_solution"> | number
    cout_max_entretien?: IntWithAggregatesFilter<"estimation_fiche_solution"> | number
    cout_investissement_override?: IntNullableWithAggregatesFilter<"estimation_fiche_solution"> | number | null
    cout_entretien_override?: IntNullableWithAggregatesFilter<"estimation_fiche_solution"> | number | null
  }

  export type conversationWhereInput = {
    AND?: conversationWhereInput | conversationWhereInput[]
    OR?: conversationWhereInput[]
    NOT?: conversationWhereInput | conversationWhereInput[]
    id?: StringFilter<"conversation"> | string
    userId?: StringNullableFilter<"conversation"> | string | null
    ragtimeId?: StringFilter<"conversation"> | string
    created_at?: DateTimeFilter<"conversation"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type conversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ragtimeId?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: conversationOrderByRelevanceInput
  }

  export type conversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ragtimeId?: string
    AND?: conversationWhereInput | conversationWhereInput[]
    OR?: conversationWhereInput[]
    NOT?: conversationWhereInput | conversationWhereInput[]
    userId?: StringNullableFilter<"conversation"> | string | null
    created_at?: DateTimeFilter<"conversation"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "ragtimeId">

  export type conversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    ragtimeId?: SortOrder
    created_at?: SortOrder
    _count?: conversationCountOrderByAggregateInput
    _max?: conversationMaxOrderByAggregateInput
    _min?: conversationMinOrderByAggregateInput
  }

  export type conversationScalarWhereWithAggregatesInput = {
    AND?: conversationScalarWhereWithAggregatesInput | conversationScalarWhereWithAggregatesInput[]
    OR?: conversationScalarWhereWithAggregatesInput[]
    NOT?: conversationScalarWhereWithAggregatesInput | conversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"conversation"> | string
    userId?: StringNullableWithAggregatesFilter<"conversation"> | string | null
    ragtimeId?: StringWithAggregatesFilter<"conversation"> | string
    created_at?: DateTimeWithAggregatesFilter<"conversation"> | Date | string
  }

  export type diagnostic_simulationWhereInput = {
    AND?: diagnostic_simulationWhereInput | diagnostic_simulationWhereInput[]
    OR?: diagnostic_simulationWhereInput[]
    NOT?: diagnostic_simulationWhereInput | diagnostic_simulationWhereInput[]
    id?: StringFilter<"diagnostic_simulation"> | string
    user_id?: StringNullableFilter<"diagnostic_simulation"> | string | null
    projet_id?: IntFilter<"diagnostic_simulation"> | number
    initial_values?: JsonNullableFilter<"diagnostic_simulation">
    validated?: BoolFilter<"diagnostic_simulation"> | boolean
    created_at?: DateTimeFilter<"diagnostic_simulation"> | Date | string
    updated_at?: DateTimeFilter<"diagnostic_simulation"> | Date | string
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type diagnostic_simulationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    projet_id?: SortOrder
    initial_values?: SortOrderInput | SortOrder
    validated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projet?: projetOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: diagnostic_simulationOrderByRelevanceInput
  }

  export type diagnostic_simulationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: diagnostic_simulationWhereInput | diagnostic_simulationWhereInput[]
    OR?: diagnostic_simulationWhereInput[]
    NOT?: diagnostic_simulationWhereInput | diagnostic_simulationWhereInput[]
    user_id?: StringNullableFilter<"diagnostic_simulation"> | string | null
    projet_id?: IntFilter<"diagnostic_simulation"> | number
    initial_values?: JsonNullableFilter<"diagnostic_simulation">
    validated?: BoolFilter<"diagnostic_simulation"> | boolean
    created_at?: DateTimeFilter<"diagnostic_simulation"> | Date | string
    updated_at?: DateTimeFilter<"diagnostic_simulation"> | Date | string
    projet?: XOR<ProjetScalarRelationFilter, projetWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type diagnostic_simulationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    projet_id?: SortOrder
    initial_values?: SortOrderInput | SortOrder
    validated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: diagnostic_simulationCountOrderByAggregateInput
    _avg?: diagnostic_simulationAvgOrderByAggregateInput
    _max?: diagnostic_simulationMaxOrderByAggregateInput
    _min?: diagnostic_simulationMinOrderByAggregateInput
    _sum?: diagnostic_simulationSumOrderByAggregateInput
  }

  export type diagnostic_simulationScalarWhereWithAggregatesInput = {
    AND?: diagnostic_simulationScalarWhereWithAggregatesInput | diagnostic_simulationScalarWhereWithAggregatesInput[]
    OR?: diagnostic_simulationScalarWhereWithAggregatesInput[]
    NOT?: diagnostic_simulationScalarWhereWithAggregatesInput | diagnostic_simulationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"diagnostic_simulation"> | string
    user_id?: StringNullableWithAggregatesFilter<"diagnostic_simulation"> | string | null
    projet_id?: IntWithAggregatesFilter<"diagnostic_simulation"> | number
    initial_values?: JsonNullableWithAggregatesFilter<"diagnostic_simulation">
    validated?: BoolWithAggregatesFilter<"diagnostic_simulation"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"diagnostic_simulation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"diagnostic_simulation"> | Date | string
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    created_at?: DateTimeFilter<"Analytics"> | Date | string
    reference_id?: StringFilter<"Analytics"> | string
    reference_type?: EnumReferenceTypeFilter<"Analytics"> | $Enums.ReferenceType
    event_type?: EnumEventTypeFilter<"Analytics"> | $Enums.EventType
    context?: JsonNullableFilter<"Analytics">
    user_id?: StringFilter<"Analytics"> | string
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    event_type?: SortOrder
    context?: SortOrderInput | SortOrder
    user_id?: SortOrder
    created_by?: UserOrderByWithRelationInput
    _relevance?: AnalyticsOrderByRelevanceInput
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    created_at?: DateTimeFilter<"Analytics"> | Date | string
    reference_id?: StringFilter<"Analytics"> | string
    reference_type?: EnumReferenceTypeFilter<"Analytics"> | $Enums.ReferenceType
    event_type?: EnumEventTypeFilter<"Analytics"> | $Enums.EventType
    context?: JsonNullableFilter<"Analytics">
    user_id?: StringFilter<"Analytics"> | string
    created_by?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    event_type?: SortOrder
    context?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    created_at?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
    reference_id?: StringWithAggregatesFilter<"Analytics"> | string
    reference_type?: EnumReferenceTypeWithAggregatesFilter<"Analytics"> | $Enums.ReferenceType
    event_type?: EnumEventTypeWithAggregatesFilter<"Analytics"> | $Enums.EventType
    context?: JsonNullableWithAggregatesFilter<"Analytics">
    user_id?: StringWithAggregatesFilter<"Analytics"> | string
  }

  export type cron_jobsWhereInput = {
    AND?: cron_jobsWhereInput | cron_jobsWhereInput[]
    OR?: cron_jobsWhereInput[]
    NOT?: cron_jobsWhereInput | cron_jobsWhereInput[]
    id?: StringFilter<"cron_jobs"> | string
    execution_start_time?: DateTimeFilter<"cron_jobs"> | Date | string
    execution_end_time?: DateTimeFilter<"cron_jobs"> | Date | string
    job_type?: EnumJobTypeFilter<"cron_jobs"> | $Enums.JobType
  }

  export type cron_jobsOrderByWithRelationInput = {
    id?: SortOrder
    execution_start_time?: SortOrder
    execution_end_time?: SortOrder
    job_type?: SortOrder
    _relevance?: cron_jobsOrderByRelevanceInput
  }

  export type cron_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cron_jobsWhereInput | cron_jobsWhereInput[]
    OR?: cron_jobsWhereInput[]
    NOT?: cron_jobsWhereInput | cron_jobsWhereInput[]
    execution_start_time?: DateTimeFilter<"cron_jobs"> | Date | string
    execution_end_time?: DateTimeFilter<"cron_jobs"> | Date | string
    job_type?: EnumJobTypeFilter<"cron_jobs"> | $Enums.JobType
  }, "id">

  export type cron_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    execution_start_time?: SortOrder
    execution_end_time?: SortOrder
    job_type?: SortOrder
    _count?: cron_jobsCountOrderByAggregateInput
    _max?: cron_jobsMaxOrderByAggregateInput
    _min?: cron_jobsMinOrderByAggregateInput
  }

  export type cron_jobsScalarWhereWithAggregatesInput = {
    AND?: cron_jobsScalarWhereWithAggregatesInput | cron_jobsScalarWhereWithAggregatesInput[]
    OR?: cron_jobsScalarWhereWithAggregatesInput[]
    NOT?: cron_jobsScalarWhereWithAggregatesInput | cron_jobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cron_jobs"> | string
    execution_start_time?: DateTimeWithAggregatesFilter<"cron_jobs"> | Date | string
    execution_end_time?: DateTimeWithAggregatesFilter<"cron_jobs"> | Date | string
    job_type?: EnumJobTypeWithAggregatesFilter<"cron_jobs"> | $Enums.JobType
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collectiviteCreateInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    users?: user_collectiviteCreateNestedManyWithoutCollectiviteInput
    creator: UserCreateNestedOneWithoutCollectivites_createdInput
    projet?: projetCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteUncheckedCreateInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_by: string
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    users?: user_collectiviteUncheckedCreateNestedManyWithoutCollectiviteInput
    projet?: projetUncheckedCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: user_collectiviteUpdateManyWithoutCollectiviteNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectivites_createdNestedInput
    projet?: projetUpdateManyWithoutCollectiviteNestedInput
  }

  export type collectiviteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: user_collectiviteUncheckedUpdateManyWithoutCollectiviteNestedInput
    projet?: projetUncheckedUpdateManyWithoutCollectiviteNestedInput
  }

  export type collectiviteCreateManyInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_by: string
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
  }

  export type collectiviteUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectiviteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_projetCreateInput = {
    email_address?: string | null
    role: $Enums.RoleProjet
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    projet: projetCreateNestedOneWithoutUsersInput
    user?: UserCreateNestedOneWithoutProjetsInput
    deleter?: UserCreateNestedOneWithoutUser_projet_deletedInput
    email?: emailCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetUncheckedCreateInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    email?: emailUncheckedCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetUpdateInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet?: projetUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneWithoutProjetsNestedInput
    deleter?: UserUpdateOneWithoutUser_projet_deletedNestedInput
    email?: emailUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: emailUncheckedUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetCreateManyInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
  }

  export type user_projetUpdateManyMutationInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_projetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type emailCreateInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
    user_projet?: user_projetCreateNestedOneWithoutEmailInput
    user?: UserCreateNestedOneWithoutEmailsInput
  }

  export type emailUncheckedCreateInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    user_projet_id?: number | null
    user_id?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
    user_projet?: user_projetUpdateOneWithoutEmailNestedInput
    user?: UserUpdateOneWithoutEmailsNestedInput
  }

  export type emailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    user_projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailCreateManyInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    user_projet_id?: number | null
    user_id?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    user_projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_collectiviteCreateInput = {
    verified?: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCollectivitesInput
    collectivite: collectiviteCreateNestedOneWithoutUsersInput
  }

  export type user_collectiviteUncheckedCreateInput = {
    user_id: string
    collectivite_id: number
    verified?: boolean
    created_at?: Date | string
  }

  export type user_collectiviteUpdateInput = {
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCollectivitesNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type user_collectiviteUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    collectivite_id?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_collectiviteCreateManyInput = {
    user_id: string
    collectivite_id: number
    verified?: boolean
    created_at?: Date | string
  }

  export type user_collectiviteUpdateManyMutationInput = {
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_collectiviteUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    collectivite_id?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projetCreateInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetCreateManyInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
  }

  export type projetUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projet_ficheCreateInput = {
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    projet: projetCreateNestedOneWithoutFichesInput
    created_by: UserCreateNestedOneWithoutFichesInput
  }

  export type projet_ficheUncheckedCreateInput = {
    id?: number
    projet_id: number
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    user_id: string
  }

  export type projet_ficheUpdateInput = {
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutFichesNestedInput
    created_by?: UserUpdateOneRequiredWithoutFichesNestedInput
  }

  export type projet_ficheUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type projet_ficheCreateManyInput = {
    id?: number
    projet_id: number
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    user_id: string
  }

  export type projet_ficheUpdateManyMutationInput = {
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_ficheUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type projet_sourcing_contactCreateInput = {
    created_at?: Date | string
    projet: projetCreateNestedOneWithoutSourcing_user_projetsInput
    sourced_user_projet: user_projetCreateNestedOneWithoutSourced_by_projetsInput
    creator: UserCreateNestedOneWithoutSourcing_contacts_createdInput
  }

  export type projet_sourcing_contactUncheckedCreateInput = {
    id?: number
    projet_id: number
    sourced_user_projet_id: number
    created_at?: Date | string
    created_by: string
  }

  export type projet_sourcing_contactUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutSourcing_user_projetsNestedInput
    sourced_user_projet?: user_projetUpdateOneRequiredWithoutSourced_by_projetsNestedInput
    creator?: UserUpdateOneRequiredWithoutSourcing_contacts_createdNestedInput
  }

  export type projet_sourcing_contactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    sourced_user_projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type projet_sourcing_contactCreateManyInput = {
    id?: number
    projet_id: number
    sourced_user_projet_id: number
    created_at?: Date | string
    created_by: string
  }

  export type projet_sourcing_contactUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_sourcing_contactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    sourced_user_projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type estimationCreateInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    creator: UserCreateNestedOneWithoutEstimations_createdInput
    projet: projetCreateNestedOneWithoutEstimationsInput
    deleter?: UserCreateNestedOneWithoutEstimations_deletedInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionCreateNestedManyWithoutEstimationInput
  }

  export type estimationUncheckedCreateInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedCreateNestedManyWithoutEstimationInput
  }

  export type estimationUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutEstimations_createdNestedInput
    projet?: projetUpdateOneRequiredWithoutEstimationsNestedInput
    deleter?: UserUpdateOneWithoutEstimations_deletedNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationNestedInput
  }

  export type estimationCreateManyInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type estimationUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type climadiagCreateInput = {
    nom: string
    type_lieu: $Enums.TypeLieuClimadiag
    code_insee: string
    code_postal: string
    epci_parent_id?: number | null
    jours_tres_chauds_ref?: number | null
    jours_tres_chauds_prevision: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: number | null
    nuits_chaudes_prevision: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: number | null
    jours_vdc_prevision: JsonNullValueInput | InputJsonValue
    population?: number
    superficie?: number
    couverture_lcz?: number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field: string
  }

  export type climadiagUncheckedCreateInput = {
    id?: number
    nom: string
    type_lieu: $Enums.TypeLieuClimadiag
    code_insee: string
    code_postal: string
    epci_parent_id?: number | null
    jours_tres_chauds_ref?: number | null
    jours_tres_chauds_prevision: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: number | null
    nuits_chaudes_prevision: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: number | null
    jours_vdc_prevision: JsonNullValueInput | InputJsonValue
    population?: number
    superficie?: number
    couverture_lcz?: number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field: string
  }

  export type climadiagUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type_lieu?: EnumTypeLieuClimadiagFieldUpdateOperationsInput | $Enums.TypeLieuClimadiag
    code_insee?: StringFieldUpdateOperationsInput | string
    code_postal?: StringFieldUpdateOperationsInput | string
    epci_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    jours_tres_chauds_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_tres_chauds_prevision?: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    nuits_chaudes_prevision?: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_vdc_prevision?: JsonNullValueInput | InputJsonValue
    population?: IntFieldUpdateOperationsInput | number
    superficie?: IntFieldUpdateOperationsInput | number
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field?: StringFieldUpdateOperationsInput | string
  }

  export type climadiagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type_lieu?: EnumTypeLieuClimadiagFieldUpdateOperationsInput | $Enums.TypeLieuClimadiag
    code_insee?: StringFieldUpdateOperationsInput | string
    code_postal?: StringFieldUpdateOperationsInput | string
    epci_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    jours_tres_chauds_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_tres_chauds_prevision?: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    nuits_chaudes_prevision?: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_vdc_prevision?: JsonNullValueInput | InputJsonValue
    population?: IntFieldUpdateOperationsInput | number
    superficie?: IntFieldUpdateOperationsInput | number
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field?: StringFieldUpdateOperationsInput | string
  }

  export type climadiagCreateManyInput = {
    id?: number
    nom: string
    type_lieu: $Enums.TypeLieuClimadiag
    code_insee: string
    code_postal: string
    epci_parent_id?: number | null
    jours_tres_chauds_ref?: number | null
    jours_tres_chauds_prevision: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: number | null
    nuits_chaudes_prevision: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: number | null
    jours_vdc_prevision: JsonNullValueInput | InputJsonValue
    population?: number
    superficie?: number
    couverture_lcz?: number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field: string
  }

  export type climadiagUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    type_lieu?: EnumTypeLieuClimadiagFieldUpdateOperationsInput | $Enums.TypeLieuClimadiag
    code_insee?: StringFieldUpdateOperationsInput | string
    code_postal?: StringFieldUpdateOperationsInput | string
    epci_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    jours_tres_chauds_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_tres_chauds_prevision?: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    nuits_chaudes_prevision?: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_vdc_prevision?: JsonNullValueInput | InputJsonValue
    population?: IntFieldUpdateOperationsInput | number
    superficie?: IntFieldUpdateOperationsInput | number
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field?: StringFieldUpdateOperationsInput | string
  }

  export type climadiagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    type_lieu?: EnumTypeLieuClimadiagFieldUpdateOperationsInput | $Enums.TypeLieuClimadiag
    code_insee?: StringFieldUpdateOperationsInput | string
    code_postal?: StringFieldUpdateOperationsInput | string
    epci_parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    jours_tres_chauds_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_tres_chauds_prevision?: JsonNullValueInput | InputJsonValue
    nuits_chaudes_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    nuits_chaudes_prevision?: JsonNullValueInput | InputJsonValue
    jours_vdc_ref?: NullableFloatFieldUpdateOperationsInput | number | null
    jours_vdc_prevision?: JsonNullValueInput | InputJsonValue
    population?: IntFieldUpdateOperationsInput | number
    superficie?: IntFieldUpdateOperationsInput | number
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    searchable_field?: StringFieldUpdateOperationsInput | string
  }

  export type aideCreateInput = {
    aideTerritoireId: number
    submission_deadline?: Date | string | null
    type: string
    name?: string | null
    financers?: aideCreatefinancersInput | string[]
    estimations_aides?: estimations_aidesCreateNestedManyWithoutAideInput
  }

  export type aideUncheckedCreateInput = {
    id?: number
    aideTerritoireId: number
    submission_deadline?: Date | string | null
    type: string
    name?: string | null
    financers?: aideCreatefinancersInput | string[]
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutAideInput
  }

  export type aideUpdateInput = {
    aideTerritoireId?: IntFieldUpdateOperationsInput | number
    submission_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financers?: aideUpdatefinancersInput | string[]
    estimations_aides?: estimations_aidesUpdateManyWithoutAideNestedInput
  }

  export type aideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    aideTerritoireId?: IntFieldUpdateOperationsInput | number
    submission_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financers?: aideUpdatefinancersInput | string[]
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutAideNestedInput
  }

  export type aideCreateManyInput = {
    id?: number
    aideTerritoireId: number
    submission_deadline?: Date | string | null
    type: string
    name?: string | null
    financers?: aideCreatefinancersInput | string[]
  }

  export type aideUpdateManyMutationInput = {
    aideTerritoireId?: IntFieldUpdateOperationsInput | number
    submission_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financers?: aideUpdatefinancersInput | string[]
  }

  export type aideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    aideTerritoireId?: IntFieldUpdateOperationsInput | number
    submission_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financers?: aideUpdatefinancersInput | string[]
  }

  export type estimations_aidesCreateInput = {
    id?: number
    created_at?: Date | string | null
    estimation: estimationCreateNestedOneWithoutEstimations_aidesInput
    aide: aideCreateNestedOneWithoutEstimations_aidesInput
    created_by?: UserCreateNestedOneWithoutEstimations_aidesInput
  }

  export type estimations_aidesUncheckedCreateInput = {
    id?: number
    estimationId: number
    aideId: number
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type estimations_aidesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimation?: estimationUpdateOneRequiredWithoutEstimations_aidesNestedInput
    aide?: aideUpdateOneRequiredWithoutEstimations_aidesNestedInput
    created_by?: UserUpdateOneWithoutEstimations_aidesNestedInput
  }

  export type estimations_aidesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimationId?: IntFieldUpdateOperationsInput | number
    aideId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimations_aidesCreateManyInput = {
    id?: number
    estimationId: number
    aideId: number
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type estimations_aidesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimations_aidesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimationId?: IntFieldUpdateOperationsInput | number
    aideId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimation_materiauxCreateInput = {
    id?: string
    materiau_id: number
    quantite: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
    estimation_fiche_solution: estimation_fiche_solutionCreateNestedOneWithoutEstimation_materiauxInput
  }

  export type estimation_materiauxUncheckedCreateInput = {
    id?: string
    estimation_fiche_solution_id: string
    materiau_id: number
    quantite: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_materiauxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
    estimation_fiche_solution?: estimation_fiche_solutionUpdateOneRequiredWithoutEstimation_materiauxNestedInput
  }

  export type estimation_materiauxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimation_fiche_solution_id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimation_materiauxCreateManyInput = {
    id?: string
    estimation_fiche_solution_id: string
    materiau_id: number
    quantite: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_materiauxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimation_materiauxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimation_fiche_solution_id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimation_fiche_solutionCreateInput = {
    id?: string
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
    estimation: estimationCreateNestedOneWithoutEstimations_fiches_solutionsInput
    estimation_materiaux?: estimation_materiauxCreateNestedManyWithoutEstimation_fiche_solutionInput
  }

  export type estimation_fiche_solutionUncheckedCreateInput = {
    id?: string
    estimation_id: number
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
    estimation_materiaux?: estimation_materiauxUncheckedCreateNestedManyWithoutEstimation_fiche_solutionInput
  }

  export type estimation_fiche_solutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
    estimation?: estimationUpdateOneRequiredWithoutEstimations_fiches_solutionsNestedInput
    estimation_materiaux?: estimation_materiauxUpdateManyWithoutEstimation_fiche_solutionNestedInput
  }

  export type estimation_fiche_solutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimation_id?: IntFieldUpdateOperationsInput | number
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
    estimation_materiaux?: estimation_materiauxUncheckedUpdateManyWithoutEstimation_fiche_solutionNestedInput
  }

  export type estimation_fiche_solutionCreateManyInput = {
    id?: string
    estimation_id: number
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_fiche_solutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimation_fiche_solutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimation_id?: IntFieldUpdateOperationsInput | number
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type conversationCreateInput = {
    id?: string
    ragtimeId: string
    created_at?: Date | string
    user?: UserCreateNestedOneWithoutConversationsInput
  }

  export type conversationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    ragtimeId: string
    created_at?: Date | string
  }

  export type conversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutConversationsNestedInput
  }

  export type conversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationCreateManyInput = {
    id?: string
    userId?: string | null
    ragtimeId: string
    created_at?: Date | string
  }

  export type conversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnostic_simulationCreateInput = {
    id?: string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    projet: projetCreateNestedOneWithoutDiagnostic_simulationsInput
    user?: UserCreateNestedOneWithoutDiagnostic_simulationInput
  }

  export type diagnostic_simulationUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    projet_id: number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type diagnostic_simulationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutDiagnostic_simulationsNestedInput
    user?: UserUpdateOneWithoutDiagnostic_simulationNestedInput
  }

  export type diagnostic_simulationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    projet_id?: IntFieldUpdateOperationsInput | number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnostic_simulationCreateManyInput = {
    id?: string
    user_id?: string | null
    projet_id: number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type diagnostic_simulationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnostic_simulationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    projet_id?: IntFieldUpdateOperationsInput | number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateInput = {
    id?: string
    created_at?: Date | string
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
    created_by: UserCreateNestedOneWithoutAnalyticsInput
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
    user_id: string
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
    created_by?: UserUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    created_at?: Date | string
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
    user_id: string
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type cron_jobsCreateInput = {
    id?: string
    execution_start_time?: Date | string
    execution_end_time: Date | string
    job_type: $Enums.JobType
  }

  export type cron_jobsUncheckedCreateInput = {
    id?: string
    execution_start_time?: Date | string
    execution_end_time: Date | string
    job_type: $Enums.JobType
  }

  export type cron_jobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    execution_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
  }

  export type cron_jobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    execution_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
  }

  export type cron_jobsCreateManyInput = {
    id?: string
    execution_start_time?: Date | string
    execution_end_time: Date | string
    job_type: $Enums.JobType
  }

  export type cron_jobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    execution_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
  }

  export type cron_jobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    execution_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    job_type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumStatutUserNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutUser | EnumStatutUserFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutUserNullableFilter<$PrismaModel> | $Enums.StatutUser | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type CollectiviteListRelationFilter = {
    every?: collectiviteWhereInput
    some?: collectiviteWhereInput
    none?: collectiviteWhereInput
  }

  export type ProjetListRelationFilter = {
    every?: projetWhereInput
    some?: projetWhereInput
    none?: projetWhereInput
  }

  export type EstimationListRelationFilter = {
    every?: estimationWhereInput
    some?: estimationWhereInput
    none?: estimationWhereInput
  }

  export type User_collectiviteListRelationFilter = {
    every?: user_collectiviteWhereInput
    some?: user_collectiviteWhereInput
    none?: user_collectiviteWhereInput
  }

  export type User_projetListRelationFilter = {
    every?: user_projetWhereInput
    some?: user_projetWhereInput
    none?: user_projetWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: conversationWhereInput
    some?: conversationWhereInput
    none?: conversationWhereInput
  }

  export type AnalyticsListRelationFilter = {
    every?: AnalyticsWhereInput
    some?: AnalyticsWhereInput
    none?: AnalyticsWhereInput
  }

  export type Projet_sourcing_contactListRelationFilter = {
    every?: projet_sourcing_contactWhereInput
    some?: projet_sourcing_contactWhereInput
    none?: projet_sourcing_contactWhereInput
  }

  export type EmailListRelationFilter = {
    every?: emailWhereInput
    some?: emailWhereInput
    none?: emailWhereInput
  }

  export type Estimations_aidesListRelationFilter = {
    every?: estimations_aidesWhereInput
    some?: estimations_aidesWhereInput
    none?: estimations_aidesWhereInput
  }

  export type Projet_ficheListRelationFilter = {
    every?: projet_ficheWhereInput
    some?: projet_ficheWhereInput
    none?: projet_ficheWhereInput
  }

  export type Diagnostic_simulationListRelationFilter = {
    every?: diagnostic_simulationWhereInput
    some?: diagnostic_simulationWhereInput
    none?: diagnostic_simulationWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collectiviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estimationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_collectiviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_projetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projet_sourcing_contactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type emailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estimations_aidesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projet_ficheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type diagnostic_simulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    agentconnect_info?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    poste?: SortOrder
    nom_etablissement?: SortOrder
    siren_info?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    canal_acquisition?: SortOrder
    discardedInformation?: SortOrder
    accept_communication_produit?: SortOrder
    accept_communication_suivi_projet?: SortOrder
    statut?: SortOrder
    statut_updated_at?: SortOrder
    last_browsing_date?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    poste?: SortOrder
    nom_etablissement?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    canal_acquisition?: SortOrder
    accept_communication_produit?: SortOrder
    accept_communication_suivi_projet?: SortOrder
    statut?: SortOrder
    statut_updated_at?: SortOrder
    last_browsing_date?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    poste?: SortOrder
    nom_etablissement?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    canal_acquisition?: SortOrder
    accept_communication_produit?: SortOrder
    accept_communication_suivi_projet?: SortOrder
    statut?: SortOrder
    statut_updated_at?: SortOrder
    last_browsing_date?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStatutUserNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutUser | EnumStatutUserFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutUserNullableWithAggregatesFilter<$PrismaModel> | $Enums.StatutUser | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatutUserNullableFilter<$PrismaModel>
    _max?: NestedEnumStatutUserNullableFilter<$PrismaModel>
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type collectiviteOrderByRelevanceInput = {
    fields: collectiviteOrderByRelevanceFieldEnum | collectiviteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type collectiviteCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    adresse_info?: SortOrder
    adresse_all_infos?: SortOrder
    ban_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    aides_territoires_perimeter_id?: SortOrder
  }

  export type collectiviteAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type collectiviteMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    ban_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    aides_territoires_perimeter_id?: SortOrder
  }

  export type collectiviteMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    ban_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    aides_territoires_perimeter_id?: SortOrder
  }

  export type collectiviteSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumRoleProjetFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleProjet | EnumRoleProjetFieldRefInput<$PrismaModel>
    in?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleProjetFilter<$PrismaModel> | $Enums.RoleProjet
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type ProjetScalarRelationFilter = {
    is?: projetWhereInput
    isNot?: projetWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type user_projetOrderByRelevanceInput = {
    fields: user_projetOrderByRelevanceFieldEnum | user_projetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_projetUser_idProjet_idCompoundUniqueInput = {
    user_id: string
    projet_id: number
  }

  export type user_projetCountOrderByAggregateInput = {
    id?: SortOrder
    email_address?: SortOrder
    role?: SortOrder
    projet_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    invitation_token?: SortOrder
    invitation_status?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    nb_views?: SortOrder
    last_viewed_at?: SortOrder
  }

  export type user_projetAvgOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    nb_views?: SortOrder
  }

  export type user_projetMaxOrderByAggregateInput = {
    id?: SortOrder
    email_address?: SortOrder
    role?: SortOrder
    projet_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    invitation_token?: SortOrder
    invitation_status?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    nb_views?: SortOrder
    last_viewed_at?: SortOrder
  }

  export type user_projetMinOrderByAggregateInput = {
    id?: SortOrder
    email_address?: SortOrder
    role?: SortOrder
    projet_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    invitation_token?: SortOrder
    invitation_status?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    nb_views?: SortOrder
    last_viewed_at?: SortOrder
  }

  export type user_projetSumOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    nb_views?: SortOrder
  }

  export type EnumRoleProjetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleProjet | EnumRoleProjetFieldRefInput<$PrismaModel>
    in?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleProjetWithAggregatesFilter<$PrismaModel> | $Enums.RoleProjet
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleProjetFilter<$PrismaModel>
    _max?: NestedEnumRoleProjetFilter<$PrismaModel>
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type EnumemailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.emailType | EnumemailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumemailTypeFilter<$PrismaModel> | $Enums.emailType
  }

  export type EnumemailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.emailStatus | EnumemailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumemailStatusFilter<$PrismaModel> | $Enums.emailStatus
  }

  export type User_projetNullableScalarRelationFilter = {
    is?: user_projetWhereInput | null
    isNot?: user_projetWhereInput | null
  }

  export type emailOrderByRelevanceInput = {
    fields: emailOrderByRelevanceFieldEnum | emailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type emailCountOrderByAggregateInput = {
    id?: SortOrder
    destination_address?: SortOrder
    type?: SortOrder
    sending_time?: SortOrder
    brevo_id?: SortOrder
    email_status?: SortOrder
    user_projet_id?: SortOrder
    user_id?: SortOrder
    extra?: SortOrder
  }

  export type emailAvgOrderByAggregateInput = {
    user_projet_id?: SortOrder
  }

  export type emailMaxOrderByAggregateInput = {
    id?: SortOrder
    destination_address?: SortOrder
    type?: SortOrder
    sending_time?: SortOrder
    brevo_id?: SortOrder
    email_status?: SortOrder
    user_projet_id?: SortOrder
    user_id?: SortOrder
  }

  export type emailMinOrderByAggregateInput = {
    id?: SortOrder
    destination_address?: SortOrder
    type?: SortOrder
    sending_time?: SortOrder
    brevo_id?: SortOrder
    email_status?: SortOrder
    user_projet_id?: SortOrder
    user_id?: SortOrder
  }

  export type emailSumOrderByAggregateInput = {
    user_projet_id?: SortOrder
  }

  export type EnumemailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.emailType | EnumemailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumemailTypeWithAggregatesFilter<$PrismaModel> | $Enums.emailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumemailTypeFilter<$PrismaModel>
    _max?: NestedEnumemailTypeFilter<$PrismaModel>
  }

  export type EnumemailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.emailStatus | EnumemailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumemailStatusWithAggregatesFilter<$PrismaModel> | $Enums.emailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumemailStatusFilter<$PrismaModel>
    _max?: NestedEnumemailStatusFilter<$PrismaModel>
  }

  export type CollectiviteScalarRelationFilter = {
    is?: collectiviteWhereInput
    isNot?: collectiviteWhereInput
  }

  export type user_collectiviteOrderByRelevanceInput = {
    fields: user_collectiviteOrderByRelevanceFieldEnum | user_collectiviteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type user_collectiviteUserCollectiviteIdCompoundUniqueInput = {
    user_id: string
    collectivite_id: number
  }

  export type user_collectiviteCountOrderByAggregateInput = {
    user_id?: SortOrder
    collectivite_id?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
  }

  export type user_collectiviteAvgOrderByAggregateInput = {
    collectivite_id?: SortOrder
  }

  export type user_collectiviteMaxOrderByAggregateInput = {
    user_id?: SortOrder
    collectivite_id?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
  }

  export type user_collectiviteMinOrderByAggregateInput = {
    user_id?: SortOrder
    collectivite_id?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
  }

  export type user_collectiviteSumOrderByAggregateInput = {
    collectivite_id?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumStatutProjetNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutProjet | EnumStatutProjetFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutProjetNullableFilter<$PrismaModel> | $Enums.StatutProjet | null
  }

  export type projetOrderByRelevanceInput = {
    fields: projetOrderByRelevanceFieldEnum | projetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type projetCountOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    nom?: SortOrder
    type_espace?: SortOrder
    adresse?: SortOrder
    niveau_maturite?: SortOrder
    adresse_info?: SortOrder
    adresse_all_infos?: SortOrder
    date_echeance?: SortOrder
    fiches_solutions_id?: SortOrder
    fiches_diagnostic_id?: SortOrder
    collectiviteId?: SortOrder
    recommandations_viewed_by?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_public?: SortOrder
    budget?: SortOrder
    sourcing_rex?: SortOrder
    statut?: SortOrder
    statut_updated_at?: SortOrder
  }

  export type projetAvgOrderByAggregateInput = {
    id?: SortOrder
    fiches_solutions_id?: SortOrder
    fiches_diagnostic_id?: SortOrder
    collectiviteId?: SortOrder
    budget?: SortOrder
  }

  export type projetMaxOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    nom?: SortOrder
    type_espace?: SortOrder
    adresse?: SortOrder
    niveau_maturite?: SortOrder
    date_echeance?: SortOrder
    collectiviteId?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_public?: SortOrder
    budget?: SortOrder
    statut?: SortOrder
    statut_updated_at?: SortOrder
  }

  export type projetMinOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    nom?: SortOrder
    type_espace?: SortOrder
    adresse?: SortOrder
    niveau_maturite?: SortOrder
    date_echeance?: SortOrder
    collectiviteId?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_public?: SortOrder
    budget?: SortOrder
    statut?: SortOrder
    statut_updated_at?: SortOrder
  }

  export type projetSumOrderByAggregateInput = {
    id?: SortOrder
    fiches_solutions_id?: SortOrder
    fiches_diagnostic_id?: SortOrder
    collectiviteId?: SortOrder
    budget?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumStatutProjetNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutProjet | EnumStatutProjetFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutProjetNullableWithAggregatesFilter<$PrismaModel> | $Enums.StatutProjet | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatutProjetNullableFilter<$PrismaModel>
    _max?: NestedEnumStatutProjetNullableFilter<$PrismaModel>
  }

  export type EnumFicheTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FicheType | EnumFicheTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFicheTypeFilter<$PrismaModel> | $Enums.FicheType
  }

  export type projet_ficheOrderByRelevanceInput = {
    fields: projet_ficheOrderByRelevanceFieldEnum | projet_ficheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type projet_ficheProjet_idFiche_idTypeCompoundUniqueInput = {
    projet_id: number
    fiche_id: number
    type: $Enums.FicheType
  }

  export type projet_ficheCountOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type projet_ficheAvgOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
  }

  export type projet_ficheMaxOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type projet_ficheMinOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type projet_ficheSumOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiche_id?: SortOrder
  }

  export type EnumFicheTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FicheType | EnumFicheTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFicheTypeWithAggregatesFilter<$PrismaModel> | $Enums.FicheType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFicheTypeFilter<$PrismaModel>
    _max?: NestedEnumFicheTypeFilter<$PrismaModel>
  }

  export type User_projetScalarRelationFilter = {
    is?: user_projetWhereInput
    isNot?: user_projetWhereInput
  }

  export type projet_sourcing_contactOrderByRelevanceInput = {
    fields: projet_sourcing_contactOrderByRelevanceFieldEnum | projet_sourcing_contactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type projet_sourcing_contactProjet_idSourced_user_projet_idCompoundUniqueInput = {
    projet_id: number
    sourced_user_projet_id: number
  }

  export type projet_sourcing_contactCountOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type projet_sourcing_contactAvgOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
  }

  export type projet_sourcing_contactMaxOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type projet_sourcing_contactMinOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
  }

  export type projet_sourcing_contactSumOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    sourced_user_projet_id?: SortOrder
  }

  export type Estimation_fiche_solutionListRelationFilter = {
    every?: estimation_fiche_solutionWhereInput
    some?: estimation_fiche_solutionWhereInput
    none?: estimation_fiche_solutionWhereInput
  }

  export type estimation_fiche_solutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estimationOrderByRelevanceInput = {
    fields: estimationOrderByRelevanceFieldEnum | estimationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estimationCountOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projet_id?: SortOrder
    fiches_solutions_id?: SortOrder
    materiaux?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
  }

  export type estimationAvgOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiches_solutions_id?: SortOrder
  }

  export type estimationMaxOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projet_id?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
  }

  export type estimationMinOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projet_id?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
  }

  export type estimationSumOrderByAggregateInput = {
    id?: SortOrder
    projet_id?: SortOrder
    fiches_solutions_id?: SortOrder
  }

  export type EnumTypeLieuClimadiagFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeLieuClimadiag | EnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    in?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeLieuClimadiagFilter<$PrismaModel> | $Enums.TypeLieuClimadiag
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type climadiagOrderByRelevanceInput = {
    fields: climadiagOrderByRelevanceFieldEnum | climadiagOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type climadiagCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type_lieu?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    epci_parent_id?: SortOrder
    jours_tres_chauds_ref?: SortOrder
    jours_tres_chauds_prevision?: SortOrder
    nuits_chaudes_ref?: SortOrder
    nuits_chaudes_prevision?: SortOrder
    jours_vdc_ref?: SortOrder
    jours_vdc_prevision?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
    adresse_all_infos?: SortOrder
    searchable_field?: SortOrder
  }

  export type climadiagAvgOrderByAggregateInput = {
    id?: SortOrder
    epci_parent_id?: SortOrder
    jours_tres_chauds_ref?: SortOrder
    nuits_chaudes_ref?: SortOrder
    jours_vdc_ref?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type climadiagMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type_lieu?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    epci_parent_id?: SortOrder
    jours_tres_chauds_ref?: SortOrder
    nuits_chaudes_ref?: SortOrder
    jours_vdc_ref?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
    searchable_field?: SortOrder
  }

  export type climadiagMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type_lieu?: SortOrder
    code_insee?: SortOrder
    code_postal?: SortOrder
    epci_parent_id?: SortOrder
    jours_tres_chauds_ref?: SortOrder
    nuits_chaudes_ref?: SortOrder
    jours_vdc_ref?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
    searchable_field?: SortOrder
  }

  export type climadiagSumOrderByAggregateInput = {
    id?: SortOrder
    epci_parent_id?: SortOrder
    jours_tres_chauds_ref?: SortOrder
    nuits_chaudes_ref?: SortOrder
    jours_vdc_ref?: SortOrder
    population?: SortOrder
    superficie?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type EnumTypeLieuClimadiagWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeLieuClimadiag | EnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    in?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeLieuClimadiagWithAggregatesFilter<$PrismaModel> | $Enums.TypeLieuClimadiag
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeLieuClimadiagFilter<$PrismaModel>
    _max?: NestedEnumTypeLieuClimadiagFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type aideOrderByRelevanceInput = {
    fields: aideOrderByRelevanceFieldEnum | aideOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type aideCountOrderByAggregateInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
    submission_deadline?: SortOrder
    type?: SortOrder
    name?: SortOrder
    financers?: SortOrder
  }

  export type aideAvgOrderByAggregateInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
  }

  export type aideMaxOrderByAggregateInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
    submission_deadline?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type aideMinOrderByAggregateInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
    submission_deadline?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type aideSumOrderByAggregateInput = {
    id?: SortOrder
    aideTerritoireId?: SortOrder
  }

  export type EstimationScalarRelationFilter = {
    is?: estimationWhereInput
    isNot?: estimationWhereInput
  }

  export type AideScalarRelationFilter = {
    is?: aideWhereInput
    isNot?: aideWhereInput
  }

  export type estimations_aidesOrderByRelevanceInput = {
    fields: estimations_aidesOrderByRelevanceFieldEnum | estimations_aidesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estimations_aidesEstimationIdAideIdCompoundUniqueInput = {
    estimationId: number
    aideId: number
  }

  export type estimations_aidesCountOrderByAggregateInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type estimations_aidesAvgOrderByAggregateInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
  }

  export type estimations_aidesMaxOrderByAggregateInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type estimations_aidesMinOrderByAggregateInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type estimations_aidesSumOrderByAggregateInput = {
    id?: SortOrder
    estimationId?: SortOrder
    aideId?: SortOrder
  }

  export type Estimation_fiche_solutionScalarRelationFilter = {
    is?: estimation_fiche_solutionWhereInput
    isNot?: estimation_fiche_solutionWhereInput
  }

  export type estimation_materiauxOrderByRelevanceInput = {
    fields: estimation_materiauxOrderByRelevanceFieldEnum | estimation_materiauxOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estimation_materiauxCountOrderByAggregateInput = {
    id?: SortOrder
    estimation_fiche_solution_id?: SortOrder
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_materiauxAvgOrderByAggregateInput = {
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_materiauxMaxOrderByAggregateInput = {
    id?: SortOrder
    estimation_fiche_solution_id?: SortOrder
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_materiauxMinOrderByAggregateInput = {
    id?: SortOrder
    estimation_fiche_solution_id?: SortOrder
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_materiauxSumOrderByAggregateInput = {
    materiau_id?: SortOrder
    quantite?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type Estimation_materiauxListRelationFilter = {
    every?: estimation_materiauxWhereInput
    some?: estimation_materiauxWhereInput
    none?: estimation_materiauxWhereInput
  }

  export type estimation_materiauxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estimation_fiche_solutionOrderByRelevanceInput = {
    fields: estimation_fiche_solutionOrderByRelevanceFieldEnum | estimation_fiche_solutionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type estimation_fiche_solutionEstimation_idFiche_solution_idCompoundUniqueInput = {
    estimation_id: number
    fiche_solution_id: number
  }

  export type estimation_fiche_solutionCountOrderByAggregateInput = {
    id?: SortOrder
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_fiche_solutionAvgOrderByAggregateInput = {
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_fiche_solutionMaxOrderByAggregateInput = {
    id?: SortOrder
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_fiche_solutionMinOrderByAggregateInput = {
    id?: SortOrder
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type estimation_fiche_solutionSumOrderByAggregateInput = {
    estimation_id?: SortOrder
    fiche_solution_id?: SortOrder
    quantite?: SortOrder
    cout_min_investissement?: SortOrder
    cout_max_investissement?: SortOrder
    cout_min_entretien?: SortOrder
    cout_max_entretien?: SortOrder
    cout_investissement_override?: SortOrder
    cout_entretien_override?: SortOrder
  }

  export type conversationOrderByRelevanceInput = {
    fields: conversationOrderByRelevanceFieldEnum | conversationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type conversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ragtimeId?: SortOrder
    created_at?: SortOrder
  }

  export type conversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ragtimeId?: SortOrder
    created_at?: SortOrder
  }

  export type conversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ragtimeId?: SortOrder
    created_at?: SortOrder
  }

  export type diagnostic_simulationOrderByRelevanceInput = {
    fields: diagnostic_simulationOrderByRelevanceFieldEnum | diagnostic_simulationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type diagnostic_simulationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    projet_id?: SortOrder
    initial_values?: SortOrder
    validated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type diagnostic_simulationAvgOrderByAggregateInput = {
    projet_id?: SortOrder
  }

  export type diagnostic_simulationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    projet_id?: SortOrder
    validated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type diagnostic_simulationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    projet_id?: SortOrder
    validated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type diagnostic_simulationSumOrderByAggregateInput = {
    projet_id?: SortOrder
  }

  export type EnumReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeFilter<$PrismaModel> | $Enums.ReferenceType
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type AnalyticsOrderByRelevanceInput = {
    fields: AnalyticsOrderByRelevanceFieldEnum | AnalyticsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    event_type?: SortOrder
    context?: SortOrder
    user_id?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    event_type?: SortOrder
    user_id?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    event_type?: SortOrder
    user_id?: SortOrder
  }

  export type EnumReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumReferenceTypeFilter<$PrismaModel>
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type cron_jobsOrderByRelevanceInput = {
    fields: cron_jobsOrderByRelevanceFieldEnum | cron_jobsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cron_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    execution_start_time?: SortOrder
    execution_end_time?: SortOrder
    job_type?: SortOrder
  }

  export type cron_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    execution_start_time?: SortOrder
    execution_end_time?: SortOrder
    job_type?: SortOrder
  }

  export type cron_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    execution_start_time?: SortOrder
    execution_end_time?: SortOrder
    job_type?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreatediscardedInformationInput = {
    set: string[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type collectiviteCreateNestedManyWithoutCreatorInput = {
    create?: XOR<collectiviteCreateWithoutCreatorInput, collectiviteUncheckedCreateWithoutCreatorInput> | collectiviteCreateWithoutCreatorInput[] | collectiviteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: collectiviteCreateOrConnectWithoutCreatorInput | collectiviteCreateOrConnectWithoutCreatorInput[]
    createMany?: collectiviteCreateManyCreatorInputEnvelope
    connect?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
  }

  export type projetCreateNestedManyWithoutCreatorInput = {
    create?: XOR<projetCreateWithoutCreatorInput, projetUncheckedCreateWithoutCreatorInput> | projetCreateWithoutCreatorInput[] | projetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCreatorInput | projetCreateOrConnectWithoutCreatorInput[]
    createMany?: projetCreateManyCreatorInputEnvelope
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
  }

  export type estimationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<estimationCreateWithoutCreatorInput, estimationUncheckedCreateWithoutCreatorInput> | estimationCreateWithoutCreatorInput[] | estimationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutCreatorInput | estimationCreateOrConnectWithoutCreatorInput[]
    createMany?: estimationCreateManyCreatorInputEnvelope
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
  }

  export type estimationCreateNestedManyWithoutDeleterInput = {
    create?: XOR<estimationCreateWithoutDeleterInput, estimationUncheckedCreateWithoutDeleterInput> | estimationCreateWithoutDeleterInput[] | estimationUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutDeleterInput | estimationCreateOrConnectWithoutDeleterInput[]
    createMany?: estimationCreateManyDeleterInputEnvelope
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
  }

  export type projetCreateNestedManyWithoutDeleterInput = {
    create?: XOR<projetCreateWithoutDeleterInput, projetUncheckedCreateWithoutDeleterInput> | projetCreateWithoutDeleterInput[] | projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: projetCreateOrConnectWithoutDeleterInput | projetCreateOrConnectWithoutDeleterInput[]
    createMany?: projetCreateManyDeleterInputEnvelope
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
  }

  export type user_collectiviteCreateNestedManyWithoutUserInput = {
    create?: XOR<user_collectiviteCreateWithoutUserInput, user_collectiviteUncheckedCreateWithoutUserInput> | user_collectiviteCreateWithoutUserInput[] | user_collectiviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutUserInput | user_collectiviteCreateOrConnectWithoutUserInput[]
    createMany?: user_collectiviteCreateManyUserInputEnvelope
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
  }

  export type user_projetCreateNestedManyWithoutUserInput = {
    create?: XOR<user_projetCreateWithoutUserInput, user_projetUncheckedCreateWithoutUserInput> | user_projetCreateWithoutUserInput[] | user_projetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutUserInput | user_projetCreateOrConnectWithoutUserInput[]
    createMany?: user_projetCreateManyUserInputEnvelope
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
  }

  export type user_projetCreateNestedManyWithoutDeleterInput = {
    create?: XOR<user_projetCreateWithoutDeleterInput, user_projetUncheckedCreateWithoutDeleterInput> | user_projetCreateWithoutDeleterInput[] | user_projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutDeleterInput | user_projetCreateOrConnectWithoutDeleterInput[]
    createMany?: user_projetCreateManyDeleterInputEnvelope
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
  }

  export type conversationCreateNestedManyWithoutUserInput = {
    create?: XOR<conversationCreateWithoutUserInput, conversationUncheckedCreateWithoutUserInput> | conversationCreateWithoutUserInput[] | conversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutUserInput | conversationCreateOrConnectWithoutUserInput[]
    createMany?: conversationCreateManyUserInputEnvelope
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
  }

  export type AnalyticsCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<AnalyticsCreateWithoutCreated_byInput, AnalyticsUncheckedCreateWithoutCreated_byInput> | AnalyticsCreateWithoutCreated_byInput[] | AnalyticsUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreated_byInput | AnalyticsCreateOrConnectWithoutCreated_byInput[]
    createMany?: AnalyticsCreateManyCreated_byInputEnvelope
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
  }

  export type projet_sourcing_contactCreateNestedManyWithoutCreatorInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutCreatorInput, projet_sourcing_contactUncheckedCreateWithoutCreatorInput> | projet_sourcing_contactCreateWithoutCreatorInput[] | projet_sourcing_contactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutCreatorInput | projet_sourcing_contactCreateOrConnectWithoutCreatorInput[]
    createMany?: projet_sourcing_contactCreateManyCreatorInputEnvelope
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
  }

  export type emailCreateNestedManyWithoutUserInput = {
    create?: XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput> | emailCreateWithoutUserInput[] | emailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUserInput | emailCreateOrConnectWithoutUserInput[]
    createMany?: emailCreateManyUserInputEnvelope
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
  }

  export type estimations_aidesCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<estimations_aidesCreateWithoutCreated_byInput, estimations_aidesUncheckedCreateWithoutCreated_byInput> | estimations_aidesCreateWithoutCreated_byInput[] | estimations_aidesUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutCreated_byInput | estimations_aidesCreateOrConnectWithoutCreated_byInput[]
    createMany?: estimations_aidesCreateManyCreated_byInputEnvelope
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
  }

  export type projet_ficheCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<projet_ficheCreateWithoutCreated_byInput, projet_ficheUncheckedCreateWithoutCreated_byInput> | projet_ficheCreateWithoutCreated_byInput[] | projet_ficheUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutCreated_byInput | projet_ficheCreateOrConnectWithoutCreated_byInput[]
    createMany?: projet_ficheCreateManyCreated_byInputEnvelope
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
  }

  export type diagnostic_simulationCreateNestedManyWithoutUserInput = {
    create?: XOR<diagnostic_simulationCreateWithoutUserInput, diagnostic_simulationUncheckedCreateWithoutUserInput> | diagnostic_simulationCreateWithoutUserInput[] | diagnostic_simulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutUserInput | diagnostic_simulationCreateOrConnectWithoutUserInput[]
    createMany?: diagnostic_simulationCreateManyUserInputEnvelope
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type collectiviteUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<collectiviteCreateWithoutCreatorInput, collectiviteUncheckedCreateWithoutCreatorInput> | collectiviteCreateWithoutCreatorInput[] | collectiviteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: collectiviteCreateOrConnectWithoutCreatorInput | collectiviteCreateOrConnectWithoutCreatorInput[]
    createMany?: collectiviteCreateManyCreatorInputEnvelope
    connect?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
  }

  export type projetUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<projetCreateWithoutCreatorInput, projetUncheckedCreateWithoutCreatorInput> | projetCreateWithoutCreatorInput[] | projetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCreatorInput | projetCreateOrConnectWithoutCreatorInput[]
    createMany?: projetCreateManyCreatorInputEnvelope
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
  }

  export type estimationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<estimationCreateWithoutCreatorInput, estimationUncheckedCreateWithoutCreatorInput> | estimationCreateWithoutCreatorInput[] | estimationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutCreatorInput | estimationCreateOrConnectWithoutCreatorInput[]
    createMany?: estimationCreateManyCreatorInputEnvelope
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
  }

  export type estimationUncheckedCreateNestedManyWithoutDeleterInput = {
    create?: XOR<estimationCreateWithoutDeleterInput, estimationUncheckedCreateWithoutDeleterInput> | estimationCreateWithoutDeleterInput[] | estimationUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutDeleterInput | estimationCreateOrConnectWithoutDeleterInput[]
    createMany?: estimationCreateManyDeleterInputEnvelope
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
  }

  export type projetUncheckedCreateNestedManyWithoutDeleterInput = {
    create?: XOR<projetCreateWithoutDeleterInput, projetUncheckedCreateWithoutDeleterInput> | projetCreateWithoutDeleterInput[] | projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: projetCreateOrConnectWithoutDeleterInput | projetCreateOrConnectWithoutDeleterInput[]
    createMany?: projetCreateManyDeleterInputEnvelope
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
  }

  export type user_collectiviteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_collectiviteCreateWithoutUserInput, user_collectiviteUncheckedCreateWithoutUserInput> | user_collectiviteCreateWithoutUserInput[] | user_collectiviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutUserInput | user_collectiviteCreateOrConnectWithoutUserInput[]
    createMany?: user_collectiviteCreateManyUserInputEnvelope
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
  }

  export type user_projetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_projetCreateWithoutUserInput, user_projetUncheckedCreateWithoutUserInput> | user_projetCreateWithoutUserInput[] | user_projetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutUserInput | user_projetCreateOrConnectWithoutUserInput[]
    createMany?: user_projetCreateManyUserInputEnvelope
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
  }

  export type user_projetUncheckedCreateNestedManyWithoutDeleterInput = {
    create?: XOR<user_projetCreateWithoutDeleterInput, user_projetUncheckedCreateWithoutDeleterInput> | user_projetCreateWithoutDeleterInput[] | user_projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutDeleterInput | user_projetCreateOrConnectWithoutDeleterInput[]
    createMany?: user_projetCreateManyDeleterInputEnvelope
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
  }

  export type conversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<conversationCreateWithoutUserInput, conversationUncheckedCreateWithoutUserInput> | conversationCreateWithoutUserInput[] | conversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutUserInput | conversationCreateOrConnectWithoutUserInput[]
    createMany?: conversationCreateManyUserInputEnvelope
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
  }

  export type AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<AnalyticsCreateWithoutCreated_byInput, AnalyticsUncheckedCreateWithoutCreated_byInput> | AnalyticsCreateWithoutCreated_byInput[] | AnalyticsUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreated_byInput | AnalyticsCreateOrConnectWithoutCreated_byInput[]
    createMany?: AnalyticsCreateManyCreated_byInputEnvelope
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
  }

  export type projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutCreatorInput, projet_sourcing_contactUncheckedCreateWithoutCreatorInput> | projet_sourcing_contactCreateWithoutCreatorInput[] | projet_sourcing_contactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutCreatorInput | projet_sourcing_contactCreateOrConnectWithoutCreatorInput[]
    createMany?: projet_sourcing_contactCreateManyCreatorInputEnvelope
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
  }

  export type emailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput> | emailCreateWithoutUserInput[] | emailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUserInput | emailCreateOrConnectWithoutUserInput[]
    createMany?: emailCreateManyUserInputEnvelope
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
  }

  export type estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<estimations_aidesCreateWithoutCreated_byInput, estimations_aidesUncheckedCreateWithoutCreated_byInput> | estimations_aidesCreateWithoutCreated_byInput[] | estimations_aidesUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutCreated_byInput | estimations_aidesCreateOrConnectWithoutCreated_byInput[]
    createMany?: estimations_aidesCreateManyCreated_byInputEnvelope
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
  }

  export type projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput = {
    create?: XOR<projet_ficheCreateWithoutCreated_byInput, projet_ficheUncheckedCreateWithoutCreated_byInput> | projet_ficheCreateWithoutCreated_byInput[] | projet_ficheUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutCreated_byInput | projet_ficheCreateOrConnectWithoutCreated_byInput[]
    createMany?: projet_ficheCreateManyCreated_byInputEnvelope
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
  }

  export type diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<diagnostic_simulationCreateWithoutUserInput, diagnostic_simulationUncheckedCreateWithoutUserInput> | diagnostic_simulationCreateWithoutUserInput[] | diagnostic_simulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutUserInput | diagnostic_simulationCreateOrConnectWithoutUserInput[]
    createMany?: diagnostic_simulationCreateManyUserInputEnvelope
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdatediscardedInformationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumStatutUserFieldUpdateOperationsInput = {
    set?: $Enums.StatutUser | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type collectiviteUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<collectiviteCreateWithoutCreatorInput, collectiviteUncheckedCreateWithoutCreatorInput> | collectiviteCreateWithoutCreatorInput[] | collectiviteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: collectiviteCreateOrConnectWithoutCreatorInput | collectiviteCreateOrConnectWithoutCreatorInput[]
    upsert?: collectiviteUpsertWithWhereUniqueWithoutCreatorInput | collectiviteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: collectiviteCreateManyCreatorInputEnvelope
    set?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    disconnect?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    delete?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    connect?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    update?: collectiviteUpdateWithWhereUniqueWithoutCreatorInput | collectiviteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: collectiviteUpdateManyWithWhereWithoutCreatorInput | collectiviteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: collectiviteScalarWhereInput | collectiviteScalarWhereInput[]
  }

  export type projetUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<projetCreateWithoutCreatorInput, projetUncheckedCreateWithoutCreatorInput> | projetCreateWithoutCreatorInput[] | projetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCreatorInput | projetCreateOrConnectWithoutCreatorInput[]
    upsert?: projetUpsertWithWhereUniqueWithoutCreatorInput | projetUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: projetCreateManyCreatorInputEnvelope
    set?: projetWhereUniqueInput | projetWhereUniqueInput[]
    disconnect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    delete?: projetWhereUniqueInput | projetWhereUniqueInput[]
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    update?: projetUpdateWithWhereUniqueWithoutCreatorInput | projetUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: projetUpdateManyWithWhereWithoutCreatorInput | projetUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: projetScalarWhereInput | projetScalarWhereInput[]
  }

  export type estimationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<estimationCreateWithoutCreatorInput, estimationUncheckedCreateWithoutCreatorInput> | estimationCreateWithoutCreatorInput[] | estimationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutCreatorInput | estimationCreateOrConnectWithoutCreatorInput[]
    upsert?: estimationUpsertWithWhereUniqueWithoutCreatorInput | estimationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: estimationCreateManyCreatorInputEnvelope
    set?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    disconnect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    delete?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    update?: estimationUpdateWithWhereUniqueWithoutCreatorInput | estimationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: estimationUpdateManyWithWhereWithoutCreatorInput | estimationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: estimationScalarWhereInput | estimationScalarWhereInput[]
  }

  export type estimationUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<estimationCreateWithoutDeleterInput, estimationUncheckedCreateWithoutDeleterInput> | estimationCreateWithoutDeleterInput[] | estimationUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutDeleterInput | estimationCreateOrConnectWithoutDeleterInput[]
    upsert?: estimationUpsertWithWhereUniqueWithoutDeleterInput | estimationUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: estimationCreateManyDeleterInputEnvelope
    set?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    disconnect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    delete?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    update?: estimationUpdateWithWhereUniqueWithoutDeleterInput | estimationUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: estimationUpdateManyWithWhereWithoutDeleterInput | estimationUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: estimationScalarWhereInput | estimationScalarWhereInput[]
  }

  export type projetUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<projetCreateWithoutDeleterInput, projetUncheckedCreateWithoutDeleterInput> | projetCreateWithoutDeleterInput[] | projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: projetCreateOrConnectWithoutDeleterInput | projetCreateOrConnectWithoutDeleterInput[]
    upsert?: projetUpsertWithWhereUniqueWithoutDeleterInput | projetUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: projetCreateManyDeleterInputEnvelope
    set?: projetWhereUniqueInput | projetWhereUniqueInput[]
    disconnect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    delete?: projetWhereUniqueInput | projetWhereUniqueInput[]
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    update?: projetUpdateWithWhereUniqueWithoutDeleterInput | projetUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: projetUpdateManyWithWhereWithoutDeleterInput | projetUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: projetScalarWhereInput | projetScalarWhereInput[]
  }

  export type user_collectiviteUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_collectiviteCreateWithoutUserInput, user_collectiviteUncheckedCreateWithoutUserInput> | user_collectiviteCreateWithoutUserInput[] | user_collectiviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutUserInput | user_collectiviteCreateOrConnectWithoutUserInput[]
    upsert?: user_collectiviteUpsertWithWhereUniqueWithoutUserInput | user_collectiviteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_collectiviteCreateManyUserInputEnvelope
    set?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    disconnect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    delete?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    update?: user_collectiviteUpdateWithWhereUniqueWithoutUserInput | user_collectiviteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_collectiviteUpdateManyWithWhereWithoutUserInput | user_collectiviteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_collectiviteScalarWhereInput | user_collectiviteScalarWhereInput[]
  }

  export type user_projetUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_projetCreateWithoutUserInput, user_projetUncheckedCreateWithoutUserInput> | user_projetCreateWithoutUserInput[] | user_projetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutUserInput | user_projetCreateOrConnectWithoutUserInput[]
    upsert?: user_projetUpsertWithWhereUniqueWithoutUserInput | user_projetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_projetCreateManyUserInputEnvelope
    set?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    disconnect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    delete?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    update?: user_projetUpdateWithWhereUniqueWithoutUserInput | user_projetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_projetUpdateManyWithWhereWithoutUserInput | user_projetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
  }

  export type user_projetUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<user_projetCreateWithoutDeleterInput, user_projetUncheckedCreateWithoutDeleterInput> | user_projetCreateWithoutDeleterInput[] | user_projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutDeleterInput | user_projetCreateOrConnectWithoutDeleterInput[]
    upsert?: user_projetUpsertWithWhereUniqueWithoutDeleterInput | user_projetUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: user_projetCreateManyDeleterInputEnvelope
    set?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    disconnect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    delete?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    update?: user_projetUpdateWithWhereUniqueWithoutDeleterInput | user_projetUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: user_projetUpdateManyWithWhereWithoutDeleterInput | user_projetUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
  }

  export type conversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<conversationCreateWithoutUserInput, conversationUncheckedCreateWithoutUserInput> | conversationCreateWithoutUserInput[] | conversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutUserInput | conversationCreateOrConnectWithoutUserInput[]
    upsert?: conversationUpsertWithWhereUniqueWithoutUserInput | conversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: conversationCreateManyUserInputEnvelope
    set?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    disconnect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    delete?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    update?: conversationUpdateWithWhereUniqueWithoutUserInput | conversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: conversationUpdateManyWithWhereWithoutUserInput | conversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: conversationScalarWhereInput | conversationScalarWhereInput[]
  }

  export type AnalyticsUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<AnalyticsCreateWithoutCreated_byInput, AnalyticsUncheckedCreateWithoutCreated_byInput> | AnalyticsCreateWithoutCreated_byInput[] | AnalyticsUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreated_byInput | AnalyticsCreateOrConnectWithoutCreated_byInput[]
    upsert?: AnalyticsUpsertWithWhereUniqueWithoutCreated_byInput | AnalyticsUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: AnalyticsCreateManyCreated_byInputEnvelope
    set?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    disconnect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    delete?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    update?: AnalyticsUpdateWithWhereUniqueWithoutCreated_byInput | AnalyticsUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: AnalyticsUpdateManyWithWhereWithoutCreated_byInput | AnalyticsUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
  }

  export type projet_sourcing_contactUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutCreatorInput, projet_sourcing_contactUncheckedCreateWithoutCreatorInput> | projet_sourcing_contactCreateWithoutCreatorInput[] | projet_sourcing_contactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutCreatorInput | projet_sourcing_contactCreateOrConnectWithoutCreatorInput[]
    upsert?: projet_sourcing_contactUpsertWithWhereUniqueWithoutCreatorInput | projet_sourcing_contactUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: projet_sourcing_contactCreateManyCreatorInputEnvelope
    set?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    disconnect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    delete?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    update?: projet_sourcing_contactUpdateWithWhereUniqueWithoutCreatorInput | projet_sourcing_contactUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: projet_sourcing_contactUpdateManyWithWhereWithoutCreatorInput | projet_sourcing_contactUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
  }

  export type emailUpdateManyWithoutUserNestedInput = {
    create?: XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput> | emailCreateWithoutUserInput[] | emailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUserInput | emailCreateOrConnectWithoutUserInput[]
    upsert?: emailUpsertWithWhereUniqueWithoutUserInput | emailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: emailCreateManyUserInputEnvelope
    set?: emailWhereUniqueInput | emailWhereUniqueInput[]
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[]
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    update?: emailUpdateWithWhereUniqueWithoutUserInput | emailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: emailUpdateManyWithWhereWithoutUserInput | emailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[]
  }

  export type estimations_aidesUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<estimations_aidesCreateWithoutCreated_byInput, estimations_aidesUncheckedCreateWithoutCreated_byInput> | estimations_aidesCreateWithoutCreated_byInput[] | estimations_aidesUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutCreated_byInput | estimations_aidesCreateOrConnectWithoutCreated_byInput[]
    upsert?: estimations_aidesUpsertWithWhereUniqueWithoutCreated_byInput | estimations_aidesUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: estimations_aidesCreateManyCreated_byInputEnvelope
    set?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    disconnect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    delete?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    update?: estimations_aidesUpdateWithWhereUniqueWithoutCreated_byInput | estimations_aidesUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: estimations_aidesUpdateManyWithWhereWithoutCreated_byInput | estimations_aidesUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
  }

  export type projet_ficheUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<projet_ficheCreateWithoutCreated_byInput, projet_ficheUncheckedCreateWithoutCreated_byInput> | projet_ficheCreateWithoutCreated_byInput[] | projet_ficheUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutCreated_byInput | projet_ficheCreateOrConnectWithoutCreated_byInput[]
    upsert?: projet_ficheUpsertWithWhereUniqueWithoutCreated_byInput | projet_ficheUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: projet_ficheCreateManyCreated_byInputEnvelope
    set?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    disconnect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    delete?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    update?: projet_ficheUpdateWithWhereUniqueWithoutCreated_byInput | projet_ficheUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: projet_ficheUpdateManyWithWhereWithoutCreated_byInput | projet_ficheUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: projet_ficheScalarWhereInput | projet_ficheScalarWhereInput[]
  }

  export type diagnostic_simulationUpdateManyWithoutUserNestedInput = {
    create?: XOR<diagnostic_simulationCreateWithoutUserInput, diagnostic_simulationUncheckedCreateWithoutUserInput> | diagnostic_simulationCreateWithoutUserInput[] | diagnostic_simulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutUserInput | diagnostic_simulationCreateOrConnectWithoutUserInput[]
    upsert?: diagnostic_simulationUpsertWithWhereUniqueWithoutUserInput | diagnostic_simulationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: diagnostic_simulationCreateManyUserInputEnvelope
    set?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    disconnect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    delete?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    update?: diagnostic_simulationUpdateWithWhereUniqueWithoutUserInput | diagnostic_simulationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: diagnostic_simulationUpdateManyWithWhereWithoutUserInput | diagnostic_simulationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: diagnostic_simulationScalarWhereInput | diagnostic_simulationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type collectiviteUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<collectiviteCreateWithoutCreatorInput, collectiviteUncheckedCreateWithoutCreatorInput> | collectiviteCreateWithoutCreatorInput[] | collectiviteUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: collectiviteCreateOrConnectWithoutCreatorInput | collectiviteCreateOrConnectWithoutCreatorInput[]
    upsert?: collectiviteUpsertWithWhereUniqueWithoutCreatorInput | collectiviteUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: collectiviteCreateManyCreatorInputEnvelope
    set?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    disconnect?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    delete?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    connect?: collectiviteWhereUniqueInput | collectiviteWhereUniqueInput[]
    update?: collectiviteUpdateWithWhereUniqueWithoutCreatorInput | collectiviteUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: collectiviteUpdateManyWithWhereWithoutCreatorInput | collectiviteUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: collectiviteScalarWhereInput | collectiviteScalarWhereInput[]
  }

  export type projetUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<projetCreateWithoutCreatorInput, projetUncheckedCreateWithoutCreatorInput> | projetCreateWithoutCreatorInput[] | projetUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCreatorInput | projetCreateOrConnectWithoutCreatorInput[]
    upsert?: projetUpsertWithWhereUniqueWithoutCreatorInput | projetUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: projetCreateManyCreatorInputEnvelope
    set?: projetWhereUniqueInput | projetWhereUniqueInput[]
    disconnect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    delete?: projetWhereUniqueInput | projetWhereUniqueInput[]
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    update?: projetUpdateWithWhereUniqueWithoutCreatorInput | projetUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: projetUpdateManyWithWhereWithoutCreatorInput | projetUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: projetScalarWhereInput | projetScalarWhereInput[]
  }

  export type estimationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<estimationCreateWithoutCreatorInput, estimationUncheckedCreateWithoutCreatorInput> | estimationCreateWithoutCreatorInput[] | estimationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutCreatorInput | estimationCreateOrConnectWithoutCreatorInput[]
    upsert?: estimationUpsertWithWhereUniqueWithoutCreatorInput | estimationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: estimationCreateManyCreatorInputEnvelope
    set?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    disconnect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    delete?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    update?: estimationUpdateWithWhereUniqueWithoutCreatorInput | estimationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: estimationUpdateManyWithWhereWithoutCreatorInput | estimationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: estimationScalarWhereInput | estimationScalarWhereInput[]
  }

  export type estimationUncheckedUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<estimationCreateWithoutDeleterInput, estimationUncheckedCreateWithoutDeleterInput> | estimationCreateWithoutDeleterInput[] | estimationUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutDeleterInput | estimationCreateOrConnectWithoutDeleterInput[]
    upsert?: estimationUpsertWithWhereUniqueWithoutDeleterInput | estimationUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: estimationCreateManyDeleterInputEnvelope
    set?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    disconnect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    delete?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    update?: estimationUpdateWithWhereUniqueWithoutDeleterInput | estimationUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: estimationUpdateManyWithWhereWithoutDeleterInput | estimationUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: estimationScalarWhereInput | estimationScalarWhereInput[]
  }

  export type projetUncheckedUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<projetCreateWithoutDeleterInput, projetUncheckedCreateWithoutDeleterInput> | projetCreateWithoutDeleterInput[] | projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: projetCreateOrConnectWithoutDeleterInput | projetCreateOrConnectWithoutDeleterInput[]
    upsert?: projetUpsertWithWhereUniqueWithoutDeleterInput | projetUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: projetCreateManyDeleterInputEnvelope
    set?: projetWhereUniqueInput | projetWhereUniqueInput[]
    disconnect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    delete?: projetWhereUniqueInput | projetWhereUniqueInput[]
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    update?: projetUpdateWithWhereUniqueWithoutDeleterInput | projetUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: projetUpdateManyWithWhereWithoutDeleterInput | projetUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: projetScalarWhereInput | projetScalarWhereInput[]
  }

  export type user_collectiviteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_collectiviteCreateWithoutUserInput, user_collectiviteUncheckedCreateWithoutUserInput> | user_collectiviteCreateWithoutUserInput[] | user_collectiviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutUserInput | user_collectiviteCreateOrConnectWithoutUserInput[]
    upsert?: user_collectiviteUpsertWithWhereUniqueWithoutUserInput | user_collectiviteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_collectiviteCreateManyUserInputEnvelope
    set?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    disconnect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    delete?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    update?: user_collectiviteUpdateWithWhereUniqueWithoutUserInput | user_collectiviteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_collectiviteUpdateManyWithWhereWithoutUserInput | user_collectiviteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_collectiviteScalarWhereInput | user_collectiviteScalarWhereInput[]
  }

  export type user_projetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_projetCreateWithoutUserInput, user_projetUncheckedCreateWithoutUserInput> | user_projetCreateWithoutUserInput[] | user_projetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutUserInput | user_projetCreateOrConnectWithoutUserInput[]
    upsert?: user_projetUpsertWithWhereUniqueWithoutUserInput | user_projetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_projetCreateManyUserInputEnvelope
    set?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    disconnect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    delete?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    update?: user_projetUpdateWithWhereUniqueWithoutUserInput | user_projetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_projetUpdateManyWithWhereWithoutUserInput | user_projetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
  }

  export type user_projetUncheckedUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<user_projetCreateWithoutDeleterInput, user_projetUncheckedCreateWithoutDeleterInput> | user_projetCreateWithoutDeleterInput[] | user_projetUncheckedCreateWithoutDeleterInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutDeleterInput | user_projetCreateOrConnectWithoutDeleterInput[]
    upsert?: user_projetUpsertWithWhereUniqueWithoutDeleterInput | user_projetUpsertWithWhereUniqueWithoutDeleterInput[]
    createMany?: user_projetCreateManyDeleterInputEnvelope
    set?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    disconnect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    delete?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    update?: user_projetUpdateWithWhereUniqueWithoutDeleterInput | user_projetUpdateWithWhereUniqueWithoutDeleterInput[]
    updateMany?: user_projetUpdateManyWithWhereWithoutDeleterInput | user_projetUpdateManyWithWhereWithoutDeleterInput[]
    deleteMany?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
  }

  export type conversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<conversationCreateWithoutUserInput, conversationUncheckedCreateWithoutUserInput> | conversationCreateWithoutUserInput[] | conversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: conversationCreateOrConnectWithoutUserInput | conversationCreateOrConnectWithoutUserInput[]
    upsert?: conversationUpsertWithWhereUniqueWithoutUserInput | conversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: conversationCreateManyUserInputEnvelope
    set?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    disconnect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    delete?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    connect?: conversationWhereUniqueInput | conversationWhereUniqueInput[]
    update?: conversationUpdateWithWhereUniqueWithoutUserInput | conversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: conversationUpdateManyWithWhereWithoutUserInput | conversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: conversationScalarWhereInput | conversationScalarWhereInput[]
  }

  export type AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<AnalyticsCreateWithoutCreated_byInput, AnalyticsUncheckedCreateWithoutCreated_byInput> | AnalyticsCreateWithoutCreated_byInput[] | AnalyticsUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: AnalyticsCreateOrConnectWithoutCreated_byInput | AnalyticsCreateOrConnectWithoutCreated_byInput[]
    upsert?: AnalyticsUpsertWithWhereUniqueWithoutCreated_byInput | AnalyticsUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: AnalyticsCreateManyCreated_byInputEnvelope
    set?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    disconnect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    delete?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    connect?: AnalyticsWhereUniqueInput | AnalyticsWhereUniqueInput[]
    update?: AnalyticsUpdateWithWhereUniqueWithoutCreated_byInput | AnalyticsUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: AnalyticsUpdateManyWithWhereWithoutCreated_byInput | AnalyticsUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
  }

  export type projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutCreatorInput, projet_sourcing_contactUncheckedCreateWithoutCreatorInput> | projet_sourcing_contactCreateWithoutCreatorInput[] | projet_sourcing_contactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutCreatorInput | projet_sourcing_contactCreateOrConnectWithoutCreatorInput[]
    upsert?: projet_sourcing_contactUpsertWithWhereUniqueWithoutCreatorInput | projet_sourcing_contactUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: projet_sourcing_contactCreateManyCreatorInputEnvelope
    set?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    disconnect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    delete?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    update?: projet_sourcing_contactUpdateWithWhereUniqueWithoutCreatorInput | projet_sourcing_contactUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: projet_sourcing_contactUpdateManyWithWhereWithoutCreatorInput | projet_sourcing_contactUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
  }

  export type emailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput> | emailCreateWithoutUserInput[] | emailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUserInput | emailCreateOrConnectWithoutUserInput[]
    upsert?: emailUpsertWithWhereUniqueWithoutUserInput | emailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: emailCreateManyUserInputEnvelope
    set?: emailWhereUniqueInput | emailWhereUniqueInput[]
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[]
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    update?: emailUpdateWithWhereUniqueWithoutUserInput | emailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: emailUpdateManyWithWhereWithoutUserInput | emailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[]
  }

  export type estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<estimations_aidesCreateWithoutCreated_byInput, estimations_aidesUncheckedCreateWithoutCreated_byInput> | estimations_aidesCreateWithoutCreated_byInput[] | estimations_aidesUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutCreated_byInput | estimations_aidesCreateOrConnectWithoutCreated_byInput[]
    upsert?: estimations_aidesUpsertWithWhereUniqueWithoutCreated_byInput | estimations_aidesUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: estimations_aidesCreateManyCreated_byInputEnvelope
    set?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    disconnect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    delete?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    update?: estimations_aidesUpdateWithWhereUniqueWithoutCreated_byInput | estimations_aidesUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: estimations_aidesUpdateManyWithWhereWithoutCreated_byInput | estimations_aidesUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
  }

  export type projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput = {
    create?: XOR<projet_ficheCreateWithoutCreated_byInput, projet_ficheUncheckedCreateWithoutCreated_byInput> | projet_ficheCreateWithoutCreated_byInput[] | projet_ficheUncheckedCreateWithoutCreated_byInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutCreated_byInput | projet_ficheCreateOrConnectWithoutCreated_byInput[]
    upsert?: projet_ficheUpsertWithWhereUniqueWithoutCreated_byInput | projet_ficheUpsertWithWhereUniqueWithoutCreated_byInput[]
    createMany?: projet_ficheCreateManyCreated_byInputEnvelope
    set?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    disconnect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    delete?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    update?: projet_ficheUpdateWithWhereUniqueWithoutCreated_byInput | projet_ficheUpdateWithWhereUniqueWithoutCreated_byInput[]
    updateMany?: projet_ficheUpdateManyWithWhereWithoutCreated_byInput | projet_ficheUpdateManyWithWhereWithoutCreated_byInput[]
    deleteMany?: projet_ficheScalarWhereInput | projet_ficheScalarWhereInput[]
  }

  export type diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<diagnostic_simulationCreateWithoutUserInput, diagnostic_simulationUncheckedCreateWithoutUserInput> | diagnostic_simulationCreateWithoutUserInput[] | diagnostic_simulationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutUserInput | diagnostic_simulationCreateOrConnectWithoutUserInput[]
    upsert?: diagnostic_simulationUpsertWithWhereUniqueWithoutUserInput | diagnostic_simulationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: diagnostic_simulationCreateManyUserInputEnvelope
    set?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    disconnect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    delete?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    update?: diagnostic_simulationUpdateWithWhereUniqueWithoutUserInput | diagnostic_simulationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: diagnostic_simulationUpdateManyWithWhereWithoutUserInput | diagnostic_simulationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: diagnostic_simulationScalarWhereInput | diagnostic_simulationScalarWhereInput[]
  }

  export type user_collectiviteCreateNestedManyWithoutCollectiviteInput = {
    create?: XOR<user_collectiviteCreateWithoutCollectiviteInput, user_collectiviteUncheckedCreateWithoutCollectiviteInput> | user_collectiviteCreateWithoutCollectiviteInput[] | user_collectiviteUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutCollectiviteInput | user_collectiviteCreateOrConnectWithoutCollectiviteInput[]
    createMany?: user_collectiviteCreateManyCollectiviteInputEnvelope
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCollectivites_createdInput = {
    create?: XOR<UserCreateWithoutCollectivites_createdInput, UserUncheckedCreateWithoutCollectivites_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollectivites_createdInput
    connect?: UserWhereUniqueInput
  }

  export type projetCreateNestedManyWithoutCollectiviteInput = {
    create?: XOR<projetCreateWithoutCollectiviteInput, projetUncheckedCreateWithoutCollectiviteInput> | projetCreateWithoutCollectiviteInput[] | projetUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCollectiviteInput | projetCreateOrConnectWithoutCollectiviteInput[]
    createMany?: projetCreateManyCollectiviteInputEnvelope
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
  }

  export type user_collectiviteUncheckedCreateNestedManyWithoutCollectiviteInput = {
    create?: XOR<user_collectiviteCreateWithoutCollectiviteInput, user_collectiviteUncheckedCreateWithoutCollectiviteInput> | user_collectiviteCreateWithoutCollectiviteInput[] | user_collectiviteUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutCollectiviteInput | user_collectiviteCreateOrConnectWithoutCollectiviteInput[]
    createMany?: user_collectiviteCreateManyCollectiviteInputEnvelope
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
  }

  export type projetUncheckedCreateNestedManyWithoutCollectiviteInput = {
    create?: XOR<projetCreateWithoutCollectiviteInput, projetUncheckedCreateWithoutCollectiviteInput> | projetCreateWithoutCollectiviteInput[] | projetUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCollectiviteInput | projetCreateOrConnectWithoutCollectiviteInput[]
    createMany?: projetCreateManyCollectiviteInputEnvelope
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type user_collectiviteUpdateManyWithoutCollectiviteNestedInput = {
    create?: XOR<user_collectiviteCreateWithoutCollectiviteInput, user_collectiviteUncheckedCreateWithoutCollectiviteInput> | user_collectiviteCreateWithoutCollectiviteInput[] | user_collectiviteUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutCollectiviteInput | user_collectiviteCreateOrConnectWithoutCollectiviteInput[]
    upsert?: user_collectiviteUpsertWithWhereUniqueWithoutCollectiviteInput | user_collectiviteUpsertWithWhereUniqueWithoutCollectiviteInput[]
    createMany?: user_collectiviteCreateManyCollectiviteInputEnvelope
    set?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    disconnect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    delete?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    update?: user_collectiviteUpdateWithWhereUniqueWithoutCollectiviteInput | user_collectiviteUpdateWithWhereUniqueWithoutCollectiviteInput[]
    updateMany?: user_collectiviteUpdateManyWithWhereWithoutCollectiviteInput | user_collectiviteUpdateManyWithWhereWithoutCollectiviteInput[]
    deleteMany?: user_collectiviteScalarWhereInput | user_collectiviteScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCollectivites_createdNestedInput = {
    create?: XOR<UserCreateWithoutCollectivites_createdInput, UserUncheckedCreateWithoutCollectivites_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollectivites_createdInput
    upsert?: UserUpsertWithoutCollectivites_createdInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCollectivites_createdInput, UserUpdateWithoutCollectivites_createdInput>, UserUncheckedUpdateWithoutCollectivites_createdInput>
  }

  export type projetUpdateManyWithoutCollectiviteNestedInput = {
    create?: XOR<projetCreateWithoutCollectiviteInput, projetUncheckedCreateWithoutCollectiviteInput> | projetCreateWithoutCollectiviteInput[] | projetUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCollectiviteInput | projetCreateOrConnectWithoutCollectiviteInput[]
    upsert?: projetUpsertWithWhereUniqueWithoutCollectiviteInput | projetUpsertWithWhereUniqueWithoutCollectiviteInput[]
    createMany?: projetCreateManyCollectiviteInputEnvelope
    set?: projetWhereUniqueInput | projetWhereUniqueInput[]
    disconnect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    delete?: projetWhereUniqueInput | projetWhereUniqueInput[]
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    update?: projetUpdateWithWhereUniqueWithoutCollectiviteInput | projetUpdateWithWhereUniqueWithoutCollectiviteInput[]
    updateMany?: projetUpdateManyWithWhereWithoutCollectiviteInput | projetUpdateManyWithWhereWithoutCollectiviteInput[]
    deleteMany?: projetScalarWhereInput | projetScalarWhereInput[]
  }

  export type user_collectiviteUncheckedUpdateManyWithoutCollectiviteNestedInput = {
    create?: XOR<user_collectiviteCreateWithoutCollectiviteInput, user_collectiviteUncheckedCreateWithoutCollectiviteInput> | user_collectiviteCreateWithoutCollectiviteInput[] | user_collectiviteUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: user_collectiviteCreateOrConnectWithoutCollectiviteInput | user_collectiviteCreateOrConnectWithoutCollectiviteInput[]
    upsert?: user_collectiviteUpsertWithWhereUniqueWithoutCollectiviteInput | user_collectiviteUpsertWithWhereUniqueWithoutCollectiviteInput[]
    createMany?: user_collectiviteCreateManyCollectiviteInputEnvelope
    set?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    disconnect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    delete?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    connect?: user_collectiviteWhereUniqueInput | user_collectiviteWhereUniqueInput[]
    update?: user_collectiviteUpdateWithWhereUniqueWithoutCollectiviteInput | user_collectiviteUpdateWithWhereUniqueWithoutCollectiviteInput[]
    updateMany?: user_collectiviteUpdateManyWithWhereWithoutCollectiviteInput | user_collectiviteUpdateManyWithWhereWithoutCollectiviteInput[]
    deleteMany?: user_collectiviteScalarWhereInput | user_collectiviteScalarWhereInput[]
  }

  export type projetUncheckedUpdateManyWithoutCollectiviteNestedInput = {
    create?: XOR<projetCreateWithoutCollectiviteInput, projetUncheckedCreateWithoutCollectiviteInput> | projetCreateWithoutCollectiviteInput[] | projetUncheckedCreateWithoutCollectiviteInput[]
    connectOrCreate?: projetCreateOrConnectWithoutCollectiviteInput | projetCreateOrConnectWithoutCollectiviteInput[]
    upsert?: projetUpsertWithWhereUniqueWithoutCollectiviteInput | projetUpsertWithWhereUniqueWithoutCollectiviteInput[]
    createMany?: projetCreateManyCollectiviteInputEnvelope
    set?: projetWhereUniqueInput | projetWhereUniqueInput[]
    disconnect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    delete?: projetWhereUniqueInput | projetWhereUniqueInput[]
    connect?: projetWhereUniqueInput | projetWhereUniqueInput[]
    update?: projetUpdateWithWhereUniqueWithoutCollectiviteInput | projetUpdateWithWhereUniqueWithoutCollectiviteInput[]
    updateMany?: projetUpdateManyWithWhereWithoutCollectiviteInput | projetUpdateManyWithWhereWithoutCollectiviteInput[]
    deleteMany?: projetScalarWhereInput | projetScalarWhereInput[]
  }

  export type projetCreateNestedOneWithoutUsersInput = {
    create?: XOR<projetCreateWithoutUsersInput, projetUncheckedCreateWithoutUsersInput>
    connectOrCreate?: projetCreateOrConnectWithoutUsersInput
    connect?: projetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjetsInput = {
    create?: XOR<UserCreateWithoutProjetsInput, UserUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_projet_deletedInput = {
    create?: XOR<UserCreateWithoutUser_projet_deletedInput, UserUncheckedCreateWithoutUser_projet_deletedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_projet_deletedInput
    connect?: UserWhereUniqueInput
  }

  export type emailCreateNestedManyWithoutUser_projetInput = {
    create?: XOR<emailCreateWithoutUser_projetInput, emailUncheckedCreateWithoutUser_projetInput> | emailCreateWithoutUser_projetInput[] | emailUncheckedCreateWithoutUser_projetInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUser_projetInput | emailCreateOrConnectWithoutUser_projetInput[]
    createMany?: emailCreateManyUser_projetInputEnvelope
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
  }

  export type projet_sourcing_contactCreateNestedManyWithoutSourced_user_projetInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput> | projet_sourcing_contactCreateWithoutSourced_user_projetInput[] | projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput | projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput[]
    createMany?: projet_sourcing_contactCreateManySourced_user_projetInputEnvelope
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
  }

  export type emailUncheckedCreateNestedManyWithoutUser_projetInput = {
    create?: XOR<emailCreateWithoutUser_projetInput, emailUncheckedCreateWithoutUser_projetInput> | emailCreateWithoutUser_projetInput[] | emailUncheckedCreateWithoutUser_projetInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUser_projetInput | emailCreateOrConnectWithoutUser_projetInput[]
    createMany?: emailCreateManyUser_projetInputEnvelope
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
  }

  export type projet_sourcing_contactUncheckedCreateNestedManyWithoutSourced_user_projetInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput> | projet_sourcing_contactCreateWithoutSourced_user_projetInput[] | projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput | projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput[]
    createMany?: projet_sourcing_contactCreateManySourced_user_projetInputEnvelope
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
  }

  export type EnumRoleProjetFieldUpdateOperationsInput = {
    set?: $Enums.RoleProjet
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type projetUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<projetCreateWithoutUsersInput, projetUncheckedCreateWithoutUsersInput>
    connectOrCreate?: projetCreateOrConnectWithoutUsersInput
    upsert?: projetUpsertWithoutUsersInput
    connect?: projetWhereUniqueInput
    update?: XOR<XOR<projetUpdateToOneWithWhereWithoutUsersInput, projetUpdateWithoutUsersInput>, projetUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutProjetsNestedInput = {
    create?: XOR<UserCreateWithoutProjetsInput, UserUncheckedCreateWithoutProjetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjetsInput
    upsert?: UserUpsertWithoutProjetsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjetsInput, UserUpdateWithoutProjetsInput>, UserUncheckedUpdateWithoutProjetsInput>
  }

  export type UserUpdateOneWithoutUser_projet_deletedNestedInput = {
    create?: XOR<UserCreateWithoutUser_projet_deletedInput, UserUncheckedCreateWithoutUser_projet_deletedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_projet_deletedInput
    upsert?: UserUpsertWithoutUser_projet_deletedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_projet_deletedInput, UserUpdateWithoutUser_projet_deletedInput>, UserUncheckedUpdateWithoutUser_projet_deletedInput>
  }

  export type emailUpdateManyWithoutUser_projetNestedInput = {
    create?: XOR<emailCreateWithoutUser_projetInput, emailUncheckedCreateWithoutUser_projetInput> | emailCreateWithoutUser_projetInput[] | emailUncheckedCreateWithoutUser_projetInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUser_projetInput | emailCreateOrConnectWithoutUser_projetInput[]
    upsert?: emailUpsertWithWhereUniqueWithoutUser_projetInput | emailUpsertWithWhereUniqueWithoutUser_projetInput[]
    createMany?: emailCreateManyUser_projetInputEnvelope
    set?: emailWhereUniqueInput | emailWhereUniqueInput[]
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[]
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    update?: emailUpdateWithWhereUniqueWithoutUser_projetInput | emailUpdateWithWhereUniqueWithoutUser_projetInput[]
    updateMany?: emailUpdateManyWithWhereWithoutUser_projetInput | emailUpdateManyWithWhereWithoutUser_projetInput[]
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[]
  }

  export type projet_sourcing_contactUpdateManyWithoutSourced_user_projetNestedInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput> | projet_sourcing_contactCreateWithoutSourced_user_projetInput[] | projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput | projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput[]
    upsert?: projet_sourcing_contactUpsertWithWhereUniqueWithoutSourced_user_projetInput | projet_sourcing_contactUpsertWithWhereUniqueWithoutSourced_user_projetInput[]
    createMany?: projet_sourcing_contactCreateManySourced_user_projetInputEnvelope
    set?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    disconnect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    delete?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    update?: projet_sourcing_contactUpdateWithWhereUniqueWithoutSourced_user_projetInput | projet_sourcing_contactUpdateWithWhereUniqueWithoutSourced_user_projetInput[]
    updateMany?: projet_sourcing_contactUpdateManyWithWhereWithoutSourced_user_projetInput | projet_sourcing_contactUpdateManyWithWhereWithoutSourced_user_projetInput[]
    deleteMany?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
  }

  export type emailUncheckedUpdateManyWithoutUser_projetNestedInput = {
    create?: XOR<emailCreateWithoutUser_projetInput, emailUncheckedCreateWithoutUser_projetInput> | emailCreateWithoutUser_projetInput[] | emailUncheckedCreateWithoutUser_projetInput[]
    connectOrCreate?: emailCreateOrConnectWithoutUser_projetInput | emailCreateOrConnectWithoutUser_projetInput[]
    upsert?: emailUpsertWithWhereUniqueWithoutUser_projetInput | emailUpsertWithWhereUniqueWithoutUser_projetInput[]
    createMany?: emailCreateManyUser_projetInputEnvelope
    set?: emailWhereUniqueInput | emailWhereUniqueInput[]
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[]
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[]
    update?: emailUpdateWithWhereUniqueWithoutUser_projetInput | emailUpdateWithWhereUniqueWithoutUser_projetInput[]
    updateMany?: emailUpdateManyWithWhereWithoutUser_projetInput | emailUpdateManyWithWhereWithoutUser_projetInput[]
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[]
  }

  export type projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetNestedInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput> | projet_sourcing_contactCreateWithoutSourced_user_projetInput[] | projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput | projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput[]
    upsert?: projet_sourcing_contactUpsertWithWhereUniqueWithoutSourced_user_projetInput | projet_sourcing_contactUpsertWithWhereUniqueWithoutSourced_user_projetInput[]
    createMany?: projet_sourcing_contactCreateManySourced_user_projetInputEnvelope
    set?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    disconnect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    delete?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    update?: projet_sourcing_contactUpdateWithWhereUniqueWithoutSourced_user_projetInput | projet_sourcing_contactUpdateWithWhereUniqueWithoutSourced_user_projetInput[]
    updateMany?: projet_sourcing_contactUpdateManyWithWhereWithoutSourced_user_projetInput | projet_sourcing_contactUpdateManyWithWhereWithoutSourced_user_projetInput[]
    deleteMany?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
  }

  export type user_projetCreateNestedOneWithoutEmailInput = {
    create?: XOR<user_projetCreateWithoutEmailInput, user_projetUncheckedCreateWithoutEmailInput>
    connectOrCreate?: user_projetCreateOrConnectWithoutEmailInput
    connect?: user_projetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailsInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumemailTypeFieldUpdateOperationsInput = {
    set?: $Enums.emailType
  }

  export type EnumemailStatusFieldUpdateOperationsInput = {
    set?: $Enums.emailStatus
  }

  export type user_projetUpdateOneWithoutEmailNestedInput = {
    create?: XOR<user_projetCreateWithoutEmailInput, user_projetUncheckedCreateWithoutEmailInput>
    connectOrCreate?: user_projetCreateOrConnectWithoutEmailInput
    upsert?: user_projetUpsertWithoutEmailInput
    disconnect?: user_projetWhereInput | boolean
    delete?: user_projetWhereInput | boolean
    connect?: user_projetWhereUniqueInput
    update?: XOR<XOR<user_projetUpdateToOneWithWhereWithoutEmailInput, user_projetUpdateWithoutEmailInput>, user_projetUncheckedUpdateWithoutEmailInput>
  }

  export type UserUpdateOneWithoutEmailsNestedInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    upsert?: UserUpsertWithoutEmailsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailsInput, UserUpdateWithoutEmailsInput>, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserCreateNestedOneWithoutCollectivitesInput = {
    create?: XOR<UserCreateWithoutCollectivitesInput, UserUncheckedCreateWithoutCollectivitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollectivitesInput
    connect?: UserWhereUniqueInput
  }

  export type collectiviteCreateNestedOneWithoutUsersInput = {
    create?: XOR<collectiviteCreateWithoutUsersInput, collectiviteUncheckedCreateWithoutUsersInput>
    connectOrCreate?: collectiviteCreateOrConnectWithoutUsersInput
    connect?: collectiviteWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCollectivitesNestedInput = {
    create?: XOR<UserCreateWithoutCollectivitesInput, UserUncheckedCreateWithoutCollectivitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollectivitesInput
    upsert?: UserUpsertWithoutCollectivitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCollectivitesInput, UserUpdateWithoutCollectivitesInput>, UserUncheckedUpdateWithoutCollectivitesInput>
  }

  export type collectiviteUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<collectiviteCreateWithoutUsersInput, collectiviteUncheckedCreateWithoutUsersInput>
    connectOrCreate?: collectiviteCreateOrConnectWithoutUsersInput
    upsert?: collectiviteUpsertWithoutUsersInput
    connect?: collectiviteWhereUniqueInput
    update?: XOR<XOR<collectiviteUpdateToOneWithWhereWithoutUsersInput, collectiviteUpdateWithoutUsersInput>, collectiviteUncheckedUpdateWithoutUsersInput>
  }

  export type projetCreatefiches_solutions_idInput = {
    set: number[]
  }

  export type projetCreatefiches_diagnostic_idInput = {
    set: number[]
  }

  export type projetCreaterecommandations_viewed_byInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProjets_createdInput = {
    create?: XOR<UserCreateWithoutProjets_createdInput, UserUncheckedCreateWithoutProjets_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjets_createdInput
    connect?: UserWhereUniqueInput
  }

  export type estimationCreateNestedManyWithoutProjetInput = {
    create?: XOR<estimationCreateWithoutProjetInput, estimationUncheckedCreateWithoutProjetInput> | estimationCreateWithoutProjetInput[] | estimationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutProjetInput | estimationCreateOrConnectWithoutProjetInput[]
    createMany?: estimationCreateManyProjetInputEnvelope
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
  }

  export type collectiviteCreateNestedOneWithoutProjetInput = {
    create?: XOR<collectiviteCreateWithoutProjetInput, collectiviteUncheckedCreateWithoutProjetInput>
    connectOrCreate?: collectiviteCreateOrConnectWithoutProjetInput
    connect?: collectiviteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjets_deletedInput = {
    create?: XOR<UserCreateWithoutProjets_deletedInput, UserUncheckedCreateWithoutProjets_deletedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjets_deletedInput
    connect?: UserWhereUniqueInput
  }

  export type user_projetCreateNestedManyWithoutProjetInput = {
    create?: XOR<user_projetCreateWithoutProjetInput, user_projetUncheckedCreateWithoutProjetInput> | user_projetCreateWithoutProjetInput[] | user_projetUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutProjetInput | user_projetCreateOrConnectWithoutProjetInput[]
    createMany?: user_projetCreateManyProjetInputEnvelope
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
  }

  export type projet_sourcing_contactCreateNestedManyWithoutProjetInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutProjetInput, projet_sourcing_contactUncheckedCreateWithoutProjetInput> | projet_sourcing_contactCreateWithoutProjetInput[] | projet_sourcing_contactUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutProjetInput | projet_sourcing_contactCreateOrConnectWithoutProjetInput[]
    createMany?: projet_sourcing_contactCreateManyProjetInputEnvelope
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
  }

  export type projet_ficheCreateNestedManyWithoutProjetInput = {
    create?: XOR<projet_ficheCreateWithoutProjetInput, projet_ficheUncheckedCreateWithoutProjetInput> | projet_ficheCreateWithoutProjetInput[] | projet_ficheUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutProjetInput | projet_ficheCreateOrConnectWithoutProjetInput[]
    createMany?: projet_ficheCreateManyProjetInputEnvelope
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
  }

  export type diagnostic_simulationCreateNestedManyWithoutProjetInput = {
    create?: XOR<diagnostic_simulationCreateWithoutProjetInput, diagnostic_simulationUncheckedCreateWithoutProjetInput> | diagnostic_simulationCreateWithoutProjetInput[] | diagnostic_simulationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutProjetInput | diagnostic_simulationCreateOrConnectWithoutProjetInput[]
    createMany?: diagnostic_simulationCreateManyProjetInputEnvelope
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
  }

  export type estimationUncheckedCreateNestedManyWithoutProjetInput = {
    create?: XOR<estimationCreateWithoutProjetInput, estimationUncheckedCreateWithoutProjetInput> | estimationCreateWithoutProjetInput[] | estimationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutProjetInput | estimationCreateOrConnectWithoutProjetInput[]
    createMany?: estimationCreateManyProjetInputEnvelope
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
  }

  export type user_projetUncheckedCreateNestedManyWithoutProjetInput = {
    create?: XOR<user_projetCreateWithoutProjetInput, user_projetUncheckedCreateWithoutProjetInput> | user_projetCreateWithoutProjetInput[] | user_projetUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutProjetInput | user_projetCreateOrConnectWithoutProjetInput[]
    createMany?: user_projetCreateManyProjetInputEnvelope
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
  }

  export type projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutProjetInput, projet_sourcing_contactUncheckedCreateWithoutProjetInput> | projet_sourcing_contactCreateWithoutProjetInput[] | projet_sourcing_contactUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutProjetInput | projet_sourcing_contactCreateOrConnectWithoutProjetInput[]
    createMany?: projet_sourcing_contactCreateManyProjetInputEnvelope
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
  }

  export type projet_ficheUncheckedCreateNestedManyWithoutProjetInput = {
    create?: XOR<projet_ficheCreateWithoutProjetInput, projet_ficheUncheckedCreateWithoutProjetInput> | projet_ficheCreateWithoutProjetInput[] | projet_ficheUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutProjetInput | projet_ficheCreateOrConnectWithoutProjetInput[]
    createMany?: projet_ficheCreateManyProjetInputEnvelope
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
  }

  export type diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput = {
    create?: XOR<diagnostic_simulationCreateWithoutProjetInput, diagnostic_simulationUncheckedCreateWithoutProjetInput> | diagnostic_simulationCreateWithoutProjetInput[] | diagnostic_simulationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutProjetInput | diagnostic_simulationCreateOrConnectWithoutProjetInput[]
    createMany?: diagnostic_simulationCreateManyProjetInputEnvelope
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
  }

  export type projetUpdatefiches_solutions_idInput = {
    set?: number[]
    push?: number | number[]
  }

  export type projetUpdatefiches_diagnostic_idInput = {
    set?: number[]
    push?: number | number[]
  }

  export type projetUpdaterecommandations_viewed_byInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumStatutProjetFieldUpdateOperationsInput = {
    set?: $Enums.StatutProjet | null
  }

  export type UserUpdateOneRequiredWithoutProjets_createdNestedInput = {
    create?: XOR<UserCreateWithoutProjets_createdInput, UserUncheckedCreateWithoutProjets_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjets_createdInput
    upsert?: UserUpsertWithoutProjets_createdInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjets_createdInput, UserUpdateWithoutProjets_createdInput>, UserUncheckedUpdateWithoutProjets_createdInput>
  }

  export type estimationUpdateManyWithoutProjetNestedInput = {
    create?: XOR<estimationCreateWithoutProjetInput, estimationUncheckedCreateWithoutProjetInput> | estimationCreateWithoutProjetInput[] | estimationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutProjetInput | estimationCreateOrConnectWithoutProjetInput[]
    upsert?: estimationUpsertWithWhereUniqueWithoutProjetInput | estimationUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: estimationCreateManyProjetInputEnvelope
    set?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    disconnect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    delete?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    update?: estimationUpdateWithWhereUniqueWithoutProjetInput | estimationUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: estimationUpdateManyWithWhereWithoutProjetInput | estimationUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: estimationScalarWhereInput | estimationScalarWhereInput[]
  }

  export type collectiviteUpdateOneRequiredWithoutProjetNestedInput = {
    create?: XOR<collectiviteCreateWithoutProjetInput, collectiviteUncheckedCreateWithoutProjetInput>
    connectOrCreate?: collectiviteCreateOrConnectWithoutProjetInput
    upsert?: collectiviteUpsertWithoutProjetInput
    connect?: collectiviteWhereUniqueInput
    update?: XOR<XOR<collectiviteUpdateToOneWithWhereWithoutProjetInput, collectiviteUpdateWithoutProjetInput>, collectiviteUncheckedUpdateWithoutProjetInput>
  }

  export type UserUpdateOneWithoutProjets_deletedNestedInput = {
    create?: XOR<UserCreateWithoutProjets_deletedInput, UserUncheckedCreateWithoutProjets_deletedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjets_deletedInput
    upsert?: UserUpsertWithoutProjets_deletedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjets_deletedInput, UserUpdateWithoutProjets_deletedInput>, UserUncheckedUpdateWithoutProjets_deletedInput>
  }

  export type user_projetUpdateManyWithoutProjetNestedInput = {
    create?: XOR<user_projetCreateWithoutProjetInput, user_projetUncheckedCreateWithoutProjetInput> | user_projetCreateWithoutProjetInput[] | user_projetUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutProjetInput | user_projetCreateOrConnectWithoutProjetInput[]
    upsert?: user_projetUpsertWithWhereUniqueWithoutProjetInput | user_projetUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: user_projetCreateManyProjetInputEnvelope
    set?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    disconnect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    delete?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    update?: user_projetUpdateWithWhereUniqueWithoutProjetInput | user_projetUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: user_projetUpdateManyWithWhereWithoutProjetInput | user_projetUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
  }

  export type projet_sourcing_contactUpdateManyWithoutProjetNestedInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutProjetInput, projet_sourcing_contactUncheckedCreateWithoutProjetInput> | projet_sourcing_contactCreateWithoutProjetInput[] | projet_sourcing_contactUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutProjetInput | projet_sourcing_contactCreateOrConnectWithoutProjetInput[]
    upsert?: projet_sourcing_contactUpsertWithWhereUniqueWithoutProjetInput | projet_sourcing_contactUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: projet_sourcing_contactCreateManyProjetInputEnvelope
    set?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    disconnect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    delete?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    update?: projet_sourcing_contactUpdateWithWhereUniqueWithoutProjetInput | projet_sourcing_contactUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: projet_sourcing_contactUpdateManyWithWhereWithoutProjetInput | projet_sourcing_contactUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
  }

  export type projet_ficheUpdateManyWithoutProjetNestedInput = {
    create?: XOR<projet_ficheCreateWithoutProjetInput, projet_ficheUncheckedCreateWithoutProjetInput> | projet_ficheCreateWithoutProjetInput[] | projet_ficheUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutProjetInput | projet_ficheCreateOrConnectWithoutProjetInput[]
    upsert?: projet_ficheUpsertWithWhereUniqueWithoutProjetInput | projet_ficheUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: projet_ficheCreateManyProjetInputEnvelope
    set?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    disconnect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    delete?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    update?: projet_ficheUpdateWithWhereUniqueWithoutProjetInput | projet_ficheUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: projet_ficheUpdateManyWithWhereWithoutProjetInput | projet_ficheUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: projet_ficheScalarWhereInput | projet_ficheScalarWhereInput[]
  }

  export type diagnostic_simulationUpdateManyWithoutProjetNestedInput = {
    create?: XOR<diagnostic_simulationCreateWithoutProjetInput, diagnostic_simulationUncheckedCreateWithoutProjetInput> | diagnostic_simulationCreateWithoutProjetInput[] | diagnostic_simulationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutProjetInput | diagnostic_simulationCreateOrConnectWithoutProjetInput[]
    upsert?: diagnostic_simulationUpsertWithWhereUniqueWithoutProjetInput | diagnostic_simulationUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: diagnostic_simulationCreateManyProjetInputEnvelope
    set?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    disconnect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    delete?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    update?: diagnostic_simulationUpdateWithWhereUniqueWithoutProjetInput | diagnostic_simulationUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: diagnostic_simulationUpdateManyWithWhereWithoutProjetInput | diagnostic_simulationUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: diagnostic_simulationScalarWhereInput | diagnostic_simulationScalarWhereInput[]
  }

  export type estimationUncheckedUpdateManyWithoutProjetNestedInput = {
    create?: XOR<estimationCreateWithoutProjetInput, estimationUncheckedCreateWithoutProjetInput> | estimationCreateWithoutProjetInput[] | estimationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: estimationCreateOrConnectWithoutProjetInput | estimationCreateOrConnectWithoutProjetInput[]
    upsert?: estimationUpsertWithWhereUniqueWithoutProjetInput | estimationUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: estimationCreateManyProjetInputEnvelope
    set?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    disconnect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    delete?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    connect?: estimationWhereUniqueInput | estimationWhereUniqueInput[]
    update?: estimationUpdateWithWhereUniqueWithoutProjetInput | estimationUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: estimationUpdateManyWithWhereWithoutProjetInput | estimationUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: estimationScalarWhereInput | estimationScalarWhereInput[]
  }

  export type user_projetUncheckedUpdateManyWithoutProjetNestedInput = {
    create?: XOR<user_projetCreateWithoutProjetInput, user_projetUncheckedCreateWithoutProjetInput> | user_projetCreateWithoutProjetInput[] | user_projetUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: user_projetCreateOrConnectWithoutProjetInput | user_projetCreateOrConnectWithoutProjetInput[]
    upsert?: user_projetUpsertWithWhereUniqueWithoutProjetInput | user_projetUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: user_projetCreateManyProjetInputEnvelope
    set?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    disconnect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    delete?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    connect?: user_projetWhereUniqueInput | user_projetWhereUniqueInput[]
    update?: user_projetUpdateWithWhereUniqueWithoutProjetInput | user_projetUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: user_projetUpdateManyWithWhereWithoutProjetInput | user_projetUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
  }

  export type projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput = {
    create?: XOR<projet_sourcing_contactCreateWithoutProjetInput, projet_sourcing_contactUncheckedCreateWithoutProjetInput> | projet_sourcing_contactCreateWithoutProjetInput[] | projet_sourcing_contactUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_sourcing_contactCreateOrConnectWithoutProjetInput | projet_sourcing_contactCreateOrConnectWithoutProjetInput[]
    upsert?: projet_sourcing_contactUpsertWithWhereUniqueWithoutProjetInput | projet_sourcing_contactUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: projet_sourcing_contactCreateManyProjetInputEnvelope
    set?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    disconnect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    delete?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    connect?: projet_sourcing_contactWhereUniqueInput | projet_sourcing_contactWhereUniqueInput[]
    update?: projet_sourcing_contactUpdateWithWhereUniqueWithoutProjetInput | projet_sourcing_contactUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: projet_sourcing_contactUpdateManyWithWhereWithoutProjetInput | projet_sourcing_contactUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
  }

  export type projet_ficheUncheckedUpdateManyWithoutProjetNestedInput = {
    create?: XOR<projet_ficheCreateWithoutProjetInput, projet_ficheUncheckedCreateWithoutProjetInput> | projet_ficheCreateWithoutProjetInput[] | projet_ficheUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: projet_ficheCreateOrConnectWithoutProjetInput | projet_ficheCreateOrConnectWithoutProjetInput[]
    upsert?: projet_ficheUpsertWithWhereUniqueWithoutProjetInput | projet_ficheUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: projet_ficheCreateManyProjetInputEnvelope
    set?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    disconnect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    delete?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    connect?: projet_ficheWhereUniqueInput | projet_ficheWhereUniqueInput[]
    update?: projet_ficheUpdateWithWhereUniqueWithoutProjetInput | projet_ficheUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: projet_ficheUpdateManyWithWhereWithoutProjetInput | projet_ficheUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: projet_ficheScalarWhereInput | projet_ficheScalarWhereInput[]
  }

  export type diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput = {
    create?: XOR<diagnostic_simulationCreateWithoutProjetInput, diagnostic_simulationUncheckedCreateWithoutProjetInput> | diagnostic_simulationCreateWithoutProjetInput[] | diagnostic_simulationUncheckedCreateWithoutProjetInput[]
    connectOrCreate?: diagnostic_simulationCreateOrConnectWithoutProjetInput | diagnostic_simulationCreateOrConnectWithoutProjetInput[]
    upsert?: diagnostic_simulationUpsertWithWhereUniqueWithoutProjetInput | diagnostic_simulationUpsertWithWhereUniqueWithoutProjetInput[]
    createMany?: diagnostic_simulationCreateManyProjetInputEnvelope
    set?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    disconnect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    delete?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    connect?: diagnostic_simulationWhereUniqueInput | diagnostic_simulationWhereUniqueInput[]
    update?: diagnostic_simulationUpdateWithWhereUniqueWithoutProjetInput | diagnostic_simulationUpdateWithWhereUniqueWithoutProjetInput[]
    updateMany?: diagnostic_simulationUpdateManyWithWhereWithoutProjetInput | diagnostic_simulationUpdateManyWithWhereWithoutProjetInput[]
    deleteMany?: diagnostic_simulationScalarWhereInput | diagnostic_simulationScalarWhereInput[]
  }

  export type projetCreateNestedOneWithoutFichesInput = {
    create?: XOR<projetCreateWithoutFichesInput, projetUncheckedCreateWithoutFichesInput>
    connectOrCreate?: projetCreateOrConnectWithoutFichesInput
    connect?: projetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFichesInput = {
    create?: XOR<UserCreateWithoutFichesInput, UserUncheckedCreateWithoutFichesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFichesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFicheTypeFieldUpdateOperationsInput = {
    set?: $Enums.FicheType
  }

  export type projetUpdateOneRequiredWithoutFichesNestedInput = {
    create?: XOR<projetCreateWithoutFichesInput, projetUncheckedCreateWithoutFichesInput>
    connectOrCreate?: projetCreateOrConnectWithoutFichesInput
    upsert?: projetUpsertWithoutFichesInput
    connect?: projetWhereUniqueInput
    update?: XOR<XOR<projetUpdateToOneWithWhereWithoutFichesInput, projetUpdateWithoutFichesInput>, projetUncheckedUpdateWithoutFichesInput>
  }

  export type UserUpdateOneRequiredWithoutFichesNestedInput = {
    create?: XOR<UserCreateWithoutFichesInput, UserUncheckedCreateWithoutFichesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFichesInput
    upsert?: UserUpsertWithoutFichesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFichesInput, UserUpdateWithoutFichesInput>, UserUncheckedUpdateWithoutFichesInput>
  }

  export type projetCreateNestedOneWithoutSourcing_user_projetsInput = {
    create?: XOR<projetCreateWithoutSourcing_user_projetsInput, projetUncheckedCreateWithoutSourcing_user_projetsInput>
    connectOrCreate?: projetCreateOrConnectWithoutSourcing_user_projetsInput
    connect?: projetWhereUniqueInput
  }

  export type user_projetCreateNestedOneWithoutSourced_by_projetsInput = {
    create?: XOR<user_projetCreateWithoutSourced_by_projetsInput, user_projetUncheckedCreateWithoutSourced_by_projetsInput>
    connectOrCreate?: user_projetCreateOrConnectWithoutSourced_by_projetsInput
    connect?: user_projetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSourcing_contacts_createdInput = {
    create?: XOR<UserCreateWithoutSourcing_contacts_createdInput, UserUncheckedCreateWithoutSourcing_contacts_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutSourcing_contacts_createdInput
    connect?: UserWhereUniqueInput
  }

  export type projetUpdateOneRequiredWithoutSourcing_user_projetsNestedInput = {
    create?: XOR<projetCreateWithoutSourcing_user_projetsInput, projetUncheckedCreateWithoutSourcing_user_projetsInput>
    connectOrCreate?: projetCreateOrConnectWithoutSourcing_user_projetsInput
    upsert?: projetUpsertWithoutSourcing_user_projetsInput
    connect?: projetWhereUniqueInput
    update?: XOR<XOR<projetUpdateToOneWithWhereWithoutSourcing_user_projetsInput, projetUpdateWithoutSourcing_user_projetsInput>, projetUncheckedUpdateWithoutSourcing_user_projetsInput>
  }

  export type user_projetUpdateOneRequiredWithoutSourced_by_projetsNestedInput = {
    create?: XOR<user_projetCreateWithoutSourced_by_projetsInput, user_projetUncheckedCreateWithoutSourced_by_projetsInput>
    connectOrCreate?: user_projetCreateOrConnectWithoutSourced_by_projetsInput
    upsert?: user_projetUpsertWithoutSourced_by_projetsInput
    connect?: user_projetWhereUniqueInput
    update?: XOR<XOR<user_projetUpdateToOneWithWhereWithoutSourced_by_projetsInput, user_projetUpdateWithoutSourced_by_projetsInput>, user_projetUncheckedUpdateWithoutSourced_by_projetsInput>
  }

  export type UserUpdateOneRequiredWithoutSourcing_contacts_createdNestedInput = {
    create?: XOR<UserCreateWithoutSourcing_contacts_createdInput, UserUncheckedCreateWithoutSourcing_contacts_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutSourcing_contacts_createdInput
    upsert?: UserUpsertWithoutSourcing_contacts_createdInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSourcing_contacts_createdInput, UserUpdateWithoutSourcing_contacts_createdInput>, UserUncheckedUpdateWithoutSourcing_contacts_createdInput>
  }

  export type estimationCreatefiches_solutions_idInput = {
    set: number[]
  }

  export type UserCreateNestedOneWithoutEstimations_createdInput = {
    create?: XOR<UserCreateWithoutEstimations_createdInput, UserUncheckedCreateWithoutEstimations_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstimations_createdInput
    connect?: UserWhereUniqueInput
  }

  export type projetCreateNestedOneWithoutEstimationsInput = {
    create?: XOR<projetCreateWithoutEstimationsInput, projetUncheckedCreateWithoutEstimationsInput>
    connectOrCreate?: projetCreateOrConnectWithoutEstimationsInput
    connect?: projetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEstimations_deletedInput = {
    create?: XOR<UserCreateWithoutEstimations_deletedInput, UserUncheckedCreateWithoutEstimations_deletedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstimations_deletedInput
    connect?: UserWhereUniqueInput
  }

  export type estimations_aidesCreateNestedManyWithoutEstimationInput = {
    create?: XOR<estimations_aidesCreateWithoutEstimationInput, estimations_aidesUncheckedCreateWithoutEstimationInput> | estimations_aidesCreateWithoutEstimationInput[] | estimations_aidesUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutEstimationInput | estimations_aidesCreateOrConnectWithoutEstimationInput[]
    createMany?: estimations_aidesCreateManyEstimationInputEnvelope
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
  }

  export type estimation_fiche_solutionCreateNestedManyWithoutEstimationInput = {
    create?: XOR<estimation_fiche_solutionCreateWithoutEstimationInput, estimation_fiche_solutionUncheckedCreateWithoutEstimationInput> | estimation_fiche_solutionCreateWithoutEstimationInput[] | estimation_fiche_solutionUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimation_fiche_solutionCreateOrConnectWithoutEstimationInput | estimation_fiche_solutionCreateOrConnectWithoutEstimationInput[]
    createMany?: estimation_fiche_solutionCreateManyEstimationInputEnvelope
    connect?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
  }

  export type estimations_aidesUncheckedCreateNestedManyWithoutEstimationInput = {
    create?: XOR<estimations_aidesCreateWithoutEstimationInput, estimations_aidesUncheckedCreateWithoutEstimationInput> | estimations_aidesCreateWithoutEstimationInput[] | estimations_aidesUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutEstimationInput | estimations_aidesCreateOrConnectWithoutEstimationInput[]
    createMany?: estimations_aidesCreateManyEstimationInputEnvelope
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
  }

  export type estimation_fiche_solutionUncheckedCreateNestedManyWithoutEstimationInput = {
    create?: XOR<estimation_fiche_solutionCreateWithoutEstimationInput, estimation_fiche_solutionUncheckedCreateWithoutEstimationInput> | estimation_fiche_solutionCreateWithoutEstimationInput[] | estimation_fiche_solutionUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimation_fiche_solutionCreateOrConnectWithoutEstimationInput | estimation_fiche_solutionCreateOrConnectWithoutEstimationInput[]
    createMany?: estimation_fiche_solutionCreateManyEstimationInputEnvelope
    connect?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
  }

  export type estimationUpdatefiches_solutions_idInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserUpdateOneRequiredWithoutEstimations_createdNestedInput = {
    create?: XOR<UserCreateWithoutEstimations_createdInput, UserUncheckedCreateWithoutEstimations_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstimations_createdInput
    upsert?: UserUpsertWithoutEstimations_createdInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEstimations_createdInput, UserUpdateWithoutEstimations_createdInput>, UserUncheckedUpdateWithoutEstimations_createdInput>
  }

  export type projetUpdateOneRequiredWithoutEstimationsNestedInput = {
    create?: XOR<projetCreateWithoutEstimationsInput, projetUncheckedCreateWithoutEstimationsInput>
    connectOrCreate?: projetCreateOrConnectWithoutEstimationsInput
    upsert?: projetUpsertWithoutEstimationsInput
    connect?: projetWhereUniqueInput
    update?: XOR<XOR<projetUpdateToOneWithWhereWithoutEstimationsInput, projetUpdateWithoutEstimationsInput>, projetUncheckedUpdateWithoutEstimationsInput>
  }

  export type UserUpdateOneWithoutEstimations_deletedNestedInput = {
    create?: XOR<UserCreateWithoutEstimations_deletedInput, UserUncheckedCreateWithoutEstimations_deletedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstimations_deletedInput
    upsert?: UserUpsertWithoutEstimations_deletedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEstimations_deletedInput, UserUpdateWithoutEstimations_deletedInput>, UserUncheckedUpdateWithoutEstimations_deletedInput>
  }

  export type estimations_aidesUpdateManyWithoutEstimationNestedInput = {
    create?: XOR<estimations_aidesCreateWithoutEstimationInput, estimations_aidesUncheckedCreateWithoutEstimationInput> | estimations_aidesCreateWithoutEstimationInput[] | estimations_aidesUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutEstimationInput | estimations_aidesCreateOrConnectWithoutEstimationInput[]
    upsert?: estimations_aidesUpsertWithWhereUniqueWithoutEstimationInput | estimations_aidesUpsertWithWhereUniqueWithoutEstimationInput[]
    createMany?: estimations_aidesCreateManyEstimationInputEnvelope
    set?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    disconnect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    delete?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    update?: estimations_aidesUpdateWithWhereUniqueWithoutEstimationInput | estimations_aidesUpdateWithWhereUniqueWithoutEstimationInput[]
    updateMany?: estimations_aidesUpdateManyWithWhereWithoutEstimationInput | estimations_aidesUpdateManyWithWhereWithoutEstimationInput[]
    deleteMany?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
  }

  export type estimation_fiche_solutionUpdateManyWithoutEstimationNestedInput = {
    create?: XOR<estimation_fiche_solutionCreateWithoutEstimationInput, estimation_fiche_solutionUncheckedCreateWithoutEstimationInput> | estimation_fiche_solutionCreateWithoutEstimationInput[] | estimation_fiche_solutionUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimation_fiche_solutionCreateOrConnectWithoutEstimationInput | estimation_fiche_solutionCreateOrConnectWithoutEstimationInput[]
    upsert?: estimation_fiche_solutionUpsertWithWhereUniqueWithoutEstimationInput | estimation_fiche_solutionUpsertWithWhereUniqueWithoutEstimationInput[]
    createMany?: estimation_fiche_solutionCreateManyEstimationInputEnvelope
    set?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    disconnect?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    delete?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    connect?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    update?: estimation_fiche_solutionUpdateWithWhereUniqueWithoutEstimationInput | estimation_fiche_solutionUpdateWithWhereUniqueWithoutEstimationInput[]
    updateMany?: estimation_fiche_solutionUpdateManyWithWhereWithoutEstimationInput | estimation_fiche_solutionUpdateManyWithWhereWithoutEstimationInput[]
    deleteMany?: estimation_fiche_solutionScalarWhereInput | estimation_fiche_solutionScalarWhereInput[]
  }

  export type estimations_aidesUncheckedUpdateManyWithoutEstimationNestedInput = {
    create?: XOR<estimations_aidesCreateWithoutEstimationInput, estimations_aidesUncheckedCreateWithoutEstimationInput> | estimations_aidesCreateWithoutEstimationInput[] | estimations_aidesUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutEstimationInput | estimations_aidesCreateOrConnectWithoutEstimationInput[]
    upsert?: estimations_aidesUpsertWithWhereUniqueWithoutEstimationInput | estimations_aidesUpsertWithWhereUniqueWithoutEstimationInput[]
    createMany?: estimations_aidesCreateManyEstimationInputEnvelope
    set?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    disconnect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    delete?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    update?: estimations_aidesUpdateWithWhereUniqueWithoutEstimationInput | estimations_aidesUpdateWithWhereUniqueWithoutEstimationInput[]
    updateMany?: estimations_aidesUpdateManyWithWhereWithoutEstimationInput | estimations_aidesUpdateManyWithWhereWithoutEstimationInput[]
    deleteMany?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
  }

  export type estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationNestedInput = {
    create?: XOR<estimation_fiche_solutionCreateWithoutEstimationInput, estimation_fiche_solutionUncheckedCreateWithoutEstimationInput> | estimation_fiche_solutionCreateWithoutEstimationInput[] | estimation_fiche_solutionUncheckedCreateWithoutEstimationInput[]
    connectOrCreate?: estimation_fiche_solutionCreateOrConnectWithoutEstimationInput | estimation_fiche_solutionCreateOrConnectWithoutEstimationInput[]
    upsert?: estimation_fiche_solutionUpsertWithWhereUniqueWithoutEstimationInput | estimation_fiche_solutionUpsertWithWhereUniqueWithoutEstimationInput[]
    createMany?: estimation_fiche_solutionCreateManyEstimationInputEnvelope
    set?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    disconnect?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    delete?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    connect?: estimation_fiche_solutionWhereUniqueInput | estimation_fiche_solutionWhereUniqueInput[]
    update?: estimation_fiche_solutionUpdateWithWhereUniqueWithoutEstimationInput | estimation_fiche_solutionUpdateWithWhereUniqueWithoutEstimationInput[]
    updateMany?: estimation_fiche_solutionUpdateManyWithWhereWithoutEstimationInput | estimation_fiche_solutionUpdateManyWithWhereWithoutEstimationInput[]
    deleteMany?: estimation_fiche_solutionScalarWhereInput | estimation_fiche_solutionScalarWhereInput[]
  }

  export type EnumTypeLieuClimadiagFieldUpdateOperationsInput = {
    set?: $Enums.TypeLieuClimadiag
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type aideCreatefinancersInput = {
    set: string[]
  }

  export type estimations_aidesCreateNestedManyWithoutAideInput = {
    create?: XOR<estimations_aidesCreateWithoutAideInput, estimations_aidesUncheckedCreateWithoutAideInput> | estimations_aidesCreateWithoutAideInput[] | estimations_aidesUncheckedCreateWithoutAideInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutAideInput | estimations_aidesCreateOrConnectWithoutAideInput[]
    createMany?: estimations_aidesCreateManyAideInputEnvelope
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
  }

  export type estimations_aidesUncheckedCreateNestedManyWithoutAideInput = {
    create?: XOR<estimations_aidesCreateWithoutAideInput, estimations_aidesUncheckedCreateWithoutAideInput> | estimations_aidesCreateWithoutAideInput[] | estimations_aidesUncheckedCreateWithoutAideInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutAideInput | estimations_aidesCreateOrConnectWithoutAideInput[]
    createMany?: estimations_aidesCreateManyAideInputEnvelope
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
  }

  export type aideUpdatefinancersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type estimations_aidesUpdateManyWithoutAideNestedInput = {
    create?: XOR<estimations_aidesCreateWithoutAideInput, estimations_aidesUncheckedCreateWithoutAideInput> | estimations_aidesCreateWithoutAideInput[] | estimations_aidesUncheckedCreateWithoutAideInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutAideInput | estimations_aidesCreateOrConnectWithoutAideInput[]
    upsert?: estimations_aidesUpsertWithWhereUniqueWithoutAideInput | estimations_aidesUpsertWithWhereUniqueWithoutAideInput[]
    createMany?: estimations_aidesCreateManyAideInputEnvelope
    set?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    disconnect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    delete?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    update?: estimations_aidesUpdateWithWhereUniqueWithoutAideInput | estimations_aidesUpdateWithWhereUniqueWithoutAideInput[]
    updateMany?: estimations_aidesUpdateManyWithWhereWithoutAideInput | estimations_aidesUpdateManyWithWhereWithoutAideInput[]
    deleteMany?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
  }

  export type estimations_aidesUncheckedUpdateManyWithoutAideNestedInput = {
    create?: XOR<estimations_aidesCreateWithoutAideInput, estimations_aidesUncheckedCreateWithoutAideInput> | estimations_aidesCreateWithoutAideInput[] | estimations_aidesUncheckedCreateWithoutAideInput[]
    connectOrCreate?: estimations_aidesCreateOrConnectWithoutAideInput | estimations_aidesCreateOrConnectWithoutAideInput[]
    upsert?: estimations_aidesUpsertWithWhereUniqueWithoutAideInput | estimations_aidesUpsertWithWhereUniqueWithoutAideInput[]
    createMany?: estimations_aidesCreateManyAideInputEnvelope
    set?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    disconnect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    delete?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    connect?: estimations_aidesWhereUniqueInput | estimations_aidesWhereUniqueInput[]
    update?: estimations_aidesUpdateWithWhereUniqueWithoutAideInput | estimations_aidesUpdateWithWhereUniqueWithoutAideInput[]
    updateMany?: estimations_aidesUpdateManyWithWhereWithoutAideInput | estimations_aidesUpdateManyWithWhereWithoutAideInput[]
    deleteMany?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
  }

  export type estimationCreateNestedOneWithoutEstimations_aidesInput = {
    create?: XOR<estimationCreateWithoutEstimations_aidesInput, estimationUncheckedCreateWithoutEstimations_aidesInput>
    connectOrCreate?: estimationCreateOrConnectWithoutEstimations_aidesInput
    connect?: estimationWhereUniqueInput
  }

  export type aideCreateNestedOneWithoutEstimations_aidesInput = {
    create?: XOR<aideCreateWithoutEstimations_aidesInput, aideUncheckedCreateWithoutEstimations_aidesInput>
    connectOrCreate?: aideCreateOrConnectWithoutEstimations_aidesInput
    connect?: aideWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEstimations_aidesInput = {
    create?: XOR<UserCreateWithoutEstimations_aidesInput, UserUncheckedCreateWithoutEstimations_aidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstimations_aidesInput
    connect?: UserWhereUniqueInput
  }

  export type estimationUpdateOneRequiredWithoutEstimations_aidesNestedInput = {
    create?: XOR<estimationCreateWithoutEstimations_aidesInput, estimationUncheckedCreateWithoutEstimations_aidesInput>
    connectOrCreate?: estimationCreateOrConnectWithoutEstimations_aidesInput
    upsert?: estimationUpsertWithoutEstimations_aidesInput
    connect?: estimationWhereUniqueInput
    update?: XOR<XOR<estimationUpdateToOneWithWhereWithoutEstimations_aidesInput, estimationUpdateWithoutEstimations_aidesInput>, estimationUncheckedUpdateWithoutEstimations_aidesInput>
  }

  export type aideUpdateOneRequiredWithoutEstimations_aidesNestedInput = {
    create?: XOR<aideCreateWithoutEstimations_aidesInput, aideUncheckedCreateWithoutEstimations_aidesInput>
    connectOrCreate?: aideCreateOrConnectWithoutEstimations_aidesInput
    upsert?: aideUpsertWithoutEstimations_aidesInput
    connect?: aideWhereUniqueInput
    update?: XOR<XOR<aideUpdateToOneWithWhereWithoutEstimations_aidesInput, aideUpdateWithoutEstimations_aidesInput>, aideUncheckedUpdateWithoutEstimations_aidesInput>
  }

  export type UserUpdateOneWithoutEstimations_aidesNestedInput = {
    create?: XOR<UserCreateWithoutEstimations_aidesInput, UserUncheckedCreateWithoutEstimations_aidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEstimations_aidesInput
    upsert?: UserUpsertWithoutEstimations_aidesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEstimations_aidesInput, UserUpdateWithoutEstimations_aidesInput>, UserUncheckedUpdateWithoutEstimations_aidesInput>
  }

  export type estimation_fiche_solutionCreateNestedOneWithoutEstimation_materiauxInput = {
    create?: XOR<estimation_fiche_solutionCreateWithoutEstimation_materiauxInput, estimation_fiche_solutionUncheckedCreateWithoutEstimation_materiauxInput>
    connectOrCreate?: estimation_fiche_solutionCreateOrConnectWithoutEstimation_materiauxInput
    connect?: estimation_fiche_solutionWhereUniqueInput
  }

  export type estimation_fiche_solutionUpdateOneRequiredWithoutEstimation_materiauxNestedInput = {
    create?: XOR<estimation_fiche_solutionCreateWithoutEstimation_materiauxInput, estimation_fiche_solutionUncheckedCreateWithoutEstimation_materiauxInput>
    connectOrCreate?: estimation_fiche_solutionCreateOrConnectWithoutEstimation_materiauxInput
    upsert?: estimation_fiche_solutionUpsertWithoutEstimation_materiauxInput
    connect?: estimation_fiche_solutionWhereUniqueInput
    update?: XOR<XOR<estimation_fiche_solutionUpdateToOneWithWhereWithoutEstimation_materiauxInput, estimation_fiche_solutionUpdateWithoutEstimation_materiauxInput>, estimation_fiche_solutionUncheckedUpdateWithoutEstimation_materiauxInput>
  }

  export type estimationCreateNestedOneWithoutEstimations_fiches_solutionsInput = {
    create?: XOR<estimationCreateWithoutEstimations_fiches_solutionsInput, estimationUncheckedCreateWithoutEstimations_fiches_solutionsInput>
    connectOrCreate?: estimationCreateOrConnectWithoutEstimations_fiches_solutionsInput
    connect?: estimationWhereUniqueInput
  }

  export type estimation_materiauxCreateNestedManyWithoutEstimation_fiche_solutionInput = {
    create?: XOR<estimation_materiauxCreateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput> | estimation_materiauxCreateWithoutEstimation_fiche_solutionInput[] | estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput[]
    connectOrCreate?: estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput | estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput[]
    createMany?: estimation_materiauxCreateManyEstimation_fiche_solutionInputEnvelope
    connect?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
  }

  export type estimation_materiauxUncheckedCreateNestedManyWithoutEstimation_fiche_solutionInput = {
    create?: XOR<estimation_materiauxCreateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput> | estimation_materiauxCreateWithoutEstimation_fiche_solutionInput[] | estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput[]
    connectOrCreate?: estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput | estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput[]
    createMany?: estimation_materiauxCreateManyEstimation_fiche_solutionInputEnvelope
    connect?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
  }

  export type estimationUpdateOneRequiredWithoutEstimations_fiches_solutionsNestedInput = {
    create?: XOR<estimationCreateWithoutEstimations_fiches_solutionsInput, estimationUncheckedCreateWithoutEstimations_fiches_solutionsInput>
    connectOrCreate?: estimationCreateOrConnectWithoutEstimations_fiches_solutionsInput
    upsert?: estimationUpsertWithoutEstimations_fiches_solutionsInput
    connect?: estimationWhereUniqueInput
    update?: XOR<XOR<estimationUpdateToOneWithWhereWithoutEstimations_fiches_solutionsInput, estimationUpdateWithoutEstimations_fiches_solutionsInput>, estimationUncheckedUpdateWithoutEstimations_fiches_solutionsInput>
  }

  export type estimation_materiauxUpdateManyWithoutEstimation_fiche_solutionNestedInput = {
    create?: XOR<estimation_materiauxCreateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput> | estimation_materiauxCreateWithoutEstimation_fiche_solutionInput[] | estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput[]
    connectOrCreate?: estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput | estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput[]
    upsert?: estimation_materiauxUpsertWithWhereUniqueWithoutEstimation_fiche_solutionInput | estimation_materiauxUpsertWithWhereUniqueWithoutEstimation_fiche_solutionInput[]
    createMany?: estimation_materiauxCreateManyEstimation_fiche_solutionInputEnvelope
    set?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    disconnect?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    delete?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    connect?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    update?: estimation_materiauxUpdateWithWhereUniqueWithoutEstimation_fiche_solutionInput | estimation_materiauxUpdateWithWhereUniqueWithoutEstimation_fiche_solutionInput[]
    updateMany?: estimation_materiauxUpdateManyWithWhereWithoutEstimation_fiche_solutionInput | estimation_materiauxUpdateManyWithWhereWithoutEstimation_fiche_solutionInput[]
    deleteMany?: estimation_materiauxScalarWhereInput | estimation_materiauxScalarWhereInput[]
  }

  export type estimation_materiauxUncheckedUpdateManyWithoutEstimation_fiche_solutionNestedInput = {
    create?: XOR<estimation_materiauxCreateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput> | estimation_materiauxCreateWithoutEstimation_fiche_solutionInput[] | estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput[]
    connectOrCreate?: estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput | estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput[]
    upsert?: estimation_materiauxUpsertWithWhereUniqueWithoutEstimation_fiche_solutionInput | estimation_materiauxUpsertWithWhereUniqueWithoutEstimation_fiche_solutionInput[]
    createMany?: estimation_materiauxCreateManyEstimation_fiche_solutionInputEnvelope
    set?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    disconnect?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    delete?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    connect?: estimation_materiauxWhereUniqueInput | estimation_materiauxWhereUniqueInput[]
    update?: estimation_materiauxUpdateWithWhereUniqueWithoutEstimation_fiche_solutionInput | estimation_materiauxUpdateWithWhereUniqueWithoutEstimation_fiche_solutionInput[]
    updateMany?: estimation_materiauxUpdateManyWithWhereWithoutEstimation_fiche_solutionInput | estimation_materiauxUpdateManyWithWhereWithoutEstimation_fiche_solutionInput[]
    deleteMany?: estimation_materiauxScalarWhereInput | estimation_materiauxScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type projetCreateNestedOneWithoutDiagnostic_simulationsInput = {
    create?: XOR<projetCreateWithoutDiagnostic_simulationsInput, projetUncheckedCreateWithoutDiagnostic_simulationsInput>
    connectOrCreate?: projetCreateOrConnectWithoutDiagnostic_simulationsInput
    connect?: projetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDiagnostic_simulationInput = {
    create?: XOR<UserCreateWithoutDiagnostic_simulationInput, UserUncheckedCreateWithoutDiagnostic_simulationInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiagnostic_simulationInput
    connect?: UserWhereUniqueInput
  }

  export type projetUpdateOneRequiredWithoutDiagnostic_simulationsNestedInput = {
    create?: XOR<projetCreateWithoutDiagnostic_simulationsInput, projetUncheckedCreateWithoutDiagnostic_simulationsInput>
    connectOrCreate?: projetCreateOrConnectWithoutDiagnostic_simulationsInput
    upsert?: projetUpsertWithoutDiagnostic_simulationsInput
    connect?: projetWhereUniqueInput
    update?: XOR<XOR<projetUpdateToOneWithWhereWithoutDiagnostic_simulationsInput, projetUpdateWithoutDiagnostic_simulationsInput>, projetUncheckedUpdateWithoutDiagnostic_simulationsInput>
  }

  export type UserUpdateOneWithoutDiagnostic_simulationNestedInput = {
    create?: XOR<UserCreateWithoutDiagnostic_simulationInput, UserUncheckedCreateWithoutDiagnostic_simulationInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiagnostic_simulationInput
    upsert?: UserUpsertWithoutDiagnostic_simulationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiagnostic_simulationInput, UserUpdateWithoutDiagnostic_simulationInput>, UserUncheckedUpdateWithoutDiagnostic_simulationInput>
  }

  export type UserCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReferenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReferenceType
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type UserUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    upsert?: UserUpsertWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsInput, UserUpdateWithoutAnalyticsInput>, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumStatutUserNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutUser | EnumStatutUserFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutUserNullableFilter<$PrismaModel> | $Enums.StatutUser | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStatutUserNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutUser | EnumStatutUserFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutUser[] | ListEnumStatutUserFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutUserNullableWithAggregatesFilter<$PrismaModel> | $Enums.StatutUser | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatutUserNullableFilter<$PrismaModel>
    _max?: NestedEnumStatutUserNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleProjetFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleProjet | EnumRoleProjetFieldRefInput<$PrismaModel>
    in?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleProjetFilter<$PrismaModel> | $Enums.RoleProjet
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumRoleProjetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleProjet | EnumRoleProjetFieldRefInput<$PrismaModel>
    in?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleProjet[] | ListEnumRoleProjetFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleProjetWithAggregatesFilter<$PrismaModel> | $Enums.RoleProjet
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleProjetFilter<$PrismaModel>
    _max?: NestedEnumRoleProjetFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumemailTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.emailType | EnumemailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumemailTypeFilter<$PrismaModel> | $Enums.emailType
  }

  export type NestedEnumemailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.emailStatus | EnumemailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumemailStatusFilter<$PrismaModel> | $Enums.emailStatus
  }

  export type NestedEnumemailTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.emailType | EnumemailTypeFieldRefInput<$PrismaModel>
    in?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailType[] | ListEnumemailTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumemailTypeWithAggregatesFilter<$PrismaModel> | $Enums.emailType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumemailTypeFilter<$PrismaModel>
    _max?: NestedEnumemailTypeFilter<$PrismaModel>
  }

  export type NestedEnumemailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.emailStatus | EnumemailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.emailStatus[] | ListEnumemailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumemailStatusWithAggregatesFilter<$PrismaModel> | $Enums.emailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumemailStatusFilter<$PrismaModel>
    _max?: NestedEnumemailStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumStatutProjetNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutProjet | EnumStatutProjetFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutProjetNullableFilter<$PrismaModel> | $Enums.StatutProjet | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatutProjetNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutProjet | EnumStatutProjetFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatutProjet[] | ListEnumStatutProjetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatutProjetNullableWithAggregatesFilter<$PrismaModel> | $Enums.StatutProjet | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatutProjetNullableFilter<$PrismaModel>
    _max?: NestedEnumStatutProjetNullableFilter<$PrismaModel>
  }

  export type NestedEnumFicheTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FicheType | EnumFicheTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFicheTypeFilter<$PrismaModel> | $Enums.FicheType
  }

  export type NestedEnumFicheTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FicheType | EnumFicheTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FicheType[] | ListEnumFicheTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFicheTypeWithAggregatesFilter<$PrismaModel> | $Enums.FicheType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFicheTypeFilter<$PrismaModel>
    _max?: NestedEnumFicheTypeFilter<$PrismaModel>
  }

  export type NestedEnumTypeLieuClimadiagFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeLieuClimadiag | EnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    in?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeLieuClimadiagFilter<$PrismaModel> | $Enums.TypeLieuClimadiag
  }

  export type NestedEnumTypeLieuClimadiagWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeLieuClimadiag | EnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    in?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeLieuClimadiag[] | ListEnumTypeLieuClimadiagFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeLieuClimadiagWithAggregatesFilter<$PrismaModel> | $Enums.TypeLieuClimadiag
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeLieuClimadiagFilter<$PrismaModel>
    _max?: NestedEnumTypeLieuClimadiagFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeFilter<$PrismaModel> | $Enums.ReferenceType
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferenceType | EnumReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferenceType[] | ListEnumReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumReferenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type collectiviteCreateWithoutCreatorInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    users?: user_collectiviteCreateNestedManyWithoutCollectiviteInput
    projet?: projetCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteUncheckedCreateWithoutCreatorInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    users?: user_collectiviteUncheckedCreateNestedManyWithoutCollectiviteInput
    projet?: projetUncheckedCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteCreateOrConnectWithoutCreatorInput = {
    where: collectiviteWhereUniqueInput
    create: XOR<collectiviteCreateWithoutCreatorInput, collectiviteUncheckedCreateWithoutCreatorInput>
  }

  export type collectiviteCreateManyCreatorInputEnvelope = {
    data: collectiviteCreateManyCreatorInput | collectiviteCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type projetCreateWithoutCreatorInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutCreatorInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutCreatorInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutCreatorInput, projetUncheckedCreateWithoutCreatorInput>
  }

  export type projetCreateManyCreatorInputEnvelope = {
    data: projetCreateManyCreatorInput | projetCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type estimationCreateWithoutCreatorInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    projet: projetCreateNestedOneWithoutEstimationsInput
    deleter?: UserCreateNestedOneWithoutEstimations_deletedInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionCreateNestedManyWithoutEstimationInput
  }

  export type estimationUncheckedCreateWithoutCreatorInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedCreateNestedManyWithoutEstimationInput
  }

  export type estimationCreateOrConnectWithoutCreatorInput = {
    where: estimationWhereUniqueInput
    create: XOR<estimationCreateWithoutCreatorInput, estimationUncheckedCreateWithoutCreatorInput>
  }

  export type estimationCreateManyCreatorInputEnvelope = {
    data: estimationCreateManyCreatorInput | estimationCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type estimationCreateWithoutDeleterInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    creator: UserCreateNestedOneWithoutEstimations_createdInput
    projet: projetCreateNestedOneWithoutEstimationsInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionCreateNestedManyWithoutEstimationInput
  }

  export type estimationUncheckedCreateWithoutDeleterInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedCreateNestedManyWithoutEstimationInput
  }

  export type estimationCreateOrConnectWithoutDeleterInput = {
    where: estimationWhereUniqueInput
    create: XOR<estimationCreateWithoutDeleterInput, estimationUncheckedCreateWithoutDeleterInput>
  }

  export type estimationCreateManyDeleterInputEnvelope = {
    data: estimationCreateManyDeleterInput | estimationCreateManyDeleterInput[]
    skipDuplicates?: boolean
  }

  export type projetCreateWithoutDeleterInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutDeleterInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutDeleterInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutDeleterInput, projetUncheckedCreateWithoutDeleterInput>
  }

  export type projetCreateManyDeleterInputEnvelope = {
    data: projetCreateManyDeleterInput | projetCreateManyDeleterInput[]
    skipDuplicates?: boolean
  }

  export type user_collectiviteCreateWithoutUserInput = {
    verified?: boolean
    created_at?: Date | string
    collectivite: collectiviteCreateNestedOneWithoutUsersInput
  }

  export type user_collectiviteUncheckedCreateWithoutUserInput = {
    collectivite_id: number
    verified?: boolean
    created_at?: Date | string
  }

  export type user_collectiviteCreateOrConnectWithoutUserInput = {
    where: user_collectiviteWhereUniqueInput
    create: XOR<user_collectiviteCreateWithoutUserInput, user_collectiviteUncheckedCreateWithoutUserInput>
  }

  export type user_collectiviteCreateManyUserInputEnvelope = {
    data: user_collectiviteCreateManyUserInput | user_collectiviteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_projetCreateWithoutUserInput = {
    email_address?: string | null
    role: $Enums.RoleProjet
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    projet: projetCreateNestedOneWithoutUsersInput
    deleter?: UserCreateNestedOneWithoutUser_projet_deletedInput
    email?: emailCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetUncheckedCreateWithoutUserInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    email?: emailUncheckedCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetCreateOrConnectWithoutUserInput = {
    where: user_projetWhereUniqueInput
    create: XOR<user_projetCreateWithoutUserInput, user_projetUncheckedCreateWithoutUserInput>
  }

  export type user_projetCreateManyUserInputEnvelope = {
    data: user_projetCreateManyUserInput | user_projetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_projetCreateWithoutDeleterInput = {
    email_address?: string | null
    role: $Enums.RoleProjet
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    projet: projetCreateNestedOneWithoutUsersInput
    user?: UserCreateNestedOneWithoutProjetsInput
    email?: emailCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetUncheckedCreateWithoutDeleterInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    email?: emailUncheckedCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetCreateOrConnectWithoutDeleterInput = {
    where: user_projetWhereUniqueInput
    create: XOR<user_projetCreateWithoutDeleterInput, user_projetUncheckedCreateWithoutDeleterInput>
  }

  export type user_projetCreateManyDeleterInputEnvelope = {
    data: user_projetCreateManyDeleterInput | user_projetCreateManyDeleterInput[]
    skipDuplicates?: boolean
  }

  export type conversationCreateWithoutUserInput = {
    id?: string
    ragtimeId: string
    created_at?: Date | string
  }

  export type conversationUncheckedCreateWithoutUserInput = {
    id?: string
    ragtimeId: string
    created_at?: Date | string
  }

  export type conversationCreateOrConnectWithoutUserInput = {
    where: conversationWhereUniqueInput
    create: XOR<conversationCreateWithoutUserInput, conversationUncheckedCreateWithoutUserInput>
  }

  export type conversationCreateManyUserInputEnvelope = {
    data: conversationCreateManyUserInput | conversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsCreateWithoutCreated_byInput = {
    id?: string
    created_at?: Date | string
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnalyticsUncheckedCreateWithoutCreated_byInput = {
    id?: string
    created_at?: Date | string
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnalyticsCreateOrConnectWithoutCreated_byInput = {
    where: AnalyticsWhereUniqueInput
    create: XOR<AnalyticsCreateWithoutCreated_byInput, AnalyticsUncheckedCreateWithoutCreated_byInput>
  }

  export type AnalyticsCreateManyCreated_byInputEnvelope = {
    data: AnalyticsCreateManyCreated_byInput | AnalyticsCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type projet_sourcing_contactCreateWithoutCreatorInput = {
    created_at?: Date | string
    projet: projetCreateNestedOneWithoutSourcing_user_projetsInput
    sourced_user_projet: user_projetCreateNestedOneWithoutSourced_by_projetsInput
  }

  export type projet_sourcing_contactUncheckedCreateWithoutCreatorInput = {
    id?: number
    projet_id: number
    sourced_user_projet_id: number
    created_at?: Date | string
  }

  export type projet_sourcing_contactCreateOrConnectWithoutCreatorInput = {
    where: projet_sourcing_contactWhereUniqueInput
    create: XOR<projet_sourcing_contactCreateWithoutCreatorInput, projet_sourcing_contactUncheckedCreateWithoutCreatorInput>
  }

  export type projet_sourcing_contactCreateManyCreatorInputEnvelope = {
    data: projet_sourcing_contactCreateManyCreatorInput | projet_sourcing_contactCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type emailCreateWithoutUserInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
    user_projet?: user_projetCreateNestedOneWithoutEmailInput
  }

  export type emailUncheckedCreateWithoutUserInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    user_projet_id?: number | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailCreateOrConnectWithoutUserInput = {
    where: emailWhereUniqueInput
    create: XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput>
  }

  export type emailCreateManyUserInputEnvelope = {
    data: emailCreateManyUserInput | emailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type estimations_aidesCreateWithoutCreated_byInput = {
    id?: number
    created_at?: Date | string | null
    estimation: estimationCreateNestedOneWithoutEstimations_aidesInput
    aide: aideCreateNestedOneWithoutEstimations_aidesInput
  }

  export type estimations_aidesUncheckedCreateWithoutCreated_byInput = {
    id?: number
    estimationId: number
    aideId: number
    created_at?: Date | string | null
  }

  export type estimations_aidesCreateOrConnectWithoutCreated_byInput = {
    where: estimations_aidesWhereUniqueInput
    create: XOR<estimations_aidesCreateWithoutCreated_byInput, estimations_aidesUncheckedCreateWithoutCreated_byInput>
  }

  export type estimations_aidesCreateManyCreated_byInputEnvelope = {
    data: estimations_aidesCreateManyCreated_byInput | estimations_aidesCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type projet_ficheCreateWithoutCreated_byInput = {
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    projet: projetCreateNestedOneWithoutFichesInput
  }

  export type projet_ficheUncheckedCreateWithoutCreated_byInput = {
    id?: number
    projet_id: number
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
  }

  export type projet_ficheCreateOrConnectWithoutCreated_byInput = {
    where: projet_ficheWhereUniqueInput
    create: XOR<projet_ficheCreateWithoutCreated_byInput, projet_ficheUncheckedCreateWithoutCreated_byInput>
  }

  export type projet_ficheCreateManyCreated_byInputEnvelope = {
    data: projet_ficheCreateManyCreated_byInput | projet_ficheCreateManyCreated_byInput[]
    skipDuplicates?: boolean
  }

  export type diagnostic_simulationCreateWithoutUserInput = {
    id?: string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    projet: projetCreateNestedOneWithoutDiagnostic_simulationsInput
  }

  export type diagnostic_simulationUncheckedCreateWithoutUserInput = {
    id?: string
    projet_id: number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type diagnostic_simulationCreateOrConnectWithoutUserInput = {
    where: diagnostic_simulationWhereUniqueInput
    create: XOR<diagnostic_simulationCreateWithoutUserInput, diagnostic_simulationUncheckedCreateWithoutUserInput>
  }

  export type diagnostic_simulationCreateManyUserInputEnvelope = {
    data: diagnostic_simulationCreateManyUserInput | diagnostic_simulationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type collectiviteUpsertWithWhereUniqueWithoutCreatorInput = {
    where: collectiviteWhereUniqueInput
    update: XOR<collectiviteUpdateWithoutCreatorInput, collectiviteUncheckedUpdateWithoutCreatorInput>
    create: XOR<collectiviteCreateWithoutCreatorInput, collectiviteUncheckedCreateWithoutCreatorInput>
  }

  export type collectiviteUpdateWithWhereUniqueWithoutCreatorInput = {
    where: collectiviteWhereUniqueInput
    data: XOR<collectiviteUpdateWithoutCreatorInput, collectiviteUncheckedUpdateWithoutCreatorInput>
  }

  export type collectiviteUpdateManyWithWhereWithoutCreatorInput = {
    where: collectiviteScalarWhereInput
    data: XOR<collectiviteUpdateManyMutationInput, collectiviteUncheckedUpdateManyWithoutCreatorInput>
  }

  export type collectiviteScalarWhereInput = {
    AND?: collectiviteScalarWhereInput | collectiviteScalarWhereInput[]
    OR?: collectiviteScalarWhereInput[]
    NOT?: collectiviteScalarWhereInput | collectiviteScalarWhereInput[]
    id?: IntFilter<"collectivite"> | number
    nom?: StringFilter<"collectivite"> | string
    code_insee?: StringNullableFilter<"collectivite"> | string | null
    code_postal?: StringNullableFilter<"collectivite"> | string | null
    adresse_info?: JsonNullableFilter<"collectivite">
    adresse_all_infos?: JsonNullableFilter<"collectivite">
    ban_id?: StringNullableFilter<"collectivite"> | string | null
    latitude?: FloatNullableFilter<"collectivite"> | number | null
    longitude?: FloatNullableFilter<"collectivite"> | number | null
    created_by?: StringFilter<"collectivite"> | string
    created_at?: DateTimeFilter<"collectivite"> | Date | string
    aides_territoires_perimeter_id?: StringNullableFilter<"collectivite"> | string | null
  }

  export type projetUpsertWithWhereUniqueWithoutCreatorInput = {
    where: projetWhereUniqueInput
    update: XOR<projetUpdateWithoutCreatorInput, projetUncheckedUpdateWithoutCreatorInput>
    create: XOR<projetCreateWithoutCreatorInput, projetUncheckedCreateWithoutCreatorInput>
  }

  export type projetUpdateWithWhereUniqueWithoutCreatorInput = {
    where: projetWhereUniqueInput
    data: XOR<projetUpdateWithoutCreatorInput, projetUncheckedUpdateWithoutCreatorInput>
  }

  export type projetUpdateManyWithWhereWithoutCreatorInput = {
    where: projetScalarWhereInput
    data: XOR<projetUpdateManyMutationInput, projetUncheckedUpdateManyWithoutCreatorInput>
  }

  export type projetScalarWhereInput = {
    AND?: projetScalarWhereInput | projetScalarWhereInput[]
    OR?: projetScalarWhereInput[]
    NOT?: projetScalarWhereInput | projetScalarWhereInput[]
    id?: IntFilter<"projet"> | number
    created_by?: StringFilter<"projet"> | string
    created_at?: DateTimeFilter<"projet"> | Date | string
    updated_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    nom?: StringFilter<"projet"> | string
    type_espace?: StringNullableFilter<"projet"> | string | null
    adresse?: StringNullableFilter<"projet"> | string | null
    niveau_maturite?: StringNullableFilter<"projet"> | string | null
    adresse_info?: JsonNullableFilter<"projet">
    adresse_all_infos?: JsonNullableFilter<"projet">
    date_echeance?: DateTimeNullableFilter<"projet"> | Date | string | null
    fiches_solutions_id?: IntNullableListFilter<"projet">
    fiches_diagnostic_id?: IntNullableListFilter<"projet">
    collectiviteId?: IntFilter<"projet"> | number
    recommandations_viewed_by?: StringNullableListFilter<"projet">
    deleted_at?: DateTimeNullableFilter<"projet"> | Date | string | null
    deleted_by?: StringNullableFilter<"projet"> | string | null
    is_public?: BoolNullableFilter<"projet"> | boolean | null
    budget?: IntNullableFilter<"projet"> | number | null
    sourcing_rex?: JsonNullableFilter<"projet">
    statut?: EnumStatutProjetNullableFilter<"projet"> | $Enums.StatutProjet | null
    statut_updated_at?: DateTimeNullableFilter<"projet"> | Date | string | null
  }

  export type estimationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: estimationWhereUniqueInput
    update: XOR<estimationUpdateWithoutCreatorInput, estimationUncheckedUpdateWithoutCreatorInput>
    create: XOR<estimationCreateWithoutCreatorInput, estimationUncheckedCreateWithoutCreatorInput>
  }

  export type estimationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: estimationWhereUniqueInput
    data: XOR<estimationUpdateWithoutCreatorInput, estimationUncheckedUpdateWithoutCreatorInput>
  }

  export type estimationUpdateManyWithWhereWithoutCreatorInput = {
    where: estimationScalarWhereInput
    data: XOR<estimationUpdateManyMutationInput, estimationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type estimationScalarWhereInput = {
    AND?: estimationScalarWhereInput | estimationScalarWhereInput[]
    OR?: estimationScalarWhereInput[]
    NOT?: estimationScalarWhereInput | estimationScalarWhereInput[]
    id?: IntFilter<"estimation"> | number
    created_by?: StringFilter<"estimation"> | string
    created_at?: DateTimeFilter<"estimation"> | Date | string
    updated_at?: DateTimeFilter<"estimation"> | Date | string
    projet_id?: IntFilter<"estimation"> | number
    fiches_solutions_id?: IntNullableListFilter<"estimation">
    materiaux?: JsonNullableFilter<"estimation">
    deleted_at?: DateTimeNullableFilter<"estimation"> | Date | string | null
    deleted_by?: StringNullableFilter<"estimation"> | string | null
  }

  export type estimationUpsertWithWhereUniqueWithoutDeleterInput = {
    where: estimationWhereUniqueInput
    update: XOR<estimationUpdateWithoutDeleterInput, estimationUncheckedUpdateWithoutDeleterInput>
    create: XOR<estimationCreateWithoutDeleterInput, estimationUncheckedCreateWithoutDeleterInput>
  }

  export type estimationUpdateWithWhereUniqueWithoutDeleterInput = {
    where: estimationWhereUniqueInput
    data: XOR<estimationUpdateWithoutDeleterInput, estimationUncheckedUpdateWithoutDeleterInput>
  }

  export type estimationUpdateManyWithWhereWithoutDeleterInput = {
    where: estimationScalarWhereInput
    data: XOR<estimationUpdateManyMutationInput, estimationUncheckedUpdateManyWithoutDeleterInput>
  }

  export type projetUpsertWithWhereUniqueWithoutDeleterInput = {
    where: projetWhereUniqueInput
    update: XOR<projetUpdateWithoutDeleterInput, projetUncheckedUpdateWithoutDeleterInput>
    create: XOR<projetCreateWithoutDeleterInput, projetUncheckedCreateWithoutDeleterInput>
  }

  export type projetUpdateWithWhereUniqueWithoutDeleterInput = {
    where: projetWhereUniqueInput
    data: XOR<projetUpdateWithoutDeleterInput, projetUncheckedUpdateWithoutDeleterInput>
  }

  export type projetUpdateManyWithWhereWithoutDeleterInput = {
    where: projetScalarWhereInput
    data: XOR<projetUpdateManyMutationInput, projetUncheckedUpdateManyWithoutDeleterInput>
  }

  export type user_collectiviteUpsertWithWhereUniqueWithoutUserInput = {
    where: user_collectiviteWhereUniqueInput
    update: XOR<user_collectiviteUpdateWithoutUserInput, user_collectiviteUncheckedUpdateWithoutUserInput>
    create: XOR<user_collectiviteCreateWithoutUserInput, user_collectiviteUncheckedCreateWithoutUserInput>
  }

  export type user_collectiviteUpdateWithWhereUniqueWithoutUserInput = {
    where: user_collectiviteWhereUniqueInput
    data: XOR<user_collectiviteUpdateWithoutUserInput, user_collectiviteUncheckedUpdateWithoutUserInput>
  }

  export type user_collectiviteUpdateManyWithWhereWithoutUserInput = {
    where: user_collectiviteScalarWhereInput
    data: XOR<user_collectiviteUpdateManyMutationInput, user_collectiviteUncheckedUpdateManyWithoutUserInput>
  }

  export type user_collectiviteScalarWhereInput = {
    AND?: user_collectiviteScalarWhereInput | user_collectiviteScalarWhereInput[]
    OR?: user_collectiviteScalarWhereInput[]
    NOT?: user_collectiviteScalarWhereInput | user_collectiviteScalarWhereInput[]
    user_id?: StringFilter<"user_collectivite"> | string
    collectivite_id?: IntFilter<"user_collectivite"> | number
    verified?: BoolFilter<"user_collectivite"> | boolean
    created_at?: DateTimeFilter<"user_collectivite"> | Date | string
  }

  export type user_projetUpsertWithWhereUniqueWithoutUserInput = {
    where: user_projetWhereUniqueInput
    update: XOR<user_projetUpdateWithoutUserInput, user_projetUncheckedUpdateWithoutUserInput>
    create: XOR<user_projetCreateWithoutUserInput, user_projetUncheckedCreateWithoutUserInput>
  }

  export type user_projetUpdateWithWhereUniqueWithoutUserInput = {
    where: user_projetWhereUniqueInput
    data: XOR<user_projetUpdateWithoutUserInput, user_projetUncheckedUpdateWithoutUserInput>
  }

  export type user_projetUpdateManyWithWhereWithoutUserInput = {
    where: user_projetScalarWhereInput
    data: XOR<user_projetUpdateManyMutationInput, user_projetUncheckedUpdateManyWithoutUserInput>
  }

  export type user_projetScalarWhereInput = {
    AND?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
    OR?: user_projetScalarWhereInput[]
    NOT?: user_projetScalarWhereInput | user_projetScalarWhereInput[]
    id?: IntFilter<"user_projet"> | number
    email_address?: StringNullableFilter<"user_projet"> | string | null
    role?: EnumRoleProjetFilter<"user_projet"> | $Enums.RoleProjet
    projet_id?: IntFilter<"user_projet"> | number
    user_id?: StringNullableFilter<"user_projet"> | string | null
    created_at?: DateTimeFilter<"user_projet"> | Date | string
    invitation_token?: StringNullableFilter<"user_projet"> | string | null
    invitation_status?: EnumInvitationStatusFilter<"user_projet"> | $Enums.InvitationStatus
    deleted_at?: DateTimeNullableFilter<"user_projet"> | Date | string | null
    deleted_by?: StringNullableFilter<"user_projet"> | string | null
    nb_views?: IntNullableFilter<"user_projet"> | number | null
    last_viewed_at?: DateTimeNullableFilter<"user_projet"> | Date | string | null
  }

  export type user_projetUpsertWithWhereUniqueWithoutDeleterInput = {
    where: user_projetWhereUniqueInput
    update: XOR<user_projetUpdateWithoutDeleterInput, user_projetUncheckedUpdateWithoutDeleterInput>
    create: XOR<user_projetCreateWithoutDeleterInput, user_projetUncheckedCreateWithoutDeleterInput>
  }

  export type user_projetUpdateWithWhereUniqueWithoutDeleterInput = {
    where: user_projetWhereUniqueInput
    data: XOR<user_projetUpdateWithoutDeleterInput, user_projetUncheckedUpdateWithoutDeleterInput>
  }

  export type user_projetUpdateManyWithWhereWithoutDeleterInput = {
    where: user_projetScalarWhereInput
    data: XOR<user_projetUpdateManyMutationInput, user_projetUncheckedUpdateManyWithoutDeleterInput>
  }

  export type conversationUpsertWithWhereUniqueWithoutUserInput = {
    where: conversationWhereUniqueInput
    update: XOR<conversationUpdateWithoutUserInput, conversationUncheckedUpdateWithoutUserInput>
    create: XOR<conversationCreateWithoutUserInput, conversationUncheckedCreateWithoutUserInput>
  }

  export type conversationUpdateWithWhereUniqueWithoutUserInput = {
    where: conversationWhereUniqueInput
    data: XOR<conversationUpdateWithoutUserInput, conversationUncheckedUpdateWithoutUserInput>
  }

  export type conversationUpdateManyWithWhereWithoutUserInput = {
    where: conversationScalarWhereInput
    data: XOR<conversationUpdateManyMutationInput, conversationUncheckedUpdateManyWithoutUserInput>
  }

  export type conversationScalarWhereInput = {
    AND?: conversationScalarWhereInput | conversationScalarWhereInput[]
    OR?: conversationScalarWhereInput[]
    NOT?: conversationScalarWhereInput | conversationScalarWhereInput[]
    id?: StringFilter<"conversation"> | string
    userId?: StringNullableFilter<"conversation"> | string | null
    ragtimeId?: StringFilter<"conversation"> | string
    created_at?: DateTimeFilter<"conversation"> | Date | string
  }

  export type AnalyticsUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: AnalyticsWhereUniqueInput
    update: XOR<AnalyticsUpdateWithoutCreated_byInput, AnalyticsUncheckedUpdateWithoutCreated_byInput>
    create: XOR<AnalyticsCreateWithoutCreated_byInput, AnalyticsUncheckedCreateWithoutCreated_byInput>
  }

  export type AnalyticsUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: AnalyticsWhereUniqueInput
    data: XOR<AnalyticsUpdateWithoutCreated_byInput, AnalyticsUncheckedUpdateWithoutCreated_byInput>
  }

  export type AnalyticsUpdateManyWithWhereWithoutCreated_byInput = {
    where: AnalyticsScalarWhereInput
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type AnalyticsScalarWhereInput = {
    AND?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
    OR?: AnalyticsScalarWhereInput[]
    NOT?: AnalyticsScalarWhereInput | AnalyticsScalarWhereInput[]
    id?: StringFilter<"Analytics"> | string
    created_at?: DateTimeFilter<"Analytics"> | Date | string
    reference_id?: StringFilter<"Analytics"> | string
    reference_type?: EnumReferenceTypeFilter<"Analytics"> | $Enums.ReferenceType
    event_type?: EnumEventTypeFilter<"Analytics"> | $Enums.EventType
    context?: JsonNullableFilter<"Analytics">
    user_id?: StringFilter<"Analytics"> | string
  }

  export type projet_sourcing_contactUpsertWithWhereUniqueWithoutCreatorInput = {
    where: projet_sourcing_contactWhereUniqueInput
    update: XOR<projet_sourcing_contactUpdateWithoutCreatorInput, projet_sourcing_contactUncheckedUpdateWithoutCreatorInput>
    create: XOR<projet_sourcing_contactCreateWithoutCreatorInput, projet_sourcing_contactUncheckedCreateWithoutCreatorInput>
  }

  export type projet_sourcing_contactUpdateWithWhereUniqueWithoutCreatorInput = {
    where: projet_sourcing_contactWhereUniqueInput
    data: XOR<projet_sourcing_contactUpdateWithoutCreatorInput, projet_sourcing_contactUncheckedUpdateWithoutCreatorInput>
  }

  export type projet_sourcing_contactUpdateManyWithWhereWithoutCreatorInput = {
    where: projet_sourcing_contactScalarWhereInput
    data: XOR<projet_sourcing_contactUpdateManyMutationInput, projet_sourcing_contactUncheckedUpdateManyWithoutCreatorInput>
  }

  export type projet_sourcing_contactScalarWhereInput = {
    AND?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
    OR?: projet_sourcing_contactScalarWhereInput[]
    NOT?: projet_sourcing_contactScalarWhereInput | projet_sourcing_contactScalarWhereInput[]
    id?: IntFilter<"projet_sourcing_contact"> | number
    projet_id?: IntFilter<"projet_sourcing_contact"> | number
    sourced_user_projet_id?: IntFilter<"projet_sourcing_contact"> | number
    created_at?: DateTimeFilter<"projet_sourcing_contact"> | Date | string
    created_by?: StringFilter<"projet_sourcing_contact"> | string
  }

  export type emailUpsertWithWhereUniqueWithoutUserInput = {
    where: emailWhereUniqueInput
    update: XOR<emailUpdateWithoutUserInput, emailUncheckedUpdateWithoutUserInput>
    create: XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput>
  }

  export type emailUpdateWithWhereUniqueWithoutUserInput = {
    where: emailWhereUniqueInput
    data: XOR<emailUpdateWithoutUserInput, emailUncheckedUpdateWithoutUserInput>
  }

  export type emailUpdateManyWithWhereWithoutUserInput = {
    where: emailScalarWhereInput
    data: XOR<emailUpdateManyMutationInput, emailUncheckedUpdateManyWithoutUserInput>
  }

  export type emailScalarWhereInput = {
    AND?: emailScalarWhereInput | emailScalarWhereInput[]
    OR?: emailScalarWhereInput[]
    NOT?: emailScalarWhereInput | emailScalarWhereInput[]
    id?: StringFilter<"email"> | string
    destination_address?: StringFilter<"email"> | string
    type?: EnumemailTypeFilter<"email"> | $Enums.emailType
    sending_time?: DateTimeFilter<"email"> | Date | string
    brevo_id?: StringNullableFilter<"email"> | string | null
    email_status?: EnumemailStatusFilter<"email"> | $Enums.emailStatus
    user_projet_id?: IntNullableFilter<"email"> | number | null
    user_id?: StringNullableFilter<"email"> | string | null
    extra?: JsonNullableFilter<"email">
  }

  export type estimations_aidesUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: estimations_aidesWhereUniqueInput
    update: XOR<estimations_aidesUpdateWithoutCreated_byInput, estimations_aidesUncheckedUpdateWithoutCreated_byInput>
    create: XOR<estimations_aidesCreateWithoutCreated_byInput, estimations_aidesUncheckedCreateWithoutCreated_byInput>
  }

  export type estimations_aidesUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: estimations_aidesWhereUniqueInput
    data: XOR<estimations_aidesUpdateWithoutCreated_byInput, estimations_aidesUncheckedUpdateWithoutCreated_byInput>
  }

  export type estimations_aidesUpdateManyWithWhereWithoutCreated_byInput = {
    where: estimations_aidesScalarWhereInput
    data: XOR<estimations_aidesUpdateManyMutationInput, estimations_aidesUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type estimations_aidesScalarWhereInput = {
    AND?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
    OR?: estimations_aidesScalarWhereInput[]
    NOT?: estimations_aidesScalarWhereInput | estimations_aidesScalarWhereInput[]
    id?: IntFilter<"estimations_aides"> | number
    estimationId?: IntFilter<"estimations_aides"> | number
    aideId?: IntFilter<"estimations_aides"> | number
    created_at?: DateTimeNullableFilter<"estimations_aides"> | Date | string | null
    user_id?: StringNullableFilter<"estimations_aides"> | string | null
  }

  export type projet_ficheUpsertWithWhereUniqueWithoutCreated_byInput = {
    where: projet_ficheWhereUniqueInput
    update: XOR<projet_ficheUpdateWithoutCreated_byInput, projet_ficheUncheckedUpdateWithoutCreated_byInput>
    create: XOR<projet_ficheCreateWithoutCreated_byInput, projet_ficheUncheckedCreateWithoutCreated_byInput>
  }

  export type projet_ficheUpdateWithWhereUniqueWithoutCreated_byInput = {
    where: projet_ficheWhereUniqueInput
    data: XOR<projet_ficheUpdateWithoutCreated_byInput, projet_ficheUncheckedUpdateWithoutCreated_byInput>
  }

  export type projet_ficheUpdateManyWithWhereWithoutCreated_byInput = {
    where: projet_ficheScalarWhereInput
    data: XOR<projet_ficheUpdateManyMutationInput, projet_ficheUncheckedUpdateManyWithoutCreated_byInput>
  }

  export type projet_ficheScalarWhereInput = {
    AND?: projet_ficheScalarWhereInput | projet_ficheScalarWhereInput[]
    OR?: projet_ficheScalarWhereInput[]
    NOT?: projet_ficheScalarWhereInput | projet_ficheScalarWhereInput[]
    id?: IntFilter<"projet_fiche"> | number
    projet_id?: IntFilter<"projet_fiche"> | number
    fiche_id?: IntFilter<"projet_fiche"> | number
    type?: EnumFicheTypeFilter<"projet_fiche"> | $Enums.FicheType
    created_at?: DateTimeFilter<"projet_fiche"> | Date | string
    user_id?: StringFilter<"projet_fiche"> | string
  }

  export type diagnostic_simulationUpsertWithWhereUniqueWithoutUserInput = {
    where: diagnostic_simulationWhereUniqueInput
    update: XOR<diagnostic_simulationUpdateWithoutUserInput, diagnostic_simulationUncheckedUpdateWithoutUserInput>
    create: XOR<diagnostic_simulationCreateWithoutUserInput, diagnostic_simulationUncheckedCreateWithoutUserInput>
  }

  export type diagnostic_simulationUpdateWithWhereUniqueWithoutUserInput = {
    where: diagnostic_simulationWhereUniqueInput
    data: XOR<diagnostic_simulationUpdateWithoutUserInput, diagnostic_simulationUncheckedUpdateWithoutUserInput>
  }

  export type diagnostic_simulationUpdateManyWithWhereWithoutUserInput = {
    where: diagnostic_simulationScalarWhereInput
    data: XOR<diagnostic_simulationUpdateManyMutationInput, diagnostic_simulationUncheckedUpdateManyWithoutUserInput>
  }

  export type diagnostic_simulationScalarWhereInput = {
    AND?: diagnostic_simulationScalarWhereInput | diagnostic_simulationScalarWhereInput[]
    OR?: diagnostic_simulationScalarWhereInput[]
    NOT?: diagnostic_simulationScalarWhereInput | diagnostic_simulationScalarWhereInput[]
    id?: StringFilter<"diagnostic_simulation"> | string
    user_id?: StringNullableFilter<"diagnostic_simulation"> | string | null
    projet_id?: IntFilter<"diagnostic_simulation"> | number
    initial_values?: JsonNullableFilter<"diagnostic_simulation">
    validated?: BoolFilter<"diagnostic_simulation"> | boolean
    created_at?: DateTimeFilter<"diagnostic_simulation"> | Date | string
    updated_at?: DateTimeFilter<"diagnostic_simulation"> | Date | string
  }

  export type user_collectiviteCreateWithoutCollectiviteInput = {
    verified?: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutCollectivitesInput
  }

  export type user_collectiviteUncheckedCreateWithoutCollectiviteInput = {
    user_id: string
    verified?: boolean
    created_at?: Date | string
  }

  export type user_collectiviteCreateOrConnectWithoutCollectiviteInput = {
    where: user_collectiviteWhereUniqueInput
    create: XOR<user_collectiviteCreateWithoutCollectiviteInput, user_collectiviteUncheckedCreateWithoutCollectiviteInput>
  }

  export type user_collectiviteCreateManyCollectiviteInputEnvelope = {
    data: user_collectiviteCreateManyCollectiviteInput | user_collectiviteCreateManyCollectiviteInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCollectivites_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCollectivites_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCollectivites_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCollectivites_createdInput, UserUncheckedCreateWithoutCollectivites_createdInput>
  }

  export type projetCreateWithoutCollectiviteInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutCollectiviteInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutCollectiviteInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutCollectiviteInput, projetUncheckedCreateWithoutCollectiviteInput>
  }

  export type projetCreateManyCollectiviteInputEnvelope = {
    data: projetCreateManyCollectiviteInput | projetCreateManyCollectiviteInput[]
    skipDuplicates?: boolean
  }

  export type user_collectiviteUpsertWithWhereUniqueWithoutCollectiviteInput = {
    where: user_collectiviteWhereUniqueInput
    update: XOR<user_collectiviteUpdateWithoutCollectiviteInput, user_collectiviteUncheckedUpdateWithoutCollectiviteInput>
    create: XOR<user_collectiviteCreateWithoutCollectiviteInput, user_collectiviteUncheckedCreateWithoutCollectiviteInput>
  }

  export type user_collectiviteUpdateWithWhereUniqueWithoutCollectiviteInput = {
    where: user_collectiviteWhereUniqueInput
    data: XOR<user_collectiviteUpdateWithoutCollectiviteInput, user_collectiviteUncheckedUpdateWithoutCollectiviteInput>
  }

  export type user_collectiviteUpdateManyWithWhereWithoutCollectiviteInput = {
    where: user_collectiviteScalarWhereInput
    data: XOR<user_collectiviteUpdateManyMutationInput, user_collectiviteUncheckedUpdateManyWithoutCollectiviteInput>
  }

  export type UserUpsertWithoutCollectivites_createdInput = {
    update: XOR<UserUpdateWithoutCollectivites_createdInput, UserUncheckedUpdateWithoutCollectivites_createdInput>
    create: XOR<UserCreateWithoutCollectivites_createdInput, UserUncheckedCreateWithoutCollectivites_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCollectivites_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCollectivites_createdInput, UserUncheckedUpdateWithoutCollectivites_createdInput>
  }

  export type UserUpdateWithoutCollectivites_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCollectivites_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type projetUpsertWithWhereUniqueWithoutCollectiviteInput = {
    where: projetWhereUniqueInput
    update: XOR<projetUpdateWithoutCollectiviteInput, projetUncheckedUpdateWithoutCollectiviteInput>
    create: XOR<projetCreateWithoutCollectiviteInput, projetUncheckedCreateWithoutCollectiviteInput>
  }

  export type projetUpdateWithWhereUniqueWithoutCollectiviteInput = {
    where: projetWhereUniqueInput
    data: XOR<projetUpdateWithoutCollectiviteInput, projetUncheckedUpdateWithoutCollectiviteInput>
  }

  export type projetUpdateManyWithWhereWithoutCollectiviteInput = {
    where: projetScalarWhereInput
    data: XOR<projetUpdateManyMutationInput, projetUncheckedUpdateManyWithoutCollectiviteInput>
  }

  export type projetCreateWithoutUsersInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutUsersInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutUsersInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutUsersInput, projetUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutProjetsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjetsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjetsInput, UserUncheckedCreateWithoutProjetsInput>
  }

  export type UserCreateWithoutUser_projet_deletedInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_projet_deletedInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_projet_deletedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_projet_deletedInput, UserUncheckedCreateWithoutUser_projet_deletedInput>
  }

  export type emailCreateWithoutUser_projetInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutEmailsInput
  }

  export type emailUncheckedCreateWithoutUser_projetInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    user_id?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailCreateOrConnectWithoutUser_projetInput = {
    where: emailWhereUniqueInput
    create: XOR<emailCreateWithoutUser_projetInput, emailUncheckedCreateWithoutUser_projetInput>
  }

  export type emailCreateManyUser_projetInputEnvelope = {
    data: emailCreateManyUser_projetInput | emailCreateManyUser_projetInput[]
    skipDuplicates?: boolean
  }

  export type projet_sourcing_contactCreateWithoutSourced_user_projetInput = {
    created_at?: Date | string
    projet: projetCreateNestedOneWithoutSourcing_user_projetsInput
    creator: UserCreateNestedOneWithoutSourcing_contacts_createdInput
  }

  export type projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput = {
    id?: number
    projet_id: number
    created_at?: Date | string
    created_by: string
  }

  export type projet_sourcing_contactCreateOrConnectWithoutSourced_user_projetInput = {
    where: projet_sourcing_contactWhereUniqueInput
    create: XOR<projet_sourcing_contactCreateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput>
  }

  export type projet_sourcing_contactCreateManySourced_user_projetInputEnvelope = {
    data: projet_sourcing_contactCreateManySourced_user_projetInput | projet_sourcing_contactCreateManySourced_user_projetInput[]
    skipDuplicates?: boolean
  }

  export type projetUpsertWithoutUsersInput = {
    update: XOR<projetUpdateWithoutUsersInput, projetUncheckedUpdateWithoutUsersInput>
    create: XOR<projetCreateWithoutUsersInput, projetUncheckedCreateWithoutUsersInput>
    where?: projetWhereInput
  }

  export type projetUpdateToOneWithWhereWithoutUsersInput = {
    where?: projetWhereInput
    data: XOR<projetUpdateWithoutUsersInput, projetUncheckedUpdateWithoutUsersInput>
  }

  export type projetUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type UserUpsertWithoutProjetsInput = {
    update: XOR<UserUpdateWithoutProjetsInput, UserUncheckedUpdateWithoutProjetsInput>
    create: XOR<UserCreateWithoutProjetsInput, UserUncheckedCreateWithoutProjetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjetsInput, UserUncheckedUpdateWithoutProjetsInput>
  }

  export type UserUpdateWithoutProjetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUser_projet_deletedInput = {
    update: XOR<UserUpdateWithoutUser_projet_deletedInput, UserUncheckedUpdateWithoutUser_projet_deletedInput>
    create: XOR<UserCreateWithoutUser_projet_deletedInput, UserUncheckedCreateWithoutUser_projet_deletedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_projet_deletedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_projet_deletedInput, UserUncheckedUpdateWithoutUser_projet_deletedInput>
  }

  export type UserUpdateWithoutUser_projet_deletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_projet_deletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type emailUpsertWithWhereUniqueWithoutUser_projetInput = {
    where: emailWhereUniqueInput
    update: XOR<emailUpdateWithoutUser_projetInput, emailUncheckedUpdateWithoutUser_projetInput>
    create: XOR<emailCreateWithoutUser_projetInput, emailUncheckedCreateWithoutUser_projetInput>
  }

  export type emailUpdateWithWhereUniqueWithoutUser_projetInput = {
    where: emailWhereUniqueInput
    data: XOR<emailUpdateWithoutUser_projetInput, emailUncheckedUpdateWithoutUser_projetInput>
  }

  export type emailUpdateManyWithWhereWithoutUser_projetInput = {
    where: emailScalarWhereInput
    data: XOR<emailUpdateManyMutationInput, emailUncheckedUpdateManyWithoutUser_projetInput>
  }

  export type projet_sourcing_contactUpsertWithWhereUniqueWithoutSourced_user_projetInput = {
    where: projet_sourcing_contactWhereUniqueInput
    update: XOR<projet_sourcing_contactUpdateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedUpdateWithoutSourced_user_projetInput>
    create: XOR<projet_sourcing_contactCreateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedCreateWithoutSourced_user_projetInput>
  }

  export type projet_sourcing_contactUpdateWithWhereUniqueWithoutSourced_user_projetInput = {
    where: projet_sourcing_contactWhereUniqueInput
    data: XOR<projet_sourcing_contactUpdateWithoutSourced_user_projetInput, projet_sourcing_contactUncheckedUpdateWithoutSourced_user_projetInput>
  }

  export type projet_sourcing_contactUpdateManyWithWhereWithoutSourced_user_projetInput = {
    where: projet_sourcing_contactScalarWhereInput
    data: XOR<projet_sourcing_contactUpdateManyMutationInput, projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetInput>
  }

  export type user_projetCreateWithoutEmailInput = {
    email_address?: string | null
    role: $Enums.RoleProjet
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    projet: projetCreateNestedOneWithoutUsersInput
    user?: UserCreateNestedOneWithoutProjetsInput
    deleter?: UserCreateNestedOneWithoutUser_projet_deletedInput
    sourced_by_projets?: projet_sourcing_contactCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetUncheckedCreateWithoutEmailInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    sourced_by_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetCreateOrConnectWithoutEmailInput = {
    where: user_projetWhereUniqueInput
    create: XOR<user_projetCreateWithoutEmailInput, user_projetUncheckedCreateWithoutEmailInput>
  }

  export type UserCreateWithoutEmailsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
  }

  export type user_projetUpsertWithoutEmailInput = {
    update: XOR<user_projetUpdateWithoutEmailInput, user_projetUncheckedUpdateWithoutEmailInput>
    create: XOR<user_projetCreateWithoutEmailInput, user_projetUncheckedCreateWithoutEmailInput>
    where?: user_projetWhereInput
  }

  export type user_projetUpdateToOneWithWhereWithoutEmailInput = {
    where?: user_projetWhereInput
    data: XOR<user_projetUpdateWithoutEmailInput, user_projetUncheckedUpdateWithoutEmailInput>
  }

  export type user_projetUpdateWithoutEmailInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet?: projetUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneWithoutProjetsNestedInput
    deleter?: UserUpdateOneWithoutUser_projet_deletedNestedInput
    sourced_by_projets?: projet_sourcing_contactUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateWithoutEmailInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourced_by_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type UserUpsertWithoutEmailsInput = {
    update: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCollectivitesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCollectivitesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCollectivitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCollectivitesInput, UserUncheckedCreateWithoutCollectivitesInput>
  }

  export type collectiviteCreateWithoutUsersInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    creator: UserCreateNestedOneWithoutCollectivites_createdInput
    projet?: projetCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteUncheckedCreateWithoutUsersInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_by: string
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    projet?: projetUncheckedCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteCreateOrConnectWithoutUsersInput = {
    where: collectiviteWhereUniqueInput
    create: XOR<collectiviteCreateWithoutUsersInput, collectiviteUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutCollectivitesInput = {
    update: XOR<UserUpdateWithoutCollectivitesInput, UserUncheckedUpdateWithoutCollectivitesInput>
    create: XOR<UserCreateWithoutCollectivitesInput, UserUncheckedCreateWithoutCollectivitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCollectivitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCollectivitesInput, UserUncheckedUpdateWithoutCollectivitesInput>
  }

  export type UserUpdateWithoutCollectivitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCollectivitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type collectiviteUpsertWithoutUsersInput = {
    update: XOR<collectiviteUpdateWithoutUsersInput, collectiviteUncheckedUpdateWithoutUsersInput>
    create: XOR<collectiviteCreateWithoutUsersInput, collectiviteUncheckedCreateWithoutUsersInput>
    where?: collectiviteWhereInput
  }

  export type collectiviteUpdateToOneWithWhereWithoutUsersInput = {
    where?: collectiviteWhereInput
    data: XOR<collectiviteUpdateWithoutUsersInput, collectiviteUncheckedUpdateWithoutUsersInput>
  }

  export type collectiviteUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCollectivites_createdNestedInput
    projet?: projetUpdateManyWithoutCollectiviteNestedInput
  }

  export type collectiviteUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    projet?: projetUncheckedUpdateManyWithoutCollectiviteNestedInput
  }

  export type UserCreateWithoutProjets_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjets_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjets_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjets_createdInput, UserUncheckedCreateWithoutProjets_createdInput>
  }

  export type estimationCreateWithoutProjetInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    creator: UserCreateNestedOneWithoutEstimations_createdInput
    deleter?: UserCreateNestedOneWithoutEstimations_deletedInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionCreateNestedManyWithoutEstimationInput
  }

  export type estimationUncheckedCreateWithoutProjetInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutEstimationInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedCreateNestedManyWithoutEstimationInput
  }

  export type estimationCreateOrConnectWithoutProjetInput = {
    where: estimationWhereUniqueInput
    create: XOR<estimationCreateWithoutProjetInput, estimationUncheckedCreateWithoutProjetInput>
  }

  export type estimationCreateManyProjetInputEnvelope = {
    data: estimationCreateManyProjetInput | estimationCreateManyProjetInput[]
    skipDuplicates?: boolean
  }

  export type collectiviteCreateWithoutProjetInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    users?: user_collectiviteCreateNestedManyWithoutCollectiviteInput
    creator: UserCreateNestedOneWithoutCollectivites_createdInput
  }

  export type collectiviteUncheckedCreateWithoutProjetInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_by: string
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
    users?: user_collectiviteUncheckedCreateNestedManyWithoutCollectiviteInput
  }

  export type collectiviteCreateOrConnectWithoutProjetInput = {
    where: collectiviteWhereUniqueInput
    create: XOR<collectiviteCreateWithoutProjetInput, collectiviteUncheckedCreateWithoutProjetInput>
  }

  export type UserCreateWithoutProjets_deletedInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjets_deletedInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjets_deletedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjets_deletedInput, UserUncheckedCreateWithoutProjets_deletedInput>
  }

  export type user_projetCreateWithoutProjetInput = {
    email_address?: string | null
    role: $Enums.RoleProjet
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    user?: UserCreateNestedOneWithoutProjetsInput
    deleter?: UserCreateNestedOneWithoutUser_projet_deletedInput
    email?: emailCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetUncheckedCreateWithoutProjetInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    email?: emailUncheckedCreateNestedManyWithoutUser_projetInput
    sourced_by_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutSourced_user_projetInput
  }

  export type user_projetCreateOrConnectWithoutProjetInput = {
    where: user_projetWhereUniqueInput
    create: XOR<user_projetCreateWithoutProjetInput, user_projetUncheckedCreateWithoutProjetInput>
  }

  export type user_projetCreateManyProjetInputEnvelope = {
    data: user_projetCreateManyProjetInput | user_projetCreateManyProjetInput[]
    skipDuplicates?: boolean
  }

  export type projet_sourcing_contactCreateWithoutProjetInput = {
    created_at?: Date | string
    sourced_user_projet: user_projetCreateNestedOneWithoutSourced_by_projetsInput
    creator: UserCreateNestedOneWithoutSourcing_contacts_createdInput
  }

  export type projet_sourcing_contactUncheckedCreateWithoutProjetInput = {
    id?: number
    sourced_user_projet_id: number
    created_at?: Date | string
    created_by: string
  }

  export type projet_sourcing_contactCreateOrConnectWithoutProjetInput = {
    where: projet_sourcing_contactWhereUniqueInput
    create: XOR<projet_sourcing_contactCreateWithoutProjetInput, projet_sourcing_contactUncheckedCreateWithoutProjetInput>
  }

  export type projet_sourcing_contactCreateManyProjetInputEnvelope = {
    data: projet_sourcing_contactCreateManyProjetInput | projet_sourcing_contactCreateManyProjetInput[]
    skipDuplicates?: boolean
  }

  export type projet_ficheCreateWithoutProjetInput = {
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    created_by: UserCreateNestedOneWithoutFichesInput
  }

  export type projet_ficheUncheckedCreateWithoutProjetInput = {
    id?: number
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    user_id: string
  }

  export type projet_ficheCreateOrConnectWithoutProjetInput = {
    where: projet_ficheWhereUniqueInput
    create: XOR<projet_ficheCreateWithoutProjetInput, projet_ficheUncheckedCreateWithoutProjetInput>
  }

  export type projet_ficheCreateManyProjetInputEnvelope = {
    data: projet_ficheCreateManyProjetInput | projet_ficheCreateManyProjetInput[]
    skipDuplicates?: boolean
  }

  export type diagnostic_simulationCreateWithoutProjetInput = {
    id?: string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutDiagnostic_simulationInput
  }

  export type diagnostic_simulationUncheckedCreateWithoutProjetInput = {
    id?: string
    user_id?: string | null
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type diagnostic_simulationCreateOrConnectWithoutProjetInput = {
    where: diagnostic_simulationWhereUniqueInput
    create: XOR<diagnostic_simulationCreateWithoutProjetInput, diagnostic_simulationUncheckedCreateWithoutProjetInput>
  }

  export type diagnostic_simulationCreateManyProjetInputEnvelope = {
    data: diagnostic_simulationCreateManyProjetInput | diagnostic_simulationCreateManyProjetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjets_createdInput = {
    update: XOR<UserUpdateWithoutProjets_createdInput, UserUncheckedUpdateWithoutProjets_createdInput>
    create: XOR<UserCreateWithoutProjets_createdInput, UserUncheckedCreateWithoutProjets_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjets_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjets_createdInput, UserUncheckedUpdateWithoutProjets_createdInput>
  }

  export type UserUpdateWithoutProjets_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjets_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type estimationUpsertWithWhereUniqueWithoutProjetInput = {
    where: estimationWhereUniqueInput
    update: XOR<estimationUpdateWithoutProjetInput, estimationUncheckedUpdateWithoutProjetInput>
    create: XOR<estimationCreateWithoutProjetInput, estimationUncheckedCreateWithoutProjetInput>
  }

  export type estimationUpdateWithWhereUniqueWithoutProjetInput = {
    where: estimationWhereUniqueInput
    data: XOR<estimationUpdateWithoutProjetInput, estimationUncheckedUpdateWithoutProjetInput>
  }

  export type estimationUpdateManyWithWhereWithoutProjetInput = {
    where: estimationScalarWhereInput
    data: XOR<estimationUpdateManyMutationInput, estimationUncheckedUpdateManyWithoutProjetInput>
  }

  export type collectiviteUpsertWithoutProjetInput = {
    update: XOR<collectiviteUpdateWithoutProjetInput, collectiviteUncheckedUpdateWithoutProjetInput>
    create: XOR<collectiviteCreateWithoutProjetInput, collectiviteUncheckedCreateWithoutProjetInput>
    where?: collectiviteWhereInput
  }

  export type collectiviteUpdateToOneWithWhereWithoutProjetInput = {
    where?: collectiviteWhereInput
    data: XOR<collectiviteUpdateWithoutProjetInput, collectiviteUncheckedUpdateWithoutProjetInput>
  }

  export type collectiviteUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: user_collectiviteUpdateManyWithoutCollectiviteNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectivites_createdNestedInput
  }

  export type collectiviteUncheckedUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: user_collectiviteUncheckedUpdateManyWithoutCollectiviteNestedInput
  }

  export type UserUpsertWithoutProjets_deletedInput = {
    update: XOR<UserUpdateWithoutProjets_deletedInput, UserUncheckedUpdateWithoutProjets_deletedInput>
    create: XOR<UserCreateWithoutProjets_deletedInput, UserUncheckedCreateWithoutProjets_deletedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjets_deletedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjets_deletedInput, UserUncheckedUpdateWithoutProjets_deletedInput>
  }

  export type UserUpdateWithoutProjets_deletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjets_deletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type user_projetUpsertWithWhereUniqueWithoutProjetInput = {
    where: user_projetWhereUniqueInput
    update: XOR<user_projetUpdateWithoutProjetInput, user_projetUncheckedUpdateWithoutProjetInput>
    create: XOR<user_projetCreateWithoutProjetInput, user_projetUncheckedCreateWithoutProjetInput>
  }

  export type user_projetUpdateWithWhereUniqueWithoutProjetInput = {
    where: user_projetWhereUniqueInput
    data: XOR<user_projetUpdateWithoutProjetInput, user_projetUncheckedUpdateWithoutProjetInput>
  }

  export type user_projetUpdateManyWithWhereWithoutProjetInput = {
    where: user_projetScalarWhereInput
    data: XOR<user_projetUpdateManyMutationInput, user_projetUncheckedUpdateManyWithoutProjetInput>
  }

  export type projet_sourcing_contactUpsertWithWhereUniqueWithoutProjetInput = {
    where: projet_sourcing_contactWhereUniqueInput
    update: XOR<projet_sourcing_contactUpdateWithoutProjetInput, projet_sourcing_contactUncheckedUpdateWithoutProjetInput>
    create: XOR<projet_sourcing_contactCreateWithoutProjetInput, projet_sourcing_contactUncheckedCreateWithoutProjetInput>
  }

  export type projet_sourcing_contactUpdateWithWhereUniqueWithoutProjetInput = {
    where: projet_sourcing_contactWhereUniqueInput
    data: XOR<projet_sourcing_contactUpdateWithoutProjetInput, projet_sourcing_contactUncheckedUpdateWithoutProjetInput>
  }

  export type projet_sourcing_contactUpdateManyWithWhereWithoutProjetInput = {
    where: projet_sourcing_contactScalarWhereInput
    data: XOR<projet_sourcing_contactUpdateManyMutationInput, projet_sourcing_contactUncheckedUpdateManyWithoutProjetInput>
  }

  export type projet_ficheUpsertWithWhereUniqueWithoutProjetInput = {
    where: projet_ficheWhereUniqueInput
    update: XOR<projet_ficheUpdateWithoutProjetInput, projet_ficheUncheckedUpdateWithoutProjetInput>
    create: XOR<projet_ficheCreateWithoutProjetInput, projet_ficheUncheckedCreateWithoutProjetInput>
  }

  export type projet_ficheUpdateWithWhereUniqueWithoutProjetInput = {
    where: projet_ficheWhereUniqueInput
    data: XOR<projet_ficheUpdateWithoutProjetInput, projet_ficheUncheckedUpdateWithoutProjetInput>
  }

  export type projet_ficheUpdateManyWithWhereWithoutProjetInput = {
    where: projet_ficheScalarWhereInput
    data: XOR<projet_ficheUpdateManyMutationInput, projet_ficheUncheckedUpdateManyWithoutProjetInput>
  }

  export type diagnostic_simulationUpsertWithWhereUniqueWithoutProjetInput = {
    where: diagnostic_simulationWhereUniqueInput
    update: XOR<diagnostic_simulationUpdateWithoutProjetInput, diagnostic_simulationUncheckedUpdateWithoutProjetInput>
    create: XOR<diagnostic_simulationCreateWithoutProjetInput, diagnostic_simulationUncheckedCreateWithoutProjetInput>
  }

  export type diagnostic_simulationUpdateWithWhereUniqueWithoutProjetInput = {
    where: diagnostic_simulationWhereUniqueInput
    data: XOR<diagnostic_simulationUpdateWithoutProjetInput, diagnostic_simulationUncheckedUpdateWithoutProjetInput>
  }

  export type diagnostic_simulationUpdateManyWithWhereWithoutProjetInput = {
    where: diagnostic_simulationScalarWhereInput
    data: XOR<diagnostic_simulationUpdateManyMutationInput, diagnostic_simulationUncheckedUpdateManyWithoutProjetInput>
  }

  export type projetCreateWithoutFichesInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutFichesInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutFichesInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutFichesInput, projetUncheckedCreateWithoutFichesInput>
  }

  export type UserCreateWithoutFichesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFichesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFichesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFichesInput, UserUncheckedCreateWithoutFichesInput>
  }

  export type projetUpsertWithoutFichesInput = {
    update: XOR<projetUpdateWithoutFichesInput, projetUncheckedUpdateWithoutFichesInput>
    create: XOR<projetCreateWithoutFichesInput, projetUncheckedCreateWithoutFichesInput>
    where?: projetWhereInput
  }

  export type projetUpdateToOneWithWhereWithoutFichesInput = {
    where?: projetWhereInput
    data: XOR<projetUpdateWithoutFichesInput, projetUncheckedUpdateWithoutFichesInput>
  }

  export type projetUpdateWithoutFichesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutFichesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type UserUpsertWithoutFichesInput = {
    update: XOR<UserUpdateWithoutFichesInput, UserUncheckedUpdateWithoutFichesInput>
    create: XOR<UserCreateWithoutFichesInput, UserUncheckedCreateWithoutFichesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFichesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFichesInput, UserUncheckedUpdateWithoutFichesInput>
  }

  export type UserUpdateWithoutFichesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFichesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type projetCreateWithoutSourcing_user_projetsInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutSourcing_user_projetsInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutSourcing_user_projetsInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutSourcing_user_projetsInput, projetUncheckedCreateWithoutSourcing_user_projetsInput>
  }

  export type user_projetCreateWithoutSourced_by_projetsInput = {
    email_address?: string | null
    role: $Enums.RoleProjet
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    projet: projetCreateNestedOneWithoutUsersInput
    user?: UserCreateNestedOneWithoutProjetsInput
    deleter?: UserCreateNestedOneWithoutUser_projet_deletedInput
    email?: emailCreateNestedManyWithoutUser_projetInput
  }

  export type user_projetUncheckedCreateWithoutSourced_by_projetsInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
    email?: emailUncheckedCreateNestedManyWithoutUser_projetInput
  }

  export type user_projetCreateOrConnectWithoutSourced_by_projetsInput = {
    where: user_projetWhereUniqueInput
    create: XOR<user_projetCreateWithoutSourced_by_projetsInput, user_projetUncheckedCreateWithoutSourced_by_projetsInput>
  }

  export type UserCreateWithoutSourcing_contacts_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSourcing_contacts_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSourcing_contacts_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSourcing_contacts_createdInput, UserUncheckedCreateWithoutSourcing_contacts_createdInput>
  }

  export type projetUpsertWithoutSourcing_user_projetsInput = {
    update: XOR<projetUpdateWithoutSourcing_user_projetsInput, projetUncheckedUpdateWithoutSourcing_user_projetsInput>
    create: XOR<projetCreateWithoutSourcing_user_projetsInput, projetUncheckedCreateWithoutSourcing_user_projetsInput>
    where?: projetWhereInput
  }

  export type projetUpdateToOneWithWhereWithoutSourcing_user_projetsInput = {
    where?: projetWhereInput
    data: XOR<projetUpdateWithoutSourcing_user_projetsInput, projetUncheckedUpdateWithoutSourcing_user_projetsInput>
  }

  export type projetUpdateWithoutSourcing_user_projetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutSourcing_user_projetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type user_projetUpsertWithoutSourced_by_projetsInput = {
    update: XOR<user_projetUpdateWithoutSourced_by_projetsInput, user_projetUncheckedUpdateWithoutSourced_by_projetsInput>
    create: XOR<user_projetCreateWithoutSourced_by_projetsInput, user_projetUncheckedCreateWithoutSourced_by_projetsInput>
    where?: user_projetWhereInput
  }

  export type user_projetUpdateToOneWithWhereWithoutSourced_by_projetsInput = {
    where?: user_projetWhereInput
    data: XOR<user_projetUpdateWithoutSourced_by_projetsInput, user_projetUncheckedUpdateWithoutSourced_by_projetsInput>
  }

  export type user_projetUpdateWithoutSourced_by_projetsInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet?: projetUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneWithoutProjetsNestedInput
    deleter?: UserUpdateOneWithoutUser_projet_deletedNestedInput
    email?: emailUpdateManyWithoutUser_projetNestedInput
  }

  export type user_projetUncheckedUpdateWithoutSourced_by_projetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: emailUncheckedUpdateManyWithoutUser_projetNestedInput
  }

  export type UserUpsertWithoutSourcing_contacts_createdInput = {
    update: XOR<UserUpdateWithoutSourcing_contacts_createdInput, UserUncheckedUpdateWithoutSourcing_contacts_createdInput>
    create: XOR<UserCreateWithoutSourcing_contacts_createdInput, UserUncheckedCreateWithoutSourcing_contacts_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSourcing_contacts_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSourcing_contacts_createdInput, UserUncheckedUpdateWithoutSourcing_contacts_createdInput>
  }

  export type UserUpdateWithoutSourcing_contacts_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSourcing_contacts_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEstimations_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEstimations_createdInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEstimations_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEstimations_createdInput, UserUncheckedCreateWithoutEstimations_createdInput>
  }

  export type projetCreateWithoutEstimationsInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutEstimationsInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
    diagnostic_simulations?: diagnostic_simulationUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutEstimationsInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutEstimationsInput, projetUncheckedCreateWithoutEstimationsInput>
  }

  export type UserCreateWithoutEstimations_deletedInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEstimations_deletedInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEstimations_deletedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEstimations_deletedInput, UserUncheckedCreateWithoutEstimations_deletedInput>
  }

  export type estimations_aidesCreateWithoutEstimationInput = {
    id?: number
    created_at?: Date | string | null
    aide: aideCreateNestedOneWithoutEstimations_aidesInput
    created_by?: UserCreateNestedOneWithoutEstimations_aidesInput
  }

  export type estimations_aidesUncheckedCreateWithoutEstimationInput = {
    id?: number
    aideId: number
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type estimations_aidesCreateOrConnectWithoutEstimationInput = {
    where: estimations_aidesWhereUniqueInput
    create: XOR<estimations_aidesCreateWithoutEstimationInput, estimations_aidesUncheckedCreateWithoutEstimationInput>
  }

  export type estimations_aidesCreateManyEstimationInputEnvelope = {
    data: estimations_aidesCreateManyEstimationInput | estimations_aidesCreateManyEstimationInput[]
    skipDuplicates?: boolean
  }

  export type estimation_fiche_solutionCreateWithoutEstimationInput = {
    id?: string
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
    estimation_materiaux?: estimation_materiauxCreateNestedManyWithoutEstimation_fiche_solutionInput
  }

  export type estimation_fiche_solutionUncheckedCreateWithoutEstimationInput = {
    id?: string
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
    estimation_materiaux?: estimation_materiauxUncheckedCreateNestedManyWithoutEstimation_fiche_solutionInput
  }

  export type estimation_fiche_solutionCreateOrConnectWithoutEstimationInput = {
    where: estimation_fiche_solutionWhereUniqueInput
    create: XOR<estimation_fiche_solutionCreateWithoutEstimationInput, estimation_fiche_solutionUncheckedCreateWithoutEstimationInput>
  }

  export type estimation_fiche_solutionCreateManyEstimationInputEnvelope = {
    data: estimation_fiche_solutionCreateManyEstimationInput | estimation_fiche_solutionCreateManyEstimationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEstimations_createdInput = {
    update: XOR<UserUpdateWithoutEstimations_createdInput, UserUncheckedUpdateWithoutEstimations_createdInput>
    create: XOR<UserCreateWithoutEstimations_createdInput, UserUncheckedCreateWithoutEstimations_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEstimations_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEstimations_createdInput, UserUncheckedUpdateWithoutEstimations_createdInput>
  }

  export type UserUpdateWithoutEstimations_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEstimations_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type projetUpsertWithoutEstimationsInput = {
    update: XOR<projetUpdateWithoutEstimationsInput, projetUncheckedUpdateWithoutEstimationsInput>
    create: XOR<projetCreateWithoutEstimationsInput, projetUncheckedCreateWithoutEstimationsInput>
    where?: projetWhereInput
  }

  export type projetUpdateToOneWithWhereWithoutEstimationsInput = {
    where?: projetWhereInput
    data: XOR<projetUpdateWithoutEstimationsInput, projetUncheckedUpdateWithoutEstimationsInput>
  }

  export type projetUpdateWithoutEstimationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutEstimationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type UserUpsertWithoutEstimations_deletedInput = {
    update: XOR<UserUpdateWithoutEstimations_deletedInput, UserUncheckedUpdateWithoutEstimations_deletedInput>
    create: XOR<UserCreateWithoutEstimations_deletedInput, UserUncheckedCreateWithoutEstimations_deletedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEstimations_deletedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEstimations_deletedInput, UserUncheckedUpdateWithoutEstimations_deletedInput>
  }

  export type UserUpdateWithoutEstimations_deletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEstimations_deletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type estimations_aidesUpsertWithWhereUniqueWithoutEstimationInput = {
    where: estimations_aidesWhereUniqueInput
    update: XOR<estimations_aidesUpdateWithoutEstimationInput, estimations_aidesUncheckedUpdateWithoutEstimationInput>
    create: XOR<estimations_aidesCreateWithoutEstimationInput, estimations_aidesUncheckedCreateWithoutEstimationInput>
  }

  export type estimations_aidesUpdateWithWhereUniqueWithoutEstimationInput = {
    where: estimations_aidesWhereUniqueInput
    data: XOR<estimations_aidesUpdateWithoutEstimationInput, estimations_aidesUncheckedUpdateWithoutEstimationInput>
  }

  export type estimations_aidesUpdateManyWithWhereWithoutEstimationInput = {
    where: estimations_aidesScalarWhereInput
    data: XOR<estimations_aidesUpdateManyMutationInput, estimations_aidesUncheckedUpdateManyWithoutEstimationInput>
  }

  export type estimation_fiche_solutionUpsertWithWhereUniqueWithoutEstimationInput = {
    where: estimation_fiche_solutionWhereUniqueInput
    update: XOR<estimation_fiche_solutionUpdateWithoutEstimationInput, estimation_fiche_solutionUncheckedUpdateWithoutEstimationInput>
    create: XOR<estimation_fiche_solutionCreateWithoutEstimationInput, estimation_fiche_solutionUncheckedCreateWithoutEstimationInput>
  }

  export type estimation_fiche_solutionUpdateWithWhereUniqueWithoutEstimationInput = {
    where: estimation_fiche_solutionWhereUniqueInput
    data: XOR<estimation_fiche_solutionUpdateWithoutEstimationInput, estimation_fiche_solutionUncheckedUpdateWithoutEstimationInput>
  }

  export type estimation_fiche_solutionUpdateManyWithWhereWithoutEstimationInput = {
    where: estimation_fiche_solutionScalarWhereInput
    data: XOR<estimation_fiche_solutionUpdateManyMutationInput, estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationInput>
  }

  export type estimation_fiche_solutionScalarWhereInput = {
    AND?: estimation_fiche_solutionScalarWhereInput | estimation_fiche_solutionScalarWhereInput[]
    OR?: estimation_fiche_solutionScalarWhereInput[]
    NOT?: estimation_fiche_solutionScalarWhereInput | estimation_fiche_solutionScalarWhereInput[]
    id?: StringFilter<"estimation_fiche_solution"> | string
    estimation_id?: IntFilter<"estimation_fiche_solution"> | number
    fiche_solution_id?: IntFilter<"estimation_fiche_solution"> | number
    quantite?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    cout_min_investissement?: IntFilter<"estimation_fiche_solution"> | number
    cout_max_investissement?: IntFilter<"estimation_fiche_solution"> | number
    cout_min_entretien?: IntFilter<"estimation_fiche_solution"> | number
    cout_max_entretien?: IntFilter<"estimation_fiche_solution"> | number
    cout_investissement_override?: IntNullableFilter<"estimation_fiche_solution"> | number | null
    cout_entretien_override?: IntNullableFilter<"estimation_fiche_solution"> | number | null
  }

  export type estimations_aidesCreateWithoutAideInput = {
    id?: number
    created_at?: Date | string | null
    estimation: estimationCreateNestedOneWithoutEstimations_aidesInput
    created_by?: UserCreateNestedOneWithoutEstimations_aidesInput
  }

  export type estimations_aidesUncheckedCreateWithoutAideInput = {
    id?: number
    estimationId: number
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type estimations_aidesCreateOrConnectWithoutAideInput = {
    where: estimations_aidesWhereUniqueInput
    create: XOR<estimations_aidesCreateWithoutAideInput, estimations_aidesUncheckedCreateWithoutAideInput>
  }

  export type estimations_aidesCreateManyAideInputEnvelope = {
    data: estimations_aidesCreateManyAideInput | estimations_aidesCreateManyAideInput[]
    skipDuplicates?: boolean
  }

  export type estimations_aidesUpsertWithWhereUniqueWithoutAideInput = {
    where: estimations_aidesWhereUniqueInput
    update: XOR<estimations_aidesUpdateWithoutAideInput, estimations_aidesUncheckedUpdateWithoutAideInput>
    create: XOR<estimations_aidesCreateWithoutAideInput, estimations_aidesUncheckedCreateWithoutAideInput>
  }

  export type estimations_aidesUpdateWithWhereUniqueWithoutAideInput = {
    where: estimations_aidesWhereUniqueInput
    data: XOR<estimations_aidesUpdateWithoutAideInput, estimations_aidesUncheckedUpdateWithoutAideInput>
  }

  export type estimations_aidesUpdateManyWithWhereWithoutAideInput = {
    where: estimations_aidesScalarWhereInput
    data: XOR<estimations_aidesUpdateManyMutationInput, estimations_aidesUncheckedUpdateManyWithoutAideInput>
  }

  export type estimationCreateWithoutEstimations_aidesInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    creator: UserCreateNestedOneWithoutEstimations_createdInput
    projet: projetCreateNestedOneWithoutEstimationsInput
    deleter?: UserCreateNestedOneWithoutEstimations_deletedInput
    estimations_fiches_solutions?: estimation_fiche_solutionCreateNestedManyWithoutEstimationInput
  }

  export type estimationUncheckedCreateWithoutEstimations_aidesInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedCreateNestedManyWithoutEstimationInput
  }

  export type estimationCreateOrConnectWithoutEstimations_aidesInput = {
    where: estimationWhereUniqueInput
    create: XOR<estimationCreateWithoutEstimations_aidesInput, estimationUncheckedCreateWithoutEstimations_aidesInput>
  }

  export type aideCreateWithoutEstimations_aidesInput = {
    aideTerritoireId: number
    submission_deadline?: Date | string | null
    type: string
    name?: string | null
    financers?: aideCreatefinancersInput | string[]
  }

  export type aideUncheckedCreateWithoutEstimations_aidesInput = {
    id?: number
    aideTerritoireId: number
    submission_deadline?: Date | string | null
    type: string
    name?: string | null
    financers?: aideCreatefinancersInput | string[]
  }

  export type aideCreateOrConnectWithoutEstimations_aidesInput = {
    where: aideWhereUniqueInput
    create: XOR<aideCreateWithoutEstimations_aidesInput, aideUncheckedCreateWithoutEstimations_aidesInput>
  }

  export type UserCreateWithoutEstimations_aidesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEstimations_aidesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEstimations_aidesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEstimations_aidesInput, UserUncheckedCreateWithoutEstimations_aidesInput>
  }

  export type estimationUpsertWithoutEstimations_aidesInput = {
    update: XOR<estimationUpdateWithoutEstimations_aidesInput, estimationUncheckedUpdateWithoutEstimations_aidesInput>
    create: XOR<estimationCreateWithoutEstimations_aidesInput, estimationUncheckedCreateWithoutEstimations_aidesInput>
    where?: estimationWhereInput
  }

  export type estimationUpdateToOneWithWhereWithoutEstimations_aidesInput = {
    where?: estimationWhereInput
    data: XOR<estimationUpdateWithoutEstimations_aidesInput, estimationUncheckedUpdateWithoutEstimations_aidesInput>
  }

  export type estimationUpdateWithoutEstimations_aidesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutEstimations_createdNestedInput
    projet?: projetUpdateOneRequiredWithoutEstimationsNestedInput
    deleter?: UserUpdateOneWithoutEstimations_deletedNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateWithoutEstimations_aidesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationNestedInput
  }

  export type aideUpsertWithoutEstimations_aidesInput = {
    update: XOR<aideUpdateWithoutEstimations_aidesInput, aideUncheckedUpdateWithoutEstimations_aidesInput>
    create: XOR<aideCreateWithoutEstimations_aidesInput, aideUncheckedCreateWithoutEstimations_aidesInput>
    where?: aideWhereInput
  }

  export type aideUpdateToOneWithWhereWithoutEstimations_aidesInput = {
    where?: aideWhereInput
    data: XOR<aideUpdateWithoutEstimations_aidesInput, aideUncheckedUpdateWithoutEstimations_aidesInput>
  }

  export type aideUpdateWithoutEstimations_aidesInput = {
    aideTerritoireId?: IntFieldUpdateOperationsInput | number
    submission_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financers?: aideUpdatefinancersInput | string[]
  }

  export type aideUncheckedUpdateWithoutEstimations_aidesInput = {
    id?: IntFieldUpdateOperationsInput | number
    aideTerritoireId?: IntFieldUpdateOperationsInput | number
    submission_deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financers?: aideUpdatefinancersInput | string[]
  }

  export type UserUpsertWithoutEstimations_aidesInput = {
    update: XOR<UserUpdateWithoutEstimations_aidesInput, UserUncheckedUpdateWithoutEstimations_aidesInput>
    create: XOR<UserCreateWithoutEstimations_aidesInput, UserUncheckedCreateWithoutEstimations_aidesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEstimations_aidesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEstimations_aidesInput, UserUncheckedUpdateWithoutEstimations_aidesInput>
  }

  export type UserUpdateWithoutEstimations_aidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEstimations_aidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type estimation_fiche_solutionCreateWithoutEstimation_materiauxInput = {
    id?: string
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
    estimation: estimationCreateNestedOneWithoutEstimations_fiches_solutionsInput
  }

  export type estimation_fiche_solutionUncheckedCreateWithoutEstimation_materiauxInput = {
    id?: string
    estimation_id: number
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_fiche_solutionCreateOrConnectWithoutEstimation_materiauxInput = {
    where: estimation_fiche_solutionWhereUniqueInput
    create: XOR<estimation_fiche_solutionCreateWithoutEstimation_materiauxInput, estimation_fiche_solutionUncheckedCreateWithoutEstimation_materiauxInput>
  }

  export type estimation_fiche_solutionUpsertWithoutEstimation_materiauxInput = {
    update: XOR<estimation_fiche_solutionUpdateWithoutEstimation_materiauxInput, estimation_fiche_solutionUncheckedUpdateWithoutEstimation_materiauxInput>
    create: XOR<estimation_fiche_solutionCreateWithoutEstimation_materiauxInput, estimation_fiche_solutionUncheckedCreateWithoutEstimation_materiauxInput>
    where?: estimation_fiche_solutionWhereInput
  }

  export type estimation_fiche_solutionUpdateToOneWithWhereWithoutEstimation_materiauxInput = {
    where?: estimation_fiche_solutionWhereInput
    data: XOR<estimation_fiche_solutionUpdateWithoutEstimation_materiauxInput, estimation_fiche_solutionUncheckedUpdateWithoutEstimation_materiauxInput>
  }

  export type estimation_fiche_solutionUpdateWithoutEstimation_materiauxInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
    estimation?: estimationUpdateOneRequiredWithoutEstimations_fiches_solutionsNestedInput
  }

  export type estimation_fiche_solutionUncheckedUpdateWithoutEstimation_materiauxInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimation_id?: IntFieldUpdateOperationsInput | number
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimationCreateWithoutEstimations_fiches_solutionsInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    creator: UserCreateNestedOneWithoutEstimations_createdInput
    projet: projetCreateNestedOneWithoutEstimationsInput
    deleter?: UserCreateNestedOneWithoutEstimations_deletedInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutEstimationInput
  }

  export type estimationUncheckedCreateWithoutEstimations_fiches_solutionsInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutEstimationInput
  }

  export type estimationCreateOrConnectWithoutEstimations_fiches_solutionsInput = {
    where: estimationWhereUniqueInput
    create: XOR<estimationCreateWithoutEstimations_fiches_solutionsInput, estimationUncheckedCreateWithoutEstimations_fiches_solutionsInput>
  }

  export type estimation_materiauxCreateWithoutEstimation_fiche_solutionInput = {
    id?: string
    materiau_id: number
    quantite: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput = {
    id?: string
    materiau_id: number
    quantite: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_materiauxCreateOrConnectWithoutEstimation_fiche_solutionInput = {
    where: estimation_materiauxWhereUniqueInput
    create: XOR<estimation_materiauxCreateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput>
  }

  export type estimation_materiauxCreateManyEstimation_fiche_solutionInputEnvelope = {
    data: estimation_materiauxCreateManyEstimation_fiche_solutionInput | estimation_materiauxCreateManyEstimation_fiche_solutionInput[]
    skipDuplicates?: boolean
  }

  export type estimationUpsertWithoutEstimations_fiches_solutionsInput = {
    update: XOR<estimationUpdateWithoutEstimations_fiches_solutionsInput, estimationUncheckedUpdateWithoutEstimations_fiches_solutionsInput>
    create: XOR<estimationCreateWithoutEstimations_fiches_solutionsInput, estimationUncheckedCreateWithoutEstimations_fiches_solutionsInput>
    where?: estimationWhereInput
  }

  export type estimationUpdateToOneWithWhereWithoutEstimations_fiches_solutionsInput = {
    where?: estimationWhereInput
    data: XOR<estimationUpdateWithoutEstimations_fiches_solutionsInput, estimationUncheckedUpdateWithoutEstimations_fiches_solutionsInput>
  }

  export type estimationUpdateWithoutEstimations_fiches_solutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutEstimations_createdNestedInput
    projet?: projetUpdateOneRequiredWithoutEstimationsNestedInput
    deleter?: UserUpdateOneWithoutEstimations_deletedNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateWithoutEstimations_fiches_solutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutEstimationNestedInput
  }

  export type estimation_materiauxUpsertWithWhereUniqueWithoutEstimation_fiche_solutionInput = {
    where: estimation_materiauxWhereUniqueInput
    update: XOR<estimation_materiauxUpdateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedUpdateWithoutEstimation_fiche_solutionInput>
    create: XOR<estimation_materiauxCreateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedCreateWithoutEstimation_fiche_solutionInput>
  }

  export type estimation_materiauxUpdateWithWhereUniqueWithoutEstimation_fiche_solutionInput = {
    where: estimation_materiauxWhereUniqueInput
    data: XOR<estimation_materiauxUpdateWithoutEstimation_fiche_solutionInput, estimation_materiauxUncheckedUpdateWithoutEstimation_fiche_solutionInput>
  }

  export type estimation_materiauxUpdateManyWithWhereWithoutEstimation_fiche_solutionInput = {
    where: estimation_materiauxScalarWhereInput
    data: XOR<estimation_materiauxUpdateManyMutationInput, estimation_materiauxUncheckedUpdateManyWithoutEstimation_fiche_solutionInput>
  }

  export type estimation_materiauxScalarWhereInput = {
    AND?: estimation_materiauxScalarWhereInput | estimation_materiauxScalarWhereInput[]
    OR?: estimation_materiauxScalarWhereInput[]
    NOT?: estimation_materiauxScalarWhereInput | estimation_materiauxScalarWhereInput[]
    id?: StringFilter<"estimation_materiaux"> | string
    estimation_fiche_solution_id?: StringFilter<"estimation_materiaux"> | string
    materiau_id?: IntFilter<"estimation_materiaux"> | number
    quantite?: IntFilter<"estimation_materiaux"> | number
    cout_investissement_override?: IntNullableFilter<"estimation_materiaux"> | number | null
    cout_entretien_override?: IntNullableFilter<"estimation_materiaux"> | number | null
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type projetCreateWithoutDiagnostic_simulationsInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    creator: UserCreateNestedOneWithoutProjets_createdInput
    estimations?: estimationCreateNestedManyWithoutProjetInput
    collectivite: collectiviteCreateNestedOneWithoutProjetInput
    deleter?: UserCreateNestedOneWithoutProjets_deletedInput
    users?: user_projetCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheCreateNestedManyWithoutProjetInput
  }

  export type projetUncheckedCreateWithoutDiagnostic_simulationsInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
    estimations?: estimationUncheckedCreateNestedManyWithoutProjetInput
    users?: user_projetUncheckedCreateNestedManyWithoutProjetInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedCreateNestedManyWithoutProjetInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutProjetInput
  }

  export type projetCreateOrConnectWithoutDiagnostic_simulationsInput = {
    where: projetWhereUniqueInput
    create: XOR<projetCreateWithoutDiagnostic_simulationsInput, projetUncheckedCreateWithoutDiagnostic_simulationsInput>
  }

  export type UserCreateWithoutDiagnostic_simulationInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
  }

  export type UserUncheckedCreateWithoutDiagnostic_simulationInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    Analytics?: AnalyticsUncheckedCreateNestedManyWithoutCreated_byInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
  }

  export type UserCreateOrConnectWithoutDiagnostic_simulationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiagnostic_simulationInput, UserUncheckedCreateWithoutDiagnostic_simulationInput>
  }

  export type projetUpsertWithoutDiagnostic_simulationsInput = {
    update: XOR<projetUpdateWithoutDiagnostic_simulationsInput, projetUncheckedUpdateWithoutDiagnostic_simulationsInput>
    create: XOR<projetCreateWithoutDiagnostic_simulationsInput, projetUncheckedCreateWithoutDiagnostic_simulationsInput>
    where?: projetWhereInput
  }

  export type projetUpdateToOneWithWhereWithoutDiagnostic_simulationsInput = {
    where?: projetWhereInput
    data: XOR<projetUpdateWithoutDiagnostic_simulationsInput, projetUncheckedUpdateWithoutDiagnostic_simulationsInput>
  }

  export type projetUpdateWithoutDiagnostic_simulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutDiagnostic_simulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type UserUpsertWithoutDiagnostic_simulationInput = {
    update: XOR<UserUpdateWithoutDiagnostic_simulationInput, UserUncheckedUpdateWithoutDiagnostic_simulationInput>
    create: XOR<UserCreateWithoutDiagnostic_simulationInput, UserUncheckedCreateWithoutDiagnostic_simulationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiagnostic_simulationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiagnostic_simulationInput, UserUncheckedUpdateWithoutDiagnostic_simulationInput>
  }

  export type UserUpdateWithoutDiagnostic_simulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
  }

  export type UserUncheckedUpdateWithoutDiagnostic_simulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    Analytics?: AnalyticsUncheckedUpdateManyWithoutCreated_byNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
  }

  export type UserCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteCreateNestedManyWithoutCreatorInput
    projets_created?: projetCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteCreateNestedManyWithoutUserInput
    projets?: user_projetCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetCreateNestedManyWithoutDeleterInput
    conversations?: conversationCreateNestedManyWithoutUserInput
    sourcing_contacts_created?: projet_sourcing_contactCreateNestedManyWithoutCreatorInput
    emails?: emailCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: string | null
    prenom?: string | null
    poste?: string | null
    nom_etablissement?: string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    canal_acquisition?: string | null
    discardedInformation?: UserCreatediscardedInformationInput | string[]
    accept_communication_produit?: boolean
    accept_communication_suivi_projet?: boolean
    statut?: $Enums.StatutUser | null
    statut_updated_at?: Date | string | null
    last_browsing_date?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    collectivites_created?: collectiviteUncheckedCreateNestedManyWithoutCreatorInput
    projets_created?: projetUncheckedCreateNestedManyWithoutCreatorInput
    estimations_created?: estimationUncheckedCreateNestedManyWithoutCreatorInput
    estimations_deleted?: estimationUncheckedCreateNestedManyWithoutDeleterInput
    projets_deleted?: projetUncheckedCreateNestedManyWithoutDeleterInput
    collectivites?: user_collectiviteUncheckedCreateNestedManyWithoutUserInput
    projets?: user_projetUncheckedCreateNestedManyWithoutUserInput
    user_projet_deleted?: user_projetUncheckedCreateNestedManyWithoutDeleterInput
    conversations?: conversationUncheckedCreateNestedManyWithoutUserInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedCreateNestedManyWithoutCreatorInput
    emails?: emailUncheckedCreateNestedManyWithoutUserInput
    estimations_aides?: estimations_aidesUncheckedCreateNestedManyWithoutCreated_byInput
    fiches?: projet_ficheUncheckedCreateNestedManyWithoutCreated_byInput
    diagnostic_simulation?: diagnostic_simulationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
  }

  export type UserUpsertWithoutAnalyticsInput = {
    update: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUpdateManyWithoutUserNestedInput
    projets?: user_projetUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUpdateManyWithoutUserNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUpdateManyWithoutCreatorNestedInput
    emails?: emailUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    agentconnect_info?: NullableJsonNullValueInput | InputJsonValue
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    poste?: NullableStringFieldUpdateOperationsInput | string | null
    nom_etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    siren_info?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canal_acquisition?: NullableStringFieldUpdateOperationsInput | string | null
    discardedInformation?: UserUpdatediscardedInformationInput | string[]
    accept_communication_produit?: BoolFieldUpdateOperationsInput | boolean
    accept_communication_suivi_projet?: BoolFieldUpdateOperationsInput | boolean
    statut?: NullableEnumStatutUserFieldUpdateOperationsInput | $Enums.StatutUser | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_browsing_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    collectivites_created?: collectiviteUncheckedUpdateManyWithoutCreatorNestedInput
    projets_created?: projetUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_created?: estimationUncheckedUpdateManyWithoutCreatorNestedInput
    estimations_deleted?: estimationUncheckedUpdateManyWithoutDeleterNestedInput
    projets_deleted?: projetUncheckedUpdateManyWithoutDeleterNestedInput
    collectivites?: user_collectiviteUncheckedUpdateManyWithoutUserNestedInput
    projets?: user_projetUncheckedUpdateManyWithoutUserNestedInput
    user_projet_deleted?: user_projetUncheckedUpdateManyWithoutDeleterNestedInput
    conversations?: conversationUncheckedUpdateManyWithoutUserNestedInput
    sourcing_contacts_created?: projet_sourcing_contactUncheckedUpdateManyWithoutCreatorNestedInput
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutCreated_byNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutCreated_byNestedInput
    diagnostic_simulation?: diagnostic_simulationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type collectiviteCreateManyCreatorInput = {
    id: number
    nom: string
    code_insee?: string | null
    code_postal?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: string | null
    latitude?: number | null
    longitude?: number | null
    created_at?: Date | string
    aides_territoires_perimeter_id?: string | null
  }

  export type projetCreateManyCreatorInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
  }

  export type estimationCreateManyCreatorInput = {
    id: number
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type estimationCreateManyDeleterInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    projet_id: number
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
  }

  export type projetCreateManyDeleterInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    collectiviteId: number
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
  }

  export type user_collectiviteCreateManyUserInput = {
    collectivite_id: number
    verified?: boolean
    created_at?: Date | string
  }

  export type user_projetCreateManyUserInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
  }

  export type user_projetCreateManyDeleterInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    projet_id: number
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
  }

  export type conversationCreateManyUserInput = {
    id?: string
    ragtimeId: string
    created_at?: Date | string
  }

  export type AnalyticsCreateManyCreated_byInput = {
    id?: string
    created_at?: Date | string
    reference_id: string
    reference_type: $Enums.ReferenceType
    event_type: $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type projet_sourcing_contactCreateManyCreatorInput = {
    id?: number
    projet_id: number
    sourced_user_projet_id: number
    created_at?: Date | string
  }

  export type emailCreateManyUserInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    user_projet_id?: number | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type estimations_aidesCreateManyCreated_byInput = {
    id?: number
    estimationId: number
    aideId: number
    created_at?: Date | string | null
  }

  export type projet_ficheCreateManyCreated_byInput = {
    id?: number
    projet_id: number
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
  }

  export type diagnostic_simulationCreateManyUserInput = {
    id?: string
    projet_id: number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectiviteUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: user_collectiviteUpdateManyWithoutCollectiviteNestedInput
    projet?: projetUpdateManyWithoutCollectiviteNestedInput
  }

  export type collectiviteUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
    users?: user_collectiviteUncheckedUpdateManyWithoutCollectiviteNestedInput
    projet?: projetUncheckedUpdateManyWithoutCollectiviteNestedInput
  }

  export type collectiviteUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code_insee?: NullableStringFieldUpdateOperationsInput | string | null
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    ban_id?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    aides_territoires_perimeter_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type projetUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimationUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet?: projetUpdateOneRequiredWithoutEstimationsNestedInput
    deleter?: UserUpdateOneWithoutEstimations_deletedNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimationUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutEstimations_createdNestedInput
    projet?: projetUpdateOneRequiredWithoutEstimationsNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateManyWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet_id?: IntFieldUpdateOperationsInput | number
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projetUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    collectivite?: collectiviteUpdateOneRequiredWithoutProjetNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateManyWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    collectiviteId?: IntFieldUpdateOperationsInput | number
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_collectiviteUpdateWithoutUserInput = {
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collectivite?: collectiviteUpdateOneRequiredWithoutUsersNestedInput
  }

  export type user_collectiviteUncheckedUpdateWithoutUserInput = {
    collectivite_id?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_collectiviteUncheckedUpdateManyWithoutUserInput = {
    collectivite_id?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_projetUpdateWithoutUserInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet?: projetUpdateOneRequiredWithoutUsersNestedInput
    deleter?: UserUpdateOneWithoutUser_projet_deletedNestedInput
    email?: emailUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: emailUncheckedUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_projetUpdateWithoutDeleterInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projet?: projetUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneWithoutProjetsNestedInput
    email?: emailUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: emailUncheckedUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateManyWithoutDeleterInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    projet_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type conversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ragtimeId?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUpdateWithoutCreated_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnalyticsUncheckedUpdateWithoutCreated_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AnalyticsUncheckedUpdateManyWithoutCreated_byInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_id?: StringFieldUpdateOperationsInput | string
    reference_type?: EnumReferenceTypeFieldUpdateOperationsInput | $Enums.ReferenceType
    event_type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    context?: NullableJsonNullValueInput | InputJsonValue
  }

  export type projet_sourcing_contactUpdateWithoutCreatorInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutSourcing_user_projetsNestedInput
    sourced_user_projet?: user_projetUpdateOneRequiredWithoutSourced_by_projetsNestedInput
  }

  export type projet_sourcing_contactUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    sourced_user_projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_sourcing_contactUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    sourced_user_projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type emailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
    user_projet?: user_projetUpdateOneWithoutEmailNestedInput
  }

  export type emailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    user_projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    user_projet_id?: NullableIntFieldUpdateOperationsInput | number | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type estimations_aidesUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimation?: estimationUpdateOneRequiredWithoutEstimations_aidesNestedInput
    aide?: aideUpdateOneRequiredWithoutEstimations_aidesNestedInput
  }

  export type estimations_aidesUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimationId?: IntFieldUpdateOperationsInput | number
    aideId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimations_aidesUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimationId?: IntFieldUpdateOperationsInput | number
    aideId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projet_ficheUpdateWithoutCreated_byInput = {
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutFichesNestedInput
  }

  export type projet_ficheUncheckedUpdateWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projet_ficheUncheckedUpdateManyWithoutCreated_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnostic_simulationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutDiagnostic_simulationsNestedInput
  }

  export type diagnostic_simulationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projet_id?: IntFieldUpdateOperationsInput | number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnostic_simulationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projet_id?: IntFieldUpdateOperationsInput | number
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_collectiviteCreateManyCollectiviteInput = {
    user_id: string
    verified?: boolean
    created_at?: Date | string
  }

  export type projetCreateManyCollectiviteInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string | null
    nom: string
    type_espace?: string | null
    adresse?: string | null
    niveau_maturite?: string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: Date | string | null
    fiches_solutions_id?: projetCreatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetCreatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetCreaterecommandations_viewed_byInput | string[]
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_public?: boolean | null
    budget?: number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: $Enums.StatutProjet | null
    statut_updated_at?: Date | string | null
  }

  export type user_collectiviteUpdateWithoutCollectiviteInput = {
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCollectivitesNestedInput
  }

  export type user_collectiviteUncheckedUpdateWithoutCollectiviteInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_collectiviteUncheckedUpdateManyWithoutCollectiviteInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projetUpdateWithoutCollectiviteInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutProjets_createdNestedInput
    estimations?: estimationUpdateManyWithoutProjetNestedInput
    deleter?: UserUpdateOneWithoutProjets_deletedNestedInput
    users?: user_projetUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateWithoutCollectiviteInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimations?: estimationUncheckedUpdateManyWithoutProjetNestedInput
    users?: user_projetUncheckedUpdateManyWithoutProjetNestedInput
    sourcing_user_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutProjetNestedInput
    fiches?: projet_ficheUncheckedUpdateManyWithoutProjetNestedInput
    diagnostic_simulations?: diagnostic_simulationUncheckedUpdateManyWithoutProjetNestedInput
  }

  export type projetUncheckedUpdateManyWithoutCollectiviteInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nom?: StringFieldUpdateOperationsInput | string
    type_espace?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    niveau_maturite?: NullableStringFieldUpdateOperationsInput | string | null
    adresse_info?: NullableJsonNullValueInput | InputJsonValue
    adresse_all_infos?: NullableJsonNullValueInput | InputJsonValue
    date_echeance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fiches_solutions_id?: projetUpdatefiches_solutions_idInput | number[]
    fiches_diagnostic_id?: projetUpdatefiches_diagnostic_idInput | number[]
    recommandations_viewed_by?: projetUpdaterecommandations_viewed_byInput | string[]
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budget?: NullableIntFieldUpdateOperationsInput | number | null
    sourcing_rex?: NullableJsonNullValueInput | InputJsonValue
    statut?: NullableEnumStatutProjetFieldUpdateOperationsInput | $Enums.StatutProjet | null
    statut_updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type emailCreateManyUser_projetInput = {
    id?: string
    destination_address: string
    type: $Enums.emailType
    sending_time?: Date | string
    brevo_id?: string | null
    email_status: $Enums.emailStatus
    user_id?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type projet_sourcing_contactCreateManySourced_user_projetInput = {
    id?: number
    projet_id: number
    created_at?: Date | string
    created_by: string
  }

  export type emailUpdateWithoutUser_projetInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    extra?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutEmailsNestedInput
  }

  export type emailUncheckedUpdateWithoutUser_projetInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type emailUncheckedUpdateManyWithoutUser_projetInput = {
    id?: StringFieldUpdateOperationsInput | string
    destination_address?: StringFieldUpdateOperationsInput | string
    type?: EnumemailTypeFieldUpdateOperationsInput | $Enums.emailType
    sending_time?: DateTimeFieldUpdateOperationsInput | Date | string
    brevo_id?: NullableStringFieldUpdateOperationsInput | string | null
    email_status?: EnumemailStatusFieldUpdateOperationsInput | $Enums.emailStatus
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
  }

  export type projet_sourcing_contactUpdateWithoutSourced_user_projetInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projet?: projetUpdateOneRequiredWithoutSourcing_user_projetsNestedInput
    creator?: UserUpdateOneRequiredWithoutSourcing_contacts_createdNestedInput
  }

  export type projet_sourcing_contactUncheckedUpdateWithoutSourced_user_projetInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetInput = {
    id?: IntFieldUpdateOperationsInput | number
    projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type estimationCreateManyProjetInput = {
    id: number
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    fiches_solutions_id?: estimationCreatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type user_projetCreateManyProjetInput = {
    id?: number
    email_address?: string | null
    role: $Enums.RoleProjet
    user_id?: string | null
    created_at?: Date | string
    invitation_token?: string | null
    invitation_status: $Enums.InvitationStatus
    deleted_at?: Date | string | null
    deleted_by?: string | null
    nb_views?: number | null
    last_viewed_at?: Date | string | null
  }

  export type projet_sourcing_contactCreateManyProjetInput = {
    id?: number
    sourced_user_projet_id: number
    created_at?: Date | string
    created_by: string
  }

  export type projet_ficheCreateManyProjetInput = {
    id?: number
    fiche_id: number
    type: $Enums.FicheType
    created_at?: Date | string
    user_id: string
  }

  export type diagnostic_simulationCreateManyProjetInput = {
    id?: string
    user_id?: string | null
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type estimationUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutEstimations_createdNestedInput
    deleter?: UserUpdateOneWithoutEstimations_deletedNestedInput
    estimations_aides?: estimations_aidesUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    estimations_aides?: estimations_aidesUncheckedUpdateManyWithoutEstimationNestedInput
    estimations_fiches_solutions?: estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationNestedInput
  }

  export type estimationUncheckedUpdateManyWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fiches_solutions_id?: estimationUpdatefiches_solutions_idInput | number[]
    materiaux?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_projetUpdateWithoutProjetInput = {
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutProjetsNestedInput
    deleter?: UserUpdateOneWithoutUser_projet_deletedNestedInput
    email?: emailUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: emailUncheckedUpdateManyWithoutUser_projetNestedInput
    sourced_by_projets?: projet_sourcing_contactUncheckedUpdateManyWithoutSourced_user_projetNestedInput
  }

  export type user_projetUncheckedUpdateManyWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    email_address?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleProjetFieldUpdateOperationsInput | $Enums.RoleProjet
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation_token?: NullableStringFieldUpdateOperationsInput | string | null
    invitation_status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    nb_views?: NullableIntFieldUpdateOperationsInput | number | null
    last_viewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projet_sourcing_contactUpdateWithoutProjetInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sourced_user_projet?: user_projetUpdateOneRequiredWithoutSourced_by_projetsNestedInput
    creator?: UserUpdateOneRequiredWithoutSourcing_contacts_createdNestedInput
  }

  export type projet_sourcing_contactUncheckedUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    sourced_user_projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type projet_sourcing_contactUncheckedUpdateManyWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    sourced_user_projet_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: StringFieldUpdateOperationsInput | string
  }

  export type projet_ficheUpdateWithoutProjetInput = {
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: UserUpdateOneRequiredWithoutFichesNestedInput
  }

  export type projet_ficheUncheckedUpdateWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type projet_ficheUncheckedUpdateManyWithoutProjetInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiche_id?: IntFieldUpdateOperationsInput | number
    type?: EnumFicheTypeFieldUpdateOperationsInput | $Enums.FicheType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type diagnostic_simulationUpdateWithoutProjetInput = {
    id?: StringFieldUpdateOperationsInput | string
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutDiagnostic_simulationNestedInput
  }

  export type diagnostic_simulationUncheckedUpdateWithoutProjetInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type diagnostic_simulationUncheckedUpdateManyWithoutProjetInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    initial_values?: NullableJsonNullValueInput | InputJsonValue
    validated?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type estimations_aidesCreateManyEstimationInput = {
    id?: number
    aideId: number
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type estimation_fiche_solutionCreateManyEstimationInput = {
    id?: string
    fiche_solution_id: number
    quantite?: number | null
    cout_min_investissement: number
    cout_max_investissement: number
    cout_min_entretien: number
    cout_max_entretien: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimations_aidesUpdateWithoutEstimationInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aide?: aideUpdateOneRequiredWithoutEstimations_aidesNestedInput
    created_by?: UserUpdateOneWithoutEstimations_aidesNestedInput
  }

  export type estimations_aidesUncheckedUpdateWithoutEstimationInput = {
    id?: IntFieldUpdateOperationsInput | number
    aideId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimations_aidesUncheckedUpdateManyWithoutEstimationInput = {
    id?: IntFieldUpdateOperationsInput | number
    aideId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimation_fiche_solutionUpdateWithoutEstimationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
    estimation_materiaux?: estimation_materiauxUpdateManyWithoutEstimation_fiche_solutionNestedInput
  }

  export type estimation_fiche_solutionUncheckedUpdateWithoutEstimationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
    estimation_materiaux?: estimation_materiauxUncheckedUpdateManyWithoutEstimation_fiche_solutionNestedInput
  }

  export type estimation_fiche_solutionUncheckedUpdateManyWithoutEstimationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiche_solution_id?: IntFieldUpdateOperationsInput | number
    quantite?: NullableIntFieldUpdateOperationsInput | number | null
    cout_min_investissement?: IntFieldUpdateOperationsInput | number
    cout_max_investissement?: IntFieldUpdateOperationsInput | number
    cout_min_entretien?: IntFieldUpdateOperationsInput | number
    cout_max_entretien?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimations_aidesCreateManyAideInput = {
    id?: number
    estimationId: number
    created_at?: Date | string | null
    user_id?: string | null
  }

  export type estimations_aidesUpdateWithoutAideInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimation?: estimationUpdateOneRequiredWithoutEstimations_aidesNestedInput
    created_by?: UserUpdateOneWithoutEstimations_aidesNestedInput
  }

  export type estimations_aidesUncheckedUpdateWithoutAideInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimationId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimations_aidesUncheckedUpdateManyWithoutAideInput = {
    id?: IntFieldUpdateOperationsInput | number
    estimationId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estimation_materiauxCreateManyEstimation_fiche_solutionInput = {
    id?: string
    materiau_id: number
    quantite: number
    cout_investissement_override?: number | null
    cout_entretien_override?: number | null
  }

  export type estimation_materiauxUpdateWithoutEstimation_fiche_solutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimation_materiauxUncheckedUpdateWithoutEstimation_fiche_solutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type estimation_materiauxUncheckedUpdateManyWithoutEstimation_fiche_solutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    materiau_id?: IntFieldUpdateOperationsInput | number
    quantite?: IntFieldUpdateOperationsInput | number
    cout_investissement_override?: NullableIntFieldUpdateOperationsInput | number | null
    cout_entretien_override?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}